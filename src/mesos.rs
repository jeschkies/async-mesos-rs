// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct FrameworkID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FrameworkID {}

impl FrameworkID {
    pub fn new() -> FrameworkID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkID {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkID,
        };
        unsafe {
            instance.get(FrameworkID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for FrameworkID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkID {
    fn new() -> FrameworkID {
        FrameworkID::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    FrameworkID::get_value_for_reflect,
                    FrameworkID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkID>(
                    "FrameworkID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FrameworkID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameworkID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OfferID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OfferID {}

impl OfferID {
    pub fn new() -> OfferID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OfferID {
        static mut instance: ::protobuf::lazy::Lazy<OfferID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OfferID,
        };
        unsafe {
            instance.get(OfferID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for OfferID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OfferID {
    fn new() -> OfferID {
        OfferID::new()
    }

    fn descriptor_static(_: ::std::option::Option<OfferID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    OfferID::get_value_for_reflect,
                    OfferID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OfferID>(
                    "OfferID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OfferID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AgentID {}

impl AgentID {
    pub fn new() -> AgentID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AgentID {
        static mut instance: ::protobuf::lazy::Lazy<AgentID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentID,
        };
        unsafe {
            instance.get(AgentID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for AgentID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AgentID {
    fn new() -> AgentID {
        AgentID::new()
    }

    fn descriptor_static(_: ::std::option::Option<AgentID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    AgentID::get_value_for_reflect,
                    AgentID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentID>(
                    "AgentID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AgentID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskID {}

impl TaskID {
    pub fn new() -> TaskID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskID {
        static mut instance: ::protobuf::lazy::Lazy<TaskID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskID,
        };
        unsafe {
            instance.get(TaskID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for TaskID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskID {
    fn new() -> TaskID {
        TaskID::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    TaskID::get_value_for_reflect,
                    TaskID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskID>(
                    "TaskID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutorID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ExecutorID {}

impl ExecutorID {
    pub fn new() -> ExecutorID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ExecutorID {
        static mut instance: ::protobuf::lazy::Lazy<ExecutorID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutorID,
        };
        unsafe {
            instance.get(ExecutorID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for ExecutorID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ExecutorID {
    fn new() -> ExecutorID {
        ExecutorID::new()
    }

    fn descriptor_static(_: ::std::option::Option<ExecutorID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    ExecutorID::get_value_for_reflect,
                    ExecutorID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutorID>(
                    "ExecutorID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ExecutorID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutorID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutorID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    parent: ::protobuf::SingularPtrField<ContainerID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerID {}

impl ContainerID {
    pub fn new() -> ContainerID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerID {
        static mut instance: ::protobuf::lazy::Lazy<ContainerID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerID,
        };
        unsafe {
            instance.get(ContainerID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }

    // optional .mesos.v1.ContainerID parent = 2;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ContainerID) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ContainerID {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> ContainerID {
        self.parent.take().unwrap_or_else(|| ContainerID::new())
    }

    pub fn get_parent(&self) -> &ContainerID {
        self.parent.as_ref().unwrap_or_else(|| ContainerID::default_instance())
    }

    fn get_parent_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerID> {
        &self.parent
    }

    fn mut_parent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerID> {
        &mut self.parent
    }
}

impl ::protobuf::Message for ContainerID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerID {
    fn new() -> ContainerID {
        ContainerID::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    ContainerID::get_value_for_reflect,
                    ContainerID::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerID>>(
                    "parent",
                    ContainerID::get_parent_for_reflect,
                    ContainerID::mut_parent_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerID>(
                    "ContainerID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerID {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_parent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceProviderID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceProviderID {}

impl ResourceProviderID {
    pub fn new() -> ResourceProviderID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceProviderID {
        static mut instance: ::protobuf::lazy::Lazy<ResourceProviderID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceProviderID,
        };
        unsafe {
            instance.get(ResourceProviderID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for ResourceProviderID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceProviderID {
    fn new() -> ResourceProviderID {
        ResourceProviderID::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceProviderID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    ResourceProviderID::get_value_for_reflect,
                    ResourceProviderID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceProviderID>(
                    "ResourceProviderID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceProviderID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceProviderID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceProviderID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OperationID {}

impl OperationID {
    pub fn new() -> OperationID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OperationID {
        static mut instance: ::protobuf::lazy::Lazy<OperationID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationID,
        };
        unsafe {
            instance.get(OperationID::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for OperationID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OperationID {
    fn new() -> OperationID {
        OperationID::new()
    }

    fn descriptor_static(_: ::std::option::Option<OperationID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    OperationID::get_value_for_reflect,
                    OperationID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationID>(
                    "OperationID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OperationID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeInfo {
    // message fields
    nanoseconds: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TimeInfo {}

impl TimeInfo {
    pub fn new() -> TimeInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TimeInfo {
        static mut instance: ::protobuf::lazy::Lazy<TimeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeInfo,
        };
        unsafe {
            instance.get(TimeInfo::new)
        }
    }

    // required int64 nanoseconds = 1;

    pub fn clear_nanoseconds(&mut self) {
        self.nanoseconds = ::std::option::Option::None;
    }

    pub fn has_nanoseconds(&self) -> bool {
        self.nanoseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanoseconds(&mut self, v: i64) {
        self.nanoseconds = ::std::option::Option::Some(v);
    }

    pub fn get_nanoseconds(&self) -> i64 {
        self.nanoseconds.unwrap_or(0)
    }

    fn get_nanoseconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.nanoseconds
    }

    fn mut_nanoseconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.nanoseconds
    }
}

impl ::protobuf::Message for TimeInfo {
    fn is_initialized(&self) -> bool {
        if self.nanoseconds.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nanoseconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.nanoseconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nanoseconds {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TimeInfo {
    fn new() -> TimeInfo {
        TimeInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<TimeInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nanoseconds",
                    TimeInfo::get_nanoseconds_for_reflect,
                    TimeInfo::mut_nanoseconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeInfo>(
                    "TimeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TimeInfo {
    fn clear(&mut self) {
        self.clear_nanoseconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DurationInfo {
    // message fields
    nanoseconds: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DurationInfo {}

impl DurationInfo {
    pub fn new() -> DurationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DurationInfo {
        static mut instance: ::protobuf::lazy::Lazy<DurationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DurationInfo,
        };
        unsafe {
            instance.get(DurationInfo::new)
        }
    }

    // required int64 nanoseconds = 1;

    pub fn clear_nanoseconds(&mut self) {
        self.nanoseconds = ::std::option::Option::None;
    }

    pub fn has_nanoseconds(&self) -> bool {
        self.nanoseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanoseconds(&mut self, v: i64) {
        self.nanoseconds = ::std::option::Option::Some(v);
    }

    pub fn get_nanoseconds(&self) -> i64 {
        self.nanoseconds.unwrap_or(0)
    }

    fn get_nanoseconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.nanoseconds
    }

    fn mut_nanoseconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.nanoseconds
    }
}

impl ::protobuf::Message for DurationInfo {
    fn is_initialized(&self) -> bool {
        if self.nanoseconds.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nanoseconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.nanoseconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nanoseconds {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DurationInfo {
    fn new() -> DurationInfo {
        DurationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DurationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nanoseconds",
                    DurationInfo::get_nanoseconds_for_reflect,
                    DurationInfo::mut_nanoseconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DurationInfo>(
                    "DurationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DurationInfo {
    fn clear(&mut self) {
        self.clear_nanoseconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DurationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DurationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Address {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    ip: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Address {}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Address {
        static mut instance: ::protobuf::lazy::Lazy<Address> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Address,
        };
        unsafe {
            instance.get(Address::new)
        }
    }

    // optional string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional string ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ip_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ip
    }

    // required int32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.port
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Address {
    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static(_: ::std::option::Option<Address>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    Address::get_hostname_for_reflect,
                    Address::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    Address::get_ip_for_reflect,
                    Address::mut_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    Address::get_port_for_reflect,
                    Address::mut_port_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Address>(
                    "Address",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_ip();
        self.clear_port();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct URL {
    // message fields
    scheme: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularPtrField<Address>,
    path: ::protobuf::SingularField<::std::string::String>,
    query: ::protobuf::RepeatedField<Parameter>,
    fragment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for URL {}

impl URL {
    pub fn new() -> URL {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static URL {
        static mut instance: ::protobuf::lazy::Lazy<URL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const URL,
        };
        unsafe {
            instance.get(URL::new)
        }
    }

    // required string scheme = 1;

    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut ::std::string::String {
        if self.scheme.is_none() {
            self.scheme.set_default();
        }
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        self.scheme.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_scheme(&self) -> &str {
        match self.scheme.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_scheme_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.scheme
    }

    fn mut_scheme_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.scheme
    }

    // required .mesos.v1.Address address = 2;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| Address::default_instance())
    }

    fn get_address_for_reflect(&self) -> &::protobuf::SingularPtrField<Address> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Address> {
        &mut self.address
    }

    // optional string path = 3;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // repeated .mesos.v1.Parameter query = 4;

    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.query = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut ::protobuf::RepeatedField<Parameter> {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.query, ::protobuf::RepeatedField::new())
    }

    pub fn get_query(&self) -> &[Parameter] {
        &self.query
    }

    fn get_query_for_reflect(&self) -> &::protobuf::RepeatedField<Parameter> {
        &self.query
    }

    fn mut_query_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Parameter> {
        &mut self.query
    }

    // optional string fragment = 5;

    pub fn clear_fragment(&mut self) {
        self.fragment.clear();
    }

    pub fn has_fragment(&self) -> bool {
        self.fragment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fragment(&mut self, v: ::std::string::String) {
        self.fragment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fragment(&mut self) -> &mut ::std::string::String {
        if self.fragment.is_none() {
            self.fragment.set_default();
        }
        self.fragment.as_mut().unwrap()
    }

    // Take field
    pub fn take_fragment(&mut self) -> ::std::string::String {
        self.fragment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fragment(&self) -> &str {
        match self.fragment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fragment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fragment
    }

    fn mut_fragment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fragment
    }
}

impl ::protobuf::Message for URL {
    fn is_initialized(&self) -> bool {
        if self.scheme.is_none() {
            return false;
        }
        if self.address.is_none() {
            return false;
        }
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.scheme)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.query)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fragment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scheme.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.query {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fragment.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scheme.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.query {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fragment.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for URL {
    fn new() -> URL {
        URL::new()
    }

    fn descriptor_static(_: ::std::option::Option<URL>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scheme",
                    URL::get_scheme_for_reflect,
                    URL::mut_scheme_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "address",
                    URL::get_address_for_reflect,
                    URL::mut_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    URL::get_path_for_reflect,
                    URL::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Parameter>>(
                    "query",
                    URL::get_query_for_reflect,
                    URL::mut_query_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fragment",
                    URL::get_fragment_for_reflect,
                    URL::mut_fragment_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<URL>(
                    "URL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for URL {
    fn clear(&mut self) {
        self.clear_scheme();
        self.clear_address();
        self.clear_path();
        self.clear_query();
        self.clear_fragment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for URL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for URL {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Unavailability {
    // message fields
    start: ::protobuf::SingularPtrField<TimeInfo>,
    duration: ::protobuf::SingularPtrField<DurationInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Unavailability {}

impl Unavailability {
    pub fn new() -> Unavailability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Unavailability {
        static mut instance: ::protobuf::lazy::Lazy<Unavailability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Unavailability,
        };
        unsafe {
            instance.get(Unavailability::new)
        }
    }

    // required .mesos.v1.TimeInfo start = 1;

    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: TimeInfo) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut TimeInfo {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> TimeInfo {
        self.start.take().unwrap_or_else(|| TimeInfo::new())
    }

    pub fn get_start(&self) -> &TimeInfo {
        self.start.as_ref().unwrap_or_else(|| TimeInfo::default_instance())
    }

    fn get_start_for_reflect(&self) -> &::protobuf::SingularPtrField<TimeInfo> {
        &self.start
    }

    fn mut_start_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TimeInfo> {
        &mut self.start
    }

    // optional .mesos.v1.DurationInfo duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: DurationInfo) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut DurationInfo {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> DurationInfo {
        self.duration.take().unwrap_or_else(|| DurationInfo::new())
    }

    pub fn get_duration(&self) -> &DurationInfo {
        self.duration.as_ref().unwrap_or_else(|| DurationInfo::default_instance())
    }

    fn get_duration_for_reflect(&self) -> &::protobuf::SingularPtrField<DurationInfo> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DurationInfo> {
        &mut self.duration
    }
}

impl ::protobuf::Message for Unavailability {
    fn is_initialized(&self) -> bool {
        if self.start.is_none() {
            return false;
        }
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Unavailability {
    fn new() -> Unavailability {
        Unavailability::new()
    }

    fn descriptor_static(_: ::std::option::Option<Unavailability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeInfo>>(
                    "start",
                    Unavailability::get_start_for_reflect,
                    Unavailability::mut_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DurationInfo>>(
                    "duration",
                    Unavailability::get_duration_for_reflect,
                    Unavailability::mut_duration_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Unavailability>(
                    "Unavailability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Unavailability {
    fn clear(&mut self) {
        self.clear_start();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Unavailability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unavailability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MachineID {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    ip: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MachineID {}

impl MachineID {
    pub fn new() -> MachineID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MachineID {
        static mut instance: ::protobuf::lazy::Lazy<MachineID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MachineID,
        };
        unsafe {
            instance.get(MachineID::new)
        }
    }

    // optional string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional string ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ip_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ip
    }
}

impl ::protobuf::Message for MachineID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MachineID {
    fn new() -> MachineID {
        MachineID::new()
    }

    fn descriptor_static(_: ::std::option::Option<MachineID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    MachineID::get_hostname_for_reflect,
                    MachineID::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    MachineID::get_ip_for_reflect,
                    MachineID::mut_ip_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MachineID>(
                    "MachineID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MachineID {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_ip();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MachineID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MachineID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MachineInfo {
    // message fields
    id: ::protobuf::SingularPtrField<MachineID>,
    mode: ::std::option::Option<MachineInfo_Mode>,
    unavailability: ::protobuf::SingularPtrField<Unavailability>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MachineInfo {}

impl MachineInfo {
    pub fn new() -> MachineInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MachineInfo {
        static mut instance: ::protobuf::lazy::Lazy<MachineInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MachineInfo,
        };
        unsafe {
            instance.get(MachineInfo::new)
        }
    }

    // required .mesos.v1.MachineID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: MachineID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut MachineID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> MachineID {
        self.id.take().unwrap_or_else(|| MachineID::new())
    }

    pub fn get_id(&self) -> &MachineID {
        self.id.as_ref().unwrap_or_else(|| MachineID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<MachineID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<MachineID> {
        &mut self.id
    }

    // optional .mesos.v1.MachineInfo.Mode mode = 2;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: MachineInfo_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> MachineInfo_Mode {
        self.mode.unwrap_or(MachineInfo_Mode::UP)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<MachineInfo_Mode> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<MachineInfo_Mode> {
        &mut self.mode
    }

    // optional .mesos.v1.Unavailability unavailability = 3;

    pub fn clear_unavailability(&mut self) {
        self.unavailability.clear();
    }

    pub fn has_unavailability(&self) -> bool {
        self.unavailability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailability(&mut self, v: Unavailability) {
        self.unavailability = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unavailability(&mut self) -> &mut Unavailability {
        if self.unavailability.is_none() {
            self.unavailability.set_default();
        }
        self.unavailability.as_mut().unwrap()
    }

    // Take field
    pub fn take_unavailability(&mut self) -> Unavailability {
        self.unavailability.take().unwrap_or_else(|| Unavailability::new())
    }

    pub fn get_unavailability(&self) -> &Unavailability {
        self.unavailability.as_ref().unwrap_or_else(|| Unavailability::default_instance())
    }

    fn get_unavailability_for_reflect(&self) -> &::protobuf::SingularPtrField<Unavailability> {
        &self.unavailability
    }

    fn mut_unavailability_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Unavailability> {
        &mut self.unavailability
    }
}

impl ::protobuf::Message for MachineInfo {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unavailability {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unavailability)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.unavailability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.unavailability.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MachineInfo {
    fn new() -> MachineInfo {
        MachineInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<MachineInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MachineID>>(
                    "id",
                    MachineInfo::get_id_for_reflect,
                    MachineInfo::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MachineInfo_Mode>>(
                    "mode",
                    MachineInfo::get_mode_for_reflect,
                    MachineInfo::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unavailability>>(
                    "unavailability",
                    MachineInfo::get_unavailability_for_reflect,
                    MachineInfo::mut_unavailability_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MachineInfo>(
                    "MachineInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MachineInfo {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_mode();
        self.clear_unavailability();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MachineInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MachineInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MachineInfo_Mode {
    UP = 1,
    DRAINING = 2,
    DOWN = 3,
}

impl ::protobuf::ProtobufEnum for MachineInfo_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MachineInfo_Mode> {
        match value {
            1 => ::std::option::Option::Some(MachineInfo_Mode::UP),
            2 => ::std::option::Option::Some(MachineInfo_Mode::DRAINING),
            3 => ::std::option::Option::Some(MachineInfo_Mode::DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MachineInfo_Mode] = &[
            MachineInfo_Mode::UP,
            MachineInfo_Mode::DRAINING,
            MachineInfo_Mode::DOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<MachineInfo_Mode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MachineInfo_Mode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MachineInfo_Mode {
}

impl ::protobuf::reflect::ProtobufValue for MachineInfo_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FrameworkInfo {
    // message fields
    user: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularPtrField<FrameworkID>,
    failover_timeout: ::std::option::Option<f64>,
    checkpoint: ::std::option::Option<bool>,
    role: ::protobuf::SingularField<::std::string::String>,
    roles: ::protobuf::RepeatedField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    principal: ::protobuf::SingularField<::std::string::String>,
    webui_url: ::protobuf::SingularField<::std::string::String>,
    capabilities: ::protobuf::RepeatedField<FrameworkInfo_Capability>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FrameworkInfo {}

impl FrameworkInfo {
    pub fn new() -> FrameworkInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkInfo {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkInfo,
        };
        unsafe {
            instance.get(FrameworkInfo::new)
        }
    }

    // required string user = 1;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user
    }

    fn mut_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user
    }

    // required string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional .mesos.v1.FrameworkID id = 3;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: FrameworkID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut FrameworkID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> FrameworkID {
        self.id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_id(&self) -> &FrameworkID {
        self.id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<FrameworkID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FrameworkID> {
        &mut self.id
    }

    // optional double failover_timeout = 4;

    pub fn clear_failover_timeout(&mut self) {
        self.failover_timeout = ::std::option::Option::None;
    }

    pub fn has_failover_timeout(&self) -> bool {
        self.failover_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failover_timeout(&mut self, v: f64) {
        self.failover_timeout = ::std::option::Option::Some(v);
    }

    pub fn get_failover_timeout(&self) -> f64 {
        self.failover_timeout.unwrap_or(0f64)
    }

    fn get_failover_timeout_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.failover_timeout
    }

    fn mut_failover_timeout_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.failover_timeout
    }

    // optional bool checkpoint = 5;

    pub fn clear_checkpoint(&mut self) {
        self.checkpoint = ::std::option::Option::None;
    }

    pub fn has_checkpoint(&self) -> bool {
        self.checkpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint(&mut self, v: bool) {
        self.checkpoint = ::std::option::Option::Some(v);
    }

    pub fn get_checkpoint(&self) -> bool {
        self.checkpoint.unwrap_or(false)
    }

    fn get_checkpoint_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.checkpoint
    }

    fn mut_checkpoint_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.checkpoint
    }

    // optional string role = 6;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "*",
        }
    }

    fn get_role_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.role
    }

    // repeated string roles = 12;

    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }

    pub fn get_roles(&self) -> &[::std::string::String] {
        &self.roles
    }

    fn get_roles_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.roles
    }

    fn mut_roles_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // optional string hostname = 7;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional string principal = 8;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal(&mut self) -> &mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        }
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal(&self) -> &str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_principal_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.principal
    }

    fn mut_principal_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.principal
    }

    // optional string webui_url = 9;

    pub fn clear_webui_url(&mut self) {
        self.webui_url.clear();
    }

    pub fn has_webui_url(&self) -> bool {
        self.webui_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webui_url(&mut self, v: ::std::string::String) {
        self.webui_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webui_url(&mut self) -> &mut ::std::string::String {
        if self.webui_url.is_none() {
            self.webui_url.set_default();
        }
        self.webui_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_webui_url(&mut self) -> ::std::string::String {
        self.webui_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_webui_url(&self) -> &str {
        match self.webui_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_webui_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.webui_url
    }

    fn mut_webui_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.webui_url
    }

    // repeated .mesos.v1.FrameworkInfo.Capability capabilities = 10;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::protobuf::RepeatedField<FrameworkInfo_Capability>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities(&mut self) -> &mut ::protobuf::RepeatedField<FrameworkInfo_Capability> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::protobuf::RepeatedField<FrameworkInfo_Capability> {
        ::std::mem::replace(&mut self.capabilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_capabilities(&self) -> &[FrameworkInfo_Capability] {
        &self.capabilities
    }

    fn get_capabilities_for_reflect(&self) -> &::protobuf::RepeatedField<FrameworkInfo_Capability> {
        &self.capabilities
    }

    fn mut_capabilities_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<FrameworkInfo_Capability> {
        &mut self.capabilities
    }

    // optional .mesos.v1.Labels labels = 11;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }
}

impl ::protobuf::Message for FrameworkInfo {
    fn is_initialized(&self) -> bool {
        if self.user.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.failover_timeout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkpoint = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.roles)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.webui_url)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.capabilities)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.failover_timeout {
            my_size += 9;
        }
        if let Some(v) = self.checkpoint {
            my_size += 2;
        }
        if let Some(ref v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.roles {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.principal.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.webui_url.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.capabilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.failover_timeout {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.checkpoint {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.role.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.roles {
            os.write_string(12, &v)?;
        };
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.principal.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.webui_url.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.capabilities {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkInfo {
    fn new() -> FrameworkInfo {
        FrameworkInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    FrameworkInfo::get_user_for_reflect,
                    FrameworkInfo::mut_user_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    FrameworkInfo::get_name_for_reflect,
                    FrameworkInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkID>>(
                    "id",
                    FrameworkInfo::get_id_for_reflect,
                    FrameworkInfo::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "failover_timeout",
                    FrameworkInfo::get_failover_timeout_for_reflect,
                    FrameworkInfo::mut_failover_timeout_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "checkpoint",
                    FrameworkInfo::get_checkpoint_for_reflect,
                    FrameworkInfo::mut_checkpoint_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    FrameworkInfo::get_role_for_reflect,
                    FrameworkInfo::mut_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "roles",
                    FrameworkInfo::get_roles_for_reflect,
                    FrameworkInfo::mut_roles_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    FrameworkInfo::get_hostname_for_reflect,
                    FrameworkInfo::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "principal",
                    FrameworkInfo::get_principal_for_reflect,
                    FrameworkInfo::mut_principal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "webui_url",
                    FrameworkInfo::get_webui_url_for_reflect,
                    FrameworkInfo::mut_webui_url_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkInfo_Capability>>(
                    "capabilities",
                    FrameworkInfo::get_capabilities_for_reflect,
                    FrameworkInfo::mut_capabilities_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    FrameworkInfo::get_labels_for_reflect,
                    FrameworkInfo::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkInfo>(
                    "FrameworkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkInfo {
    fn clear(&mut self) {
        self.clear_user();
        self.clear_name();
        self.clear_id();
        self.clear_failover_timeout();
        self.clear_checkpoint();
        self.clear_role();
        self.clear_roles();
        self.clear_hostname();
        self.clear_principal();
        self.clear_webui_url();
        self.clear_capabilities();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FrameworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameworkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FrameworkInfo_Capability {
    // message fields
    field_type: ::std::option::Option<FrameworkInfo_Capability_Type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FrameworkInfo_Capability {}

impl FrameworkInfo_Capability {
    pub fn new() -> FrameworkInfo_Capability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkInfo_Capability {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkInfo_Capability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkInfo_Capability,
        };
        unsafe {
            instance.get(FrameworkInfo_Capability::new)
        }
    }

    // optional .mesos.v1.FrameworkInfo.Capability.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: FrameworkInfo_Capability_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> FrameworkInfo_Capability_Type {
        self.field_type.unwrap_or(FrameworkInfo_Capability_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<FrameworkInfo_Capability_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<FrameworkInfo_Capability_Type> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for FrameworkInfo_Capability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkInfo_Capability {
    fn new() -> FrameworkInfo_Capability {
        FrameworkInfo_Capability::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkInfo_Capability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FrameworkInfo_Capability_Type>>(
                    "type",
                    FrameworkInfo_Capability::get_field_type_for_reflect,
                    FrameworkInfo_Capability::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkInfo_Capability>(
                    "FrameworkInfo_Capability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkInfo_Capability {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FrameworkInfo_Capability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameworkInfo_Capability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FrameworkInfo_Capability_Type {
    UNKNOWN = 0,
    REVOCABLE_RESOURCES = 1,
    TASK_KILLING_STATE = 2,
    GPU_RESOURCES = 3,
    SHARED_RESOURCES = 4,
    PARTITION_AWARE = 5,
    MULTI_ROLE = 6,
    RESERVATION_REFINEMENT = 7,
    REGION_AWARE = 8,
}

impl ::protobuf::ProtobufEnum for FrameworkInfo_Capability_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FrameworkInfo_Capability_Type> {
        match value {
            0 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::UNKNOWN),
            1 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::REVOCABLE_RESOURCES),
            2 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::TASK_KILLING_STATE),
            3 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::GPU_RESOURCES),
            4 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::SHARED_RESOURCES),
            5 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::PARTITION_AWARE),
            6 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::MULTI_ROLE),
            7 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::RESERVATION_REFINEMENT),
            8 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::REGION_AWARE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FrameworkInfo_Capability_Type] = &[
            FrameworkInfo_Capability_Type::UNKNOWN,
            FrameworkInfo_Capability_Type::REVOCABLE_RESOURCES,
            FrameworkInfo_Capability_Type::TASK_KILLING_STATE,
            FrameworkInfo_Capability_Type::GPU_RESOURCES,
            FrameworkInfo_Capability_Type::SHARED_RESOURCES,
            FrameworkInfo_Capability_Type::PARTITION_AWARE,
            FrameworkInfo_Capability_Type::MULTI_ROLE,
            FrameworkInfo_Capability_Type::RESERVATION_REFINEMENT,
            FrameworkInfo_Capability_Type::REGION_AWARE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<FrameworkInfo_Capability_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FrameworkInfo_Capability_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FrameworkInfo_Capability_Type {
}

impl ::protobuf::reflect::ProtobufValue for FrameworkInfo_Capability_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckInfo {
    // message fields
    field_type: ::std::option::Option<CheckInfo_Type>,
    command: ::protobuf::SingularPtrField<CheckInfo_Command>,
    http: ::protobuf::SingularPtrField<CheckInfo_Http>,
    tcp: ::protobuf::SingularPtrField<CheckInfo_Tcp>,
    delay_seconds: ::std::option::Option<f64>,
    interval_seconds: ::std::option::Option<f64>,
    timeout_seconds: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckInfo {}

impl CheckInfo {
    pub fn new() -> CheckInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckInfo {
        static mut instance: ::protobuf::lazy::Lazy<CheckInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckInfo,
        };
        unsafe {
            instance.get(CheckInfo::new)
        }
    }

    // optional .mesos.v1.CheckInfo.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CheckInfo_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> CheckInfo_Type {
        self.field_type.unwrap_or(CheckInfo_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<CheckInfo_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<CheckInfo_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.CheckInfo.Command command = 2;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CheckInfo_Command) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut CheckInfo_Command {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CheckInfo_Command {
        self.command.take().unwrap_or_else(|| CheckInfo_Command::new())
    }

    pub fn get_command(&self) -> &CheckInfo_Command {
        self.command.as_ref().unwrap_or_else(|| CheckInfo_Command::default_instance())
    }

    fn get_command_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckInfo_Command> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckInfo_Command> {
        &mut self.command
    }

    // optional .mesos.v1.CheckInfo.Http http = 3;

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: CheckInfo_Http) {
        self.http = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http(&mut self) -> &mut CheckInfo_Http {
        if self.http.is_none() {
            self.http.set_default();
        }
        self.http.as_mut().unwrap()
    }

    // Take field
    pub fn take_http(&mut self) -> CheckInfo_Http {
        self.http.take().unwrap_or_else(|| CheckInfo_Http::new())
    }

    pub fn get_http(&self) -> &CheckInfo_Http {
        self.http.as_ref().unwrap_or_else(|| CheckInfo_Http::default_instance())
    }

    fn get_http_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckInfo_Http> {
        &self.http
    }

    fn mut_http_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckInfo_Http> {
        &mut self.http
    }

    // optional .mesos.v1.CheckInfo.Tcp tcp = 7;

    pub fn clear_tcp(&mut self) {
        self.tcp.clear();
    }

    pub fn has_tcp(&self) -> bool {
        self.tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp(&mut self, v: CheckInfo_Tcp) {
        self.tcp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcp(&mut self) -> &mut CheckInfo_Tcp {
        if self.tcp.is_none() {
            self.tcp.set_default();
        }
        self.tcp.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcp(&mut self) -> CheckInfo_Tcp {
        self.tcp.take().unwrap_or_else(|| CheckInfo_Tcp::new())
    }

    pub fn get_tcp(&self) -> &CheckInfo_Tcp {
        self.tcp.as_ref().unwrap_or_else(|| CheckInfo_Tcp::default_instance())
    }

    fn get_tcp_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckInfo_Tcp> {
        &self.tcp
    }

    fn mut_tcp_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckInfo_Tcp> {
        &mut self.tcp
    }

    // optional double delay_seconds = 4;

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_delay_seconds(&self) -> f64 {
        self.delay_seconds.unwrap_or(15f64)
    }

    fn get_delay_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.delay_seconds
    }

    fn mut_delay_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.delay_seconds
    }

    // optional double interval_seconds = 5;

    pub fn clear_interval_seconds(&mut self) {
        self.interval_seconds = ::std::option::Option::None;
    }

    pub fn has_interval_seconds(&self) -> bool {
        self.interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval_seconds(&mut self, v: f64) {
        self.interval_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_interval_seconds(&self) -> f64 {
        self.interval_seconds.unwrap_or(10f64)
    }

    fn get_interval_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.interval_seconds
    }

    fn mut_interval_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.interval_seconds
    }

    // optional double timeout_seconds = 6;

    pub fn clear_timeout_seconds(&mut self) {
        self.timeout_seconds = ::std::option::Option::None;
    }

    pub fn has_timeout_seconds(&self) -> bool {
        self.timeout_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_seconds(&mut self, v: f64) {
        self.timeout_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_timeout_seconds(&self) -> f64 {
        self.timeout_seconds.unwrap_or(20f64)
    }

    fn get_timeout_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.timeout_seconds
    }

    fn mut_timeout_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.timeout_seconds
    }
}

impl ::protobuf::Message for CheckInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.http {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcp)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.delay_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.interval_seconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timeout_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.http.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tcp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.delay_seconds {
            my_size += 9;
        }
        if let Some(v) = self.interval_seconds {
            my_size += 9;
        }
        if let Some(v) = self.timeout_seconds {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.http.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tcp.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.delay_seconds {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.interval_seconds {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.timeout_seconds {
            os.write_double(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckInfo {
    fn new() -> CheckInfo {
        CheckInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CheckInfo_Type>>(
                    "type",
                    CheckInfo::get_field_type_for_reflect,
                    CheckInfo::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckInfo_Command>>(
                    "command",
                    CheckInfo::get_command_for_reflect,
                    CheckInfo::mut_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckInfo_Http>>(
                    "http",
                    CheckInfo::get_http_for_reflect,
                    CheckInfo::mut_http_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckInfo_Tcp>>(
                    "tcp",
                    CheckInfo::get_tcp_for_reflect,
                    CheckInfo::mut_tcp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "delay_seconds",
                    CheckInfo::get_delay_seconds_for_reflect,
                    CheckInfo::mut_delay_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "interval_seconds",
                    CheckInfo::get_interval_seconds_for_reflect,
                    CheckInfo::mut_interval_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "timeout_seconds",
                    CheckInfo::get_timeout_seconds_for_reflect,
                    CheckInfo::mut_timeout_seconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckInfo>(
                    "CheckInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_command();
        self.clear_http();
        self.clear_tcp();
        self.clear_delay_seconds();
        self.clear_interval_seconds();
        self.clear_timeout_seconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckInfo_Command {
    // message fields
    command: ::protobuf::SingularPtrField<CommandInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckInfo_Command {}

impl CheckInfo_Command {
    pub fn new() -> CheckInfo_Command {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckInfo_Command {
        static mut instance: ::protobuf::lazy::Lazy<CheckInfo_Command> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckInfo_Command,
        };
        unsafe {
            instance.get(CheckInfo_Command::new)
        }
    }

    // required .mesos.v1.CommandInfo command = 1;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command(&self) -> &CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    fn get_command_for_reflect(&self) -> &::protobuf::SingularPtrField<CommandInfo> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CommandInfo> {
        &mut self.command
    }
}

impl ::protobuf::Message for CheckInfo_Command {
    fn is_initialized(&self) -> bool {
        if self.command.is_none() {
            return false;
        }
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckInfo_Command {
    fn new() -> CheckInfo_Command {
        CheckInfo_Command::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckInfo_Command>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandInfo>>(
                    "command",
                    CheckInfo_Command::get_command_for_reflect,
                    CheckInfo_Command::mut_command_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckInfo_Command>(
                    "CheckInfo_Command",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckInfo_Command {
    fn clear(&mut self) {
        self.clear_command();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckInfo_Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckInfo_Command {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckInfo_Http {
    // message fields
    port: ::std::option::Option<u32>,
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckInfo_Http {}

impl CheckInfo_Http {
    pub fn new() -> CheckInfo_Http {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckInfo_Http {
        static mut instance: ::protobuf::lazy::Lazy<CheckInfo_Http> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckInfo_Http,
        };
        unsafe {
            instance.get(CheckInfo_Http::new)
        }
    }

    // required uint32 port = 1;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.port
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for CheckInfo_Http {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.port {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckInfo_Http {
    fn new() -> CheckInfo_Http {
        CheckInfo_Http::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckInfo_Http>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    CheckInfo_Http::get_port_for_reflect,
                    CheckInfo_Http::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    CheckInfo_Http::get_path_for_reflect,
                    CheckInfo_Http::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckInfo_Http>(
                    "CheckInfo_Http",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckInfo_Http {
    fn clear(&mut self) {
        self.clear_port();
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckInfo_Http {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckInfo_Http {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckInfo_Tcp {
    // message fields
    port: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckInfo_Tcp {}

impl CheckInfo_Tcp {
    pub fn new() -> CheckInfo_Tcp {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckInfo_Tcp {
        static mut instance: ::protobuf::lazy::Lazy<CheckInfo_Tcp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckInfo_Tcp,
        };
        unsafe {
            instance.get(CheckInfo_Tcp::new)
        }
    }

    // required uint32 port = 1;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.port
    }
}

impl ::protobuf::Message for CheckInfo_Tcp {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.port {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckInfo_Tcp {
    fn new() -> CheckInfo_Tcp {
        CheckInfo_Tcp::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckInfo_Tcp>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    CheckInfo_Tcp::get_port_for_reflect,
                    CheckInfo_Tcp::mut_port_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckInfo_Tcp>(
                    "CheckInfo_Tcp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckInfo_Tcp {
    fn clear(&mut self) {
        self.clear_port();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckInfo_Tcp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckInfo_Tcp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CheckInfo_Type {
    UNKNOWN = 0,
    COMMAND = 1,
    HTTP = 2,
    TCP = 3,
}

impl ::protobuf::ProtobufEnum for CheckInfo_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CheckInfo_Type> {
        match value {
            0 => ::std::option::Option::Some(CheckInfo_Type::UNKNOWN),
            1 => ::std::option::Option::Some(CheckInfo_Type::COMMAND),
            2 => ::std::option::Option::Some(CheckInfo_Type::HTTP),
            3 => ::std::option::Option::Some(CheckInfo_Type::TCP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CheckInfo_Type] = &[
            CheckInfo_Type::UNKNOWN,
            CheckInfo_Type::COMMAND,
            CheckInfo_Type::HTTP,
            CheckInfo_Type::TCP,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CheckInfo_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CheckInfo_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CheckInfo_Type {
}

impl ::protobuf::reflect::ProtobufValue for CheckInfo_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck {
    // message fields
    delay_seconds: ::std::option::Option<f64>,
    interval_seconds: ::std::option::Option<f64>,
    timeout_seconds: ::std::option::Option<f64>,
    consecutive_failures: ::std::option::Option<u32>,
    grace_period_seconds: ::std::option::Option<f64>,
    field_type: ::std::option::Option<HealthCheck_Type>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    http: ::protobuf::SingularPtrField<HealthCheck_HTTPCheckInfo>,
    tcp: ::protobuf::SingularPtrField<HealthCheck_TCPCheckInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HealthCheck {}

impl HealthCheck {
    pub fn new() -> HealthCheck {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HealthCheck {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheck,
        };
        unsafe {
            instance.get(HealthCheck::new)
        }
    }

    // optional double delay_seconds = 2;

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_delay_seconds(&self) -> f64 {
        self.delay_seconds.unwrap_or(15f64)
    }

    fn get_delay_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.delay_seconds
    }

    fn mut_delay_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.delay_seconds
    }

    // optional double interval_seconds = 3;

    pub fn clear_interval_seconds(&mut self) {
        self.interval_seconds = ::std::option::Option::None;
    }

    pub fn has_interval_seconds(&self) -> bool {
        self.interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval_seconds(&mut self, v: f64) {
        self.interval_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_interval_seconds(&self) -> f64 {
        self.interval_seconds.unwrap_or(10f64)
    }

    fn get_interval_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.interval_seconds
    }

    fn mut_interval_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.interval_seconds
    }

    // optional double timeout_seconds = 4;

    pub fn clear_timeout_seconds(&mut self) {
        self.timeout_seconds = ::std::option::Option::None;
    }

    pub fn has_timeout_seconds(&self) -> bool {
        self.timeout_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_seconds(&mut self, v: f64) {
        self.timeout_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_timeout_seconds(&self) -> f64 {
        self.timeout_seconds.unwrap_or(20f64)
    }

    fn get_timeout_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.timeout_seconds
    }

    fn mut_timeout_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.timeout_seconds
    }

    // optional uint32 consecutive_failures = 5;

    pub fn clear_consecutive_failures(&mut self) {
        self.consecutive_failures = ::std::option::Option::None;
    }

    pub fn has_consecutive_failures(&self) -> bool {
        self.consecutive_failures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consecutive_failures(&mut self, v: u32) {
        self.consecutive_failures = ::std::option::Option::Some(v);
    }

    pub fn get_consecutive_failures(&self) -> u32 {
        self.consecutive_failures.unwrap_or(3u32)
    }

    fn get_consecutive_failures_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.consecutive_failures
    }

    fn mut_consecutive_failures_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.consecutive_failures
    }

    // optional double grace_period_seconds = 6;

    pub fn clear_grace_period_seconds(&mut self) {
        self.grace_period_seconds = ::std::option::Option::None;
    }

    pub fn has_grace_period_seconds(&self) -> bool {
        self.grace_period_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grace_period_seconds(&mut self, v: f64) {
        self.grace_period_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_grace_period_seconds(&self) -> f64 {
        self.grace_period_seconds.unwrap_or(10f64)
    }

    fn get_grace_period_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.grace_period_seconds
    }

    fn mut_grace_period_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.grace_period_seconds
    }

    // optional .mesos.v1.HealthCheck.Type type = 8;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: HealthCheck_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> HealthCheck_Type {
        self.field_type.unwrap_or(HealthCheck_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<HealthCheck_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<HealthCheck_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command(&self) -> &CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    fn get_command_for_reflect(&self) -> &::protobuf::SingularPtrField<CommandInfo> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CommandInfo> {
        &mut self.command
    }

    // optional .mesos.v1.HealthCheck.HTTPCheckInfo http = 1;

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HealthCheck_HTTPCheckInfo) {
        self.http = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http(&mut self) -> &mut HealthCheck_HTTPCheckInfo {
        if self.http.is_none() {
            self.http.set_default();
        }
        self.http.as_mut().unwrap()
    }

    // Take field
    pub fn take_http(&mut self) -> HealthCheck_HTTPCheckInfo {
        self.http.take().unwrap_or_else(|| HealthCheck_HTTPCheckInfo::new())
    }

    pub fn get_http(&self) -> &HealthCheck_HTTPCheckInfo {
        self.http.as_ref().unwrap_or_else(|| HealthCheck_HTTPCheckInfo::default_instance())
    }

    fn get_http_for_reflect(&self) -> &::protobuf::SingularPtrField<HealthCheck_HTTPCheckInfo> {
        &self.http
    }

    fn mut_http_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<HealthCheck_HTTPCheckInfo> {
        &mut self.http
    }

    // optional .mesos.v1.HealthCheck.TCPCheckInfo tcp = 9;

    pub fn clear_tcp(&mut self) {
        self.tcp.clear();
    }

    pub fn has_tcp(&self) -> bool {
        self.tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp(&mut self, v: HealthCheck_TCPCheckInfo) {
        self.tcp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcp(&mut self) -> &mut HealthCheck_TCPCheckInfo {
        if self.tcp.is_none() {
            self.tcp.set_default();
        }
        self.tcp.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcp(&mut self) -> HealthCheck_TCPCheckInfo {
        self.tcp.take().unwrap_or_else(|| HealthCheck_TCPCheckInfo::new())
    }

    pub fn get_tcp(&self) -> &HealthCheck_TCPCheckInfo {
        self.tcp.as_ref().unwrap_or_else(|| HealthCheck_TCPCheckInfo::default_instance())
    }

    fn get_tcp_for_reflect(&self) -> &::protobuf::SingularPtrField<HealthCheck_TCPCheckInfo> {
        &self.tcp
    }

    fn mut_tcp_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<HealthCheck_TCPCheckInfo> {
        &mut self.tcp
    }
}

impl ::protobuf::Message for HealthCheck {
    fn is_initialized(&self) -> bool {
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.http {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.delay_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.interval_seconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timeout_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consecutive_failures = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.grace_period_seconds = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.delay_seconds {
            my_size += 9;
        }
        if let Some(v) = self.interval_seconds {
            my_size += 9;
        }
        if let Some(v) = self.timeout_seconds {
            my_size += 9;
        }
        if let Some(v) = self.consecutive_failures {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.grace_period_seconds {
            my_size += 9;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.http.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tcp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.delay_seconds {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.interval_seconds {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.timeout_seconds {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.consecutive_failures {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.grace_period_seconds {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(8, v.value())?;
        }
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.http.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tcp.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HealthCheck {
    fn new() -> HealthCheck {
        HealthCheck::new()
    }

    fn descriptor_static(_: ::std::option::Option<HealthCheck>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "delay_seconds",
                    HealthCheck::get_delay_seconds_for_reflect,
                    HealthCheck::mut_delay_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "interval_seconds",
                    HealthCheck::get_interval_seconds_for_reflect,
                    HealthCheck::mut_interval_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "timeout_seconds",
                    HealthCheck::get_timeout_seconds_for_reflect,
                    HealthCheck::mut_timeout_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "consecutive_failures",
                    HealthCheck::get_consecutive_failures_for_reflect,
                    HealthCheck::mut_consecutive_failures_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "grace_period_seconds",
                    HealthCheck::get_grace_period_seconds_for_reflect,
                    HealthCheck::mut_grace_period_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HealthCheck_Type>>(
                    "type",
                    HealthCheck::get_field_type_for_reflect,
                    HealthCheck::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandInfo>>(
                    "command",
                    HealthCheck::get_command_for_reflect,
                    HealthCheck::mut_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck_HTTPCheckInfo>>(
                    "http",
                    HealthCheck::get_http_for_reflect,
                    HealthCheck::mut_http_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck_TCPCheckInfo>>(
                    "tcp",
                    HealthCheck::get_tcp_for_reflect,
                    HealthCheck::mut_tcp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheck>(
                    "HealthCheck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HealthCheck {
    fn clear(&mut self) {
        self.clear_delay_seconds();
        self.clear_interval_seconds();
        self.clear_timeout_seconds();
        self.clear_consecutive_failures();
        self.clear_grace_period_seconds();
        self.clear_field_type();
        self.clear_command();
        self.clear_http();
        self.clear_tcp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_HTTPCheckInfo {
    // message fields
    protocol: ::std::option::Option<NetworkInfo_Protocol>,
    scheme: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<u32>,
    path: ::protobuf::SingularField<::std::string::String>,
    statuses: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HealthCheck_HTTPCheckInfo {}

impl HealthCheck_HTTPCheckInfo {
    pub fn new() -> HealthCheck_HTTPCheckInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HealthCheck_HTTPCheckInfo {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheck_HTTPCheckInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheck_HTTPCheckInfo,
        };
        unsafe {
            instance.get(HealthCheck_HTTPCheckInfo::new)
        }
    }

    // optional .mesos.v1.NetworkInfo.Protocol protocol = 5;

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: NetworkInfo_Protocol) {
        self.protocol = ::std::option::Option::Some(v);
    }

    pub fn get_protocol(&self) -> NetworkInfo_Protocol {
        self.protocol.unwrap_or(NetworkInfo_Protocol::IPv4)
    }

    fn get_protocol_for_reflect(&self) -> &::std::option::Option<NetworkInfo_Protocol> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::std::option::Option<NetworkInfo_Protocol> {
        &mut self.protocol
    }

    // optional string scheme = 3;

    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut ::std::string::String {
        if self.scheme.is_none() {
            self.scheme.set_default();
        }
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        self.scheme.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_scheme(&self) -> &str {
        match self.scheme.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_scheme_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.scheme
    }

    fn mut_scheme_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.scheme
    }

    // required uint32 port = 1;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.port
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // repeated uint32 statuses = 4;

    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::std::vec::Vec<u32>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.statuses, ::std::vec::Vec::new())
    }

    pub fn get_statuses(&self) -> &[u32] {
        &self.statuses
    }

    fn get_statuses_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.statuses
    }

    fn mut_statuses_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.statuses
    }
}

impl ::protobuf::Message for HealthCheck_HTTPCheckInfo {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.protocol = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.scheme)?;
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(ref v) = self.scheme.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.statuses {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol {
            os.write_enum(5, v.value())?;
        }
        if let Some(ref v) = self.scheme.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.statuses {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HealthCheck_HTTPCheckInfo {
    fn new() -> HealthCheck_HTTPCheckInfo {
        HealthCheck_HTTPCheckInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<HealthCheck_HTTPCheckInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NetworkInfo_Protocol>>(
                    "protocol",
                    HealthCheck_HTTPCheckInfo::get_protocol_for_reflect,
                    HealthCheck_HTTPCheckInfo::mut_protocol_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scheme",
                    HealthCheck_HTTPCheckInfo::get_scheme_for_reflect,
                    HealthCheck_HTTPCheckInfo::mut_scheme_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    HealthCheck_HTTPCheckInfo::get_port_for_reflect,
                    HealthCheck_HTTPCheckInfo::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    HealthCheck_HTTPCheckInfo::get_path_for_reflect,
                    HealthCheck_HTTPCheckInfo::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "statuses",
                    HealthCheck_HTTPCheckInfo::get_statuses_for_reflect,
                    HealthCheck_HTTPCheckInfo::mut_statuses_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheck_HTTPCheckInfo>(
                    "HealthCheck_HTTPCheckInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HealthCheck_HTTPCheckInfo {
    fn clear(&mut self) {
        self.clear_protocol();
        self.clear_scheme();
        self.clear_port();
        self.clear_path();
        self.clear_statuses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_HTTPCheckInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_HTTPCheckInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_TCPCheckInfo {
    // message fields
    protocol: ::std::option::Option<NetworkInfo_Protocol>,
    port: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HealthCheck_TCPCheckInfo {}

impl HealthCheck_TCPCheckInfo {
    pub fn new() -> HealthCheck_TCPCheckInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HealthCheck_TCPCheckInfo {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheck_TCPCheckInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheck_TCPCheckInfo,
        };
        unsafe {
            instance.get(HealthCheck_TCPCheckInfo::new)
        }
    }

    // optional .mesos.v1.NetworkInfo.Protocol protocol = 2;

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: NetworkInfo_Protocol) {
        self.protocol = ::std::option::Option::Some(v);
    }

    pub fn get_protocol(&self) -> NetworkInfo_Protocol {
        self.protocol.unwrap_or(NetworkInfo_Protocol::IPv4)
    }

    fn get_protocol_for_reflect(&self) -> &::std::option::Option<NetworkInfo_Protocol> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::std::option::Option<NetworkInfo_Protocol> {
        &mut self.protocol
    }

    // required uint32 port = 1;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.port
    }
}

impl ::protobuf::Message for HealthCheck_TCPCheckInfo {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.protocol = ::std::option::Option::Some(tmp);
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.port {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HealthCheck_TCPCheckInfo {
    fn new() -> HealthCheck_TCPCheckInfo {
        HealthCheck_TCPCheckInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<HealthCheck_TCPCheckInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NetworkInfo_Protocol>>(
                    "protocol",
                    HealthCheck_TCPCheckInfo::get_protocol_for_reflect,
                    HealthCheck_TCPCheckInfo::mut_protocol_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    HealthCheck_TCPCheckInfo::get_port_for_reflect,
                    HealthCheck_TCPCheckInfo::mut_port_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheck_TCPCheckInfo>(
                    "HealthCheck_TCPCheckInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HealthCheck_TCPCheckInfo {
    fn clear(&mut self) {
        self.clear_protocol();
        self.clear_port();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_TCPCheckInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_TCPCheckInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HealthCheck_Type {
    UNKNOWN = 0,
    COMMAND = 1,
    HTTP = 2,
    TCP = 3,
}

impl ::protobuf::ProtobufEnum for HealthCheck_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HealthCheck_Type> {
        match value {
            0 => ::std::option::Option::Some(HealthCheck_Type::UNKNOWN),
            1 => ::std::option::Option::Some(HealthCheck_Type::COMMAND),
            2 => ::std::option::Option::Some(HealthCheck_Type::HTTP),
            3 => ::std::option::Option::Some(HealthCheck_Type::TCP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HealthCheck_Type] = &[
            HealthCheck_Type::UNKNOWN,
            HealthCheck_Type::COMMAND,
            HealthCheck_Type::HTTP,
            HealthCheck_Type::TCP,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<HealthCheck_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("HealthCheck_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for HealthCheck_Type {
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KillPolicy {
    // message fields
    grace_period: ::protobuf::SingularPtrField<DurationInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for KillPolicy {}

impl KillPolicy {
    pub fn new() -> KillPolicy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static KillPolicy {
        static mut instance: ::protobuf::lazy::Lazy<KillPolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KillPolicy,
        };
        unsafe {
            instance.get(KillPolicy::new)
        }
    }

    // optional .mesos.v1.DurationInfo grace_period = 1;

    pub fn clear_grace_period(&mut self) {
        self.grace_period.clear();
    }

    pub fn has_grace_period(&self) -> bool {
        self.grace_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grace_period(&mut self, v: DurationInfo) {
        self.grace_period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grace_period(&mut self) -> &mut DurationInfo {
        if self.grace_period.is_none() {
            self.grace_period.set_default();
        }
        self.grace_period.as_mut().unwrap()
    }

    // Take field
    pub fn take_grace_period(&mut self) -> DurationInfo {
        self.grace_period.take().unwrap_or_else(|| DurationInfo::new())
    }

    pub fn get_grace_period(&self) -> &DurationInfo {
        self.grace_period.as_ref().unwrap_or_else(|| DurationInfo::default_instance())
    }

    fn get_grace_period_for_reflect(&self) -> &::protobuf::SingularPtrField<DurationInfo> {
        &self.grace_period
    }

    fn mut_grace_period_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DurationInfo> {
        &mut self.grace_period
    }
}

impl ::protobuf::Message for KillPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.grace_period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grace_period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.grace_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.grace_period.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for KillPolicy {
    fn new() -> KillPolicy {
        KillPolicy::new()
    }

    fn descriptor_static(_: ::std::option::Option<KillPolicy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DurationInfo>>(
                    "grace_period",
                    KillPolicy::get_grace_period_for_reflect,
                    KillPolicy::mut_grace_period_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KillPolicy>(
                    "KillPolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for KillPolicy {
    fn clear(&mut self) {
        self.clear_grace_period();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KillPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KillPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandInfo {
    // message fields
    uris: ::protobuf::RepeatedField<CommandInfo_URI>,
    environment: ::protobuf::SingularPtrField<Environment>,
    shell: ::std::option::Option<bool>,
    value: ::protobuf::SingularField<::std::string::String>,
    arguments: ::protobuf::RepeatedField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CommandInfo {}

impl CommandInfo {
    pub fn new() -> CommandInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CommandInfo {
        static mut instance: ::protobuf::lazy::Lazy<CommandInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandInfo,
        };
        unsafe {
            instance.get(CommandInfo::new)
        }
    }

    // repeated .mesos.v1.CommandInfo.URI uris = 1;

    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<CommandInfo_URI>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<CommandInfo_URI> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<CommandInfo_URI> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    pub fn get_uris(&self) -> &[CommandInfo_URI] {
        &self.uris
    }

    fn get_uris_for_reflect(&self) -> &::protobuf::RepeatedField<CommandInfo_URI> {
        &self.uris
    }

    fn mut_uris_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CommandInfo_URI> {
        &mut self.uris
    }

    // optional .mesos.v1.Environment environment = 2;

    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: Environment) {
        self.environment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment(&mut self) -> &mut Environment {
        if self.environment.is_none() {
            self.environment.set_default();
        }
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> Environment {
        self.environment.take().unwrap_or_else(|| Environment::new())
    }

    pub fn get_environment(&self) -> &Environment {
        self.environment.as_ref().unwrap_or_else(|| Environment::default_instance())
    }

    fn get_environment_for_reflect(&self) -> &::protobuf::SingularPtrField<Environment> {
        &self.environment
    }

    fn mut_environment_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Environment> {
        &mut self.environment
    }

    // optional bool shell = 6;

    pub fn clear_shell(&mut self) {
        self.shell = ::std::option::Option::None;
    }

    pub fn has_shell(&self) -> bool {
        self.shell.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shell(&mut self, v: bool) {
        self.shell = ::std::option::Option::Some(v);
    }

    pub fn get_shell(&self) -> bool {
        self.shell.unwrap_or(true)
    }

    fn get_shell_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.shell
    }

    fn mut_shell_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.shell
    }

    // optional string value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }

    // repeated string arguments = 7;

    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    pub fn get_arguments(&self) -> &[::std::string::String] {
        &self.arguments
    }

    fn get_arguments_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.arguments
    }

    fn mut_arguments_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.arguments
    }

    // optional string user = 5;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user
    }

    fn mut_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user
    }
}

impl ::protobuf::Message for CommandInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.uris {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.environment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.uris)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.environment)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shell = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.arguments)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uris {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.environment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.shell {
            my_size += 2;
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uris {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.environment.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.shell {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.arguments {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CommandInfo {
    fn new() -> CommandInfo {
        CommandInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CommandInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandInfo_URI>>(
                    "uris",
                    CommandInfo::get_uris_for_reflect,
                    CommandInfo::mut_uris_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Environment>>(
                    "environment",
                    CommandInfo::get_environment_for_reflect,
                    CommandInfo::mut_environment_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "shell",
                    CommandInfo::get_shell_for_reflect,
                    CommandInfo::mut_shell_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    CommandInfo::get_value_for_reflect,
                    CommandInfo::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "arguments",
                    CommandInfo::get_arguments_for_reflect,
                    CommandInfo::mut_arguments_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    CommandInfo::get_user_for_reflect,
                    CommandInfo::mut_user_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandInfo>(
                    "CommandInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CommandInfo {
    fn clear(&mut self) {
        self.clear_uris();
        self.clear_environment();
        self.clear_shell();
        self.clear_value();
        self.clear_arguments();
        self.clear_user();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandInfo_URI {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    executable: ::std::option::Option<bool>,
    extract: ::std::option::Option<bool>,
    cache: ::std::option::Option<bool>,
    output_file: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CommandInfo_URI {}

impl CommandInfo_URI {
    pub fn new() -> CommandInfo_URI {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CommandInfo_URI {
        static mut instance: ::protobuf::lazy::Lazy<CommandInfo_URI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandInfo_URI,
        };
        unsafe {
            instance.get(CommandInfo_URI::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }

    // optional bool executable = 2;

    pub fn clear_executable(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_executable(&self) -> bool {
        self.executable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executable(&mut self, v: bool) {
        self.executable = ::std::option::Option::Some(v);
    }

    pub fn get_executable(&self) -> bool {
        self.executable.unwrap_or(false)
    }

    fn get_executable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.executable
    }

    fn mut_executable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.executable
    }

    // optional bool extract = 3;

    pub fn clear_extract(&mut self) {
        self.extract = ::std::option::Option::None;
    }

    pub fn has_extract(&self) -> bool {
        self.extract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extract(&mut self, v: bool) {
        self.extract = ::std::option::Option::Some(v);
    }

    pub fn get_extract(&self) -> bool {
        self.extract.unwrap_or(true)
    }

    fn get_extract_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.extract
    }

    fn mut_extract_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.extract
    }

    // optional bool cache = 4;

    pub fn clear_cache(&mut self) {
        self.cache = ::std::option::Option::None;
    }

    pub fn has_cache(&self) -> bool {
        self.cache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: bool) {
        self.cache = ::std::option::Option::Some(v);
    }

    pub fn get_cache(&self) -> bool {
        self.cache.unwrap_or(false)
    }

    fn get_cache_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.cache
    }

    fn mut_cache_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.cache
    }

    // optional string output_file = 5;

    pub fn clear_output_file(&mut self) {
        self.output_file.clear();
    }

    pub fn has_output_file(&self) -> bool {
        self.output_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_file(&mut self, v: ::std::string::String) {
        self.output_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_file(&mut self) -> &mut ::std::string::String {
        if self.output_file.is_none() {
            self.output_file.set_default();
        }
        self.output_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_file(&mut self) -> ::std::string::String {
        self.output_file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_output_file(&self) -> &str {
        match self.output_file.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_output_file_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.output_file
    }

    fn mut_output_file_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.output_file
    }
}

impl ::protobuf::Message for CommandInfo_URI {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.executable = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.extract = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cache = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.output_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.executable {
            my_size += 2;
        }
        if let Some(v) = self.extract {
            my_size += 2;
        }
        if let Some(v) = self.cache {
            my_size += 2;
        }
        if let Some(ref v) = self.output_file.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.executable {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.extract {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.cache {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.output_file.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CommandInfo_URI {
    fn new() -> CommandInfo_URI {
        CommandInfo_URI::new()
    }

    fn descriptor_static(_: ::std::option::Option<CommandInfo_URI>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    CommandInfo_URI::get_value_for_reflect,
                    CommandInfo_URI::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "executable",
                    CommandInfo_URI::get_executable_for_reflect,
                    CommandInfo_URI::mut_executable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "extract",
                    CommandInfo_URI::get_extract_for_reflect,
                    CommandInfo_URI::mut_extract_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cache",
                    CommandInfo_URI::get_cache_for_reflect,
                    CommandInfo_URI::mut_cache_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "output_file",
                    CommandInfo_URI::get_output_file_for_reflect,
                    CommandInfo_URI::mut_output_file_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandInfo_URI>(
                    "CommandInfo_URI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CommandInfo_URI {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_executable();
        self.clear_extract();
        self.clear_cache();
        self.clear_output_file();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandInfo_URI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandInfo_URI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutorInfo {
    // message fields
    field_type: ::std::option::Option<ExecutorInfo_Type>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    resources: ::protobuf::RepeatedField<Resource>,
    name: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    discovery: ::protobuf::SingularPtrField<DiscoveryInfo>,
    shutdown_grace_period: ::protobuf::SingularPtrField<DurationInfo>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ExecutorInfo {}

impl ExecutorInfo {
    pub fn new() -> ExecutorInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ExecutorInfo {
        static mut instance: ::protobuf::lazy::Lazy<ExecutorInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutorInfo,
        };
        unsafe {
            instance.get(ExecutorInfo::new)
        }
    }

    // optional .mesos.v1.ExecutorInfo.Type type = 15;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ExecutorInfo_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> ExecutorInfo_Type {
        self.field_type.unwrap_or(ExecutorInfo_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<ExecutorInfo_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<ExecutorInfo_Type> {
        &mut self.field_type
    }

    // required .mesos.v1.ExecutorID executor_id = 1;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id(&mut self) -> &mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        }
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id(&self) -> &ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    fn get_executor_id_for_reflect(&self) -> &::protobuf::SingularPtrField<ExecutorID> {
        &self.executor_id
    }

    fn mut_executor_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ExecutorID> {
        &mut self.executor_id
    }

    // optional .mesos.v1.FrameworkID framework_id = 8;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id(&mut self) -> &mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        }
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id(&self) -> &FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    fn get_framework_id_for_reflect(&self) -> &::protobuf::SingularPtrField<FrameworkID> {
        &self.framework_id
    }

    fn mut_framework_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FrameworkID> {
        &mut self.framework_id
    }

    // optional .mesos.v1.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command(&self) -> &CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    fn get_command_for_reflect(&self) -> &::protobuf::SingularPtrField<CommandInfo> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CommandInfo> {
        &mut self.command
    }

    // optional .mesos.v1.ContainerInfo container = 11;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container(&self) -> &ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    fn get_container_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerInfo> {
        &self.container
    }

    fn mut_container_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerInfo> {
        &mut self.container
    }

    // repeated .mesos.v1.Resource resources = 5;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // optional string name = 9;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string source = 10;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_source_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.source
    }

    // optional bytes data = 4;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }

    // optional .mesos.v1.DiscoveryInfo discovery = 12;

    pub fn clear_discovery(&mut self) {
        self.discovery.clear();
    }

    pub fn has_discovery(&self) -> bool {
        self.discovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery(&mut self, v: DiscoveryInfo) {
        self.discovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery(&mut self) -> &mut DiscoveryInfo {
        if self.discovery.is_none() {
            self.discovery.set_default();
        }
        self.discovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery(&mut self) -> DiscoveryInfo {
        self.discovery.take().unwrap_or_else(|| DiscoveryInfo::new())
    }

    pub fn get_discovery(&self) -> &DiscoveryInfo {
        self.discovery.as_ref().unwrap_or_else(|| DiscoveryInfo::default_instance())
    }

    fn get_discovery_for_reflect(&self) -> &::protobuf::SingularPtrField<DiscoveryInfo> {
        &self.discovery
    }

    fn mut_discovery_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DiscoveryInfo> {
        &mut self.discovery
    }

    // optional .mesos.v1.DurationInfo shutdown_grace_period = 13;

    pub fn clear_shutdown_grace_period(&mut self) {
        self.shutdown_grace_period.clear();
    }

    pub fn has_shutdown_grace_period(&self) -> bool {
        self.shutdown_grace_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shutdown_grace_period(&mut self, v: DurationInfo) {
        self.shutdown_grace_period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shutdown_grace_period(&mut self) -> &mut DurationInfo {
        if self.shutdown_grace_period.is_none() {
            self.shutdown_grace_period.set_default();
        }
        self.shutdown_grace_period.as_mut().unwrap()
    }

    // Take field
    pub fn take_shutdown_grace_period(&mut self) -> DurationInfo {
        self.shutdown_grace_period.take().unwrap_or_else(|| DurationInfo::new())
    }

    pub fn get_shutdown_grace_period(&self) -> &DurationInfo {
        self.shutdown_grace_period.as_ref().unwrap_or_else(|| DurationInfo::default_instance())
    }

    fn get_shutdown_grace_period_for_reflect(&self) -> &::protobuf::SingularPtrField<DurationInfo> {
        &self.shutdown_grace_period
    }

    fn mut_shutdown_grace_period_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DurationInfo> {
        &mut self.shutdown_grace_period
    }

    // optional .mesos.v1.Labels labels = 14;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }
}

impl ::protobuf::Message for ExecutorInfo {
    fn is_initialized(&self) -> bool {
        if self.executor_id.is_none() {
            return false;
        }
        for v in &self.executor_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.framework_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.container {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discovery {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shutdown_grace_period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor_id)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.discovery)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shutdown_grace_period)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(15, v);
        }
        if let Some(ref v) = self.executor_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.container.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.discovery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shutdown_grace_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(15, v.value())?;
        }
        if let Some(ref v) = self.executor_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resources {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.discovery.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shutdown_grace_period.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ExecutorInfo {
    fn new() -> ExecutorInfo {
        ExecutorInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ExecutorInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExecutorInfo_Type>>(
                    "type",
                    ExecutorInfo::get_field_type_for_reflect,
                    ExecutorInfo::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorID>>(
                    "executor_id",
                    ExecutorInfo::get_executor_id_for_reflect,
                    ExecutorInfo::mut_executor_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkID>>(
                    "framework_id",
                    ExecutorInfo::get_framework_id_for_reflect,
                    ExecutorInfo::mut_framework_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandInfo>>(
                    "command",
                    ExecutorInfo::get_command_for_reflect,
                    ExecutorInfo::mut_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerInfo>>(
                    "container",
                    ExecutorInfo::get_container_for_reflect,
                    ExecutorInfo::mut_container_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    ExecutorInfo::get_resources_for_reflect,
                    ExecutorInfo::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ExecutorInfo::get_name_for_reflect,
                    ExecutorInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    ExecutorInfo::get_source_for_reflect,
                    ExecutorInfo::mut_source_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    ExecutorInfo::get_data_for_reflect,
                    ExecutorInfo::mut_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveryInfo>>(
                    "discovery",
                    ExecutorInfo::get_discovery_for_reflect,
                    ExecutorInfo::mut_discovery_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DurationInfo>>(
                    "shutdown_grace_period",
                    ExecutorInfo::get_shutdown_grace_period_for_reflect,
                    ExecutorInfo::mut_shutdown_grace_period_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    ExecutorInfo::get_labels_for_reflect,
                    ExecutorInfo::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutorInfo>(
                    "ExecutorInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ExecutorInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_executor_id();
        self.clear_framework_id();
        self.clear_command();
        self.clear_container();
        self.clear_resources();
        self.clear_name();
        self.clear_source();
        self.clear_data();
        self.clear_discovery();
        self.clear_shutdown_grace_period();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExecutorInfo_Type {
    UNKNOWN = 0,
    DEFAULT = 1,
    CUSTOM = 2,
}

impl ::protobuf::ProtobufEnum for ExecutorInfo_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExecutorInfo_Type> {
        match value {
            0 => ::std::option::Option::Some(ExecutorInfo_Type::UNKNOWN),
            1 => ::std::option::Option::Some(ExecutorInfo_Type::DEFAULT),
            2 => ::std::option::Option::Some(ExecutorInfo_Type::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExecutorInfo_Type] = &[
            ExecutorInfo_Type::UNKNOWN,
            ExecutorInfo_Type::DEFAULT,
            ExecutorInfo_Type::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ExecutorInfo_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ExecutorInfo_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ExecutorInfo_Type {
}

impl ::protobuf::reflect::ProtobufValue for ExecutorInfo_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DomainInfo {
    // message fields
    fault_domain: ::protobuf::SingularPtrField<DomainInfo_FaultDomain>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DomainInfo {}

impl DomainInfo {
    pub fn new() -> DomainInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DomainInfo {
        static mut instance: ::protobuf::lazy::Lazy<DomainInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DomainInfo,
        };
        unsafe {
            instance.get(DomainInfo::new)
        }
    }

    // optional .mesos.v1.DomainInfo.FaultDomain fault_domain = 1;

    pub fn clear_fault_domain(&mut self) {
        self.fault_domain.clear();
    }

    pub fn has_fault_domain(&self) -> bool {
        self.fault_domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fault_domain(&mut self, v: DomainInfo_FaultDomain) {
        self.fault_domain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fault_domain(&mut self) -> &mut DomainInfo_FaultDomain {
        if self.fault_domain.is_none() {
            self.fault_domain.set_default();
        }
        self.fault_domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_fault_domain(&mut self) -> DomainInfo_FaultDomain {
        self.fault_domain.take().unwrap_or_else(|| DomainInfo_FaultDomain::new())
    }

    pub fn get_fault_domain(&self) -> &DomainInfo_FaultDomain {
        self.fault_domain.as_ref().unwrap_or_else(|| DomainInfo_FaultDomain::default_instance())
    }

    fn get_fault_domain_for_reflect(&self) -> &::protobuf::SingularPtrField<DomainInfo_FaultDomain> {
        &self.fault_domain
    }

    fn mut_fault_domain_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DomainInfo_FaultDomain> {
        &mut self.fault_domain
    }
}

impl ::protobuf::Message for DomainInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.fault_domain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fault_domain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fault_domain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fault_domain.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DomainInfo {
    fn new() -> DomainInfo {
        DomainInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DomainInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DomainInfo_FaultDomain>>(
                    "fault_domain",
                    DomainInfo::get_fault_domain_for_reflect,
                    DomainInfo::mut_fault_domain_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DomainInfo>(
                    "DomainInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DomainInfo {
    fn clear(&mut self) {
        self.clear_fault_domain();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DomainInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DomainInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DomainInfo_FaultDomain {
    // message fields
    region: ::protobuf::SingularPtrField<DomainInfo_FaultDomain_RegionInfo>,
    zone: ::protobuf::SingularPtrField<DomainInfo_FaultDomain_ZoneInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DomainInfo_FaultDomain {}

impl DomainInfo_FaultDomain {
    pub fn new() -> DomainInfo_FaultDomain {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DomainInfo_FaultDomain {
        static mut instance: ::protobuf::lazy::Lazy<DomainInfo_FaultDomain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DomainInfo_FaultDomain,
        };
        unsafe {
            instance.get(DomainInfo_FaultDomain::new)
        }
    }

    // required .mesos.v1.DomainInfo.FaultDomain.RegionInfo region = 1;

    pub fn clear_region(&mut self) {
        self.region.clear();
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: DomainInfo_FaultDomain_RegionInfo) {
        self.region = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut DomainInfo_FaultDomain_RegionInfo {
        if self.region.is_none() {
            self.region.set_default();
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> DomainInfo_FaultDomain_RegionInfo {
        self.region.take().unwrap_or_else(|| DomainInfo_FaultDomain_RegionInfo::new())
    }

    pub fn get_region(&self) -> &DomainInfo_FaultDomain_RegionInfo {
        self.region.as_ref().unwrap_or_else(|| DomainInfo_FaultDomain_RegionInfo::default_instance())
    }

    fn get_region_for_reflect(&self) -> &::protobuf::SingularPtrField<DomainInfo_FaultDomain_RegionInfo> {
        &self.region
    }

    fn mut_region_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DomainInfo_FaultDomain_RegionInfo> {
        &mut self.region
    }

    // required .mesos.v1.DomainInfo.FaultDomain.ZoneInfo zone = 2;

    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    pub fn has_zone(&self) -> bool {
        self.zone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: DomainInfo_FaultDomain_ZoneInfo) {
        self.zone = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut DomainInfo_FaultDomain_ZoneInfo {
        if self.zone.is_none() {
            self.zone.set_default();
        }
        self.zone.as_mut().unwrap()
    }

    // Take field
    pub fn take_zone(&mut self) -> DomainInfo_FaultDomain_ZoneInfo {
        self.zone.take().unwrap_or_else(|| DomainInfo_FaultDomain_ZoneInfo::new())
    }

    pub fn get_zone(&self) -> &DomainInfo_FaultDomain_ZoneInfo {
        self.zone.as_ref().unwrap_or_else(|| DomainInfo_FaultDomain_ZoneInfo::default_instance())
    }

    fn get_zone_for_reflect(&self) -> &::protobuf::SingularPtrField<DomainInfo_FaultDomain_ZoneInfo> {
        &self.zone
    }

    fn mut_zone_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DomainInfo_FaultDomain_ZoneInfo> {
        &mut self.zone
    }
}

impl ::protobuf::Message for DomainInfo_FaultDomain {
    fn is_initialized(&self) -> bool {
        if self.region.is_none() {
            return false;
        }
        if self.zone.is_none() {
            return false;
        }
        for v in &self.region {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.zone {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.zone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.zone.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DomainInfo_FaultDomain {
    fn new() -> DomainInfo_FaultDomain {
        DomainInfo_FaultDomain::new()
    }

    fn descriptor_static(_: ::std::option::Option<DomainInfo_FaultDomain>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DomainInfo_FaultDomain_RegionInfo>>(
                    "region",
                    DomainInfo_FaultDomain::get_region_for_reflect,
                    DomainInfo_FaultDomain::mut_region_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DomainInfo_FaultDomain_ZoneInfo>>(
                    "zone",
                    DomainInfo_FaultDomain::get_zone_for_reflect,
                    DomainInfo_FaultDomain::mut_zone_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DomainInfo_FaultDomain>(
                    "DomainInfo_FaultDomain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DomainInfo_FaultDomain {
    fn clear(&mut self) {
        self.clear_region();
        self.clear_zone();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DomainInfo_FaultDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DomainInfo_FaultDomain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DomainInfo_FaultDomain_RegionInfo {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DomainInfo_FaultDomain_RegionInfo {}

impl DomainInfo_FaultDomain_RegionInfo {
    pub fn new() -> DomainInfo_FaultDomain_RegionInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DomainInfo_FaultDomain_RegionInfo {
        static mut instance: ::protobuf::lazy::Lazy<DomainInfo_FaultDomain_RegionInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DomainInfo_FaultDomain_RegionInfo,
        };
        unsafe {
            instance.get(DomainInfo_FaultDomain_RegionInfo::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for DomainInfo_FaultDomain_RegionInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DomainInfo_FaultDomain_RegionInfo {
    fn new() -> DomainInfo_FaultDomain_RegionInfo {
        DomainInfo_FaultDomain_RegionInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DomainInfo_FaultDomain_RegionInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    DomainInfo_FaultDomain_RegionInfo::get_name_for_reflect,
                    DomainInfo_FaultDomain_RegionInfo::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DomainInfo_FaultDomain_RegionInfo>(
                    "DomainInfo_FaultDomain_RegionInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DomainInfo_FaultDomain_RegionInfo {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DomainInfo_FaultDomain_RegionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DomainInfo_FaultDomain_RegionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DomainInfo_FaultDomain_ZoneInfo {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DomainInfo_FaultDomain_ZoneInfo {}

impl DomainInfo_FaultDomain_ZoneInfo {
    pub fn new() -> DomainInfo_FaultDomain_ZoneInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DomainInfo_FaultDomain_ZoneInfo {
        static mut instance: ::protobuf::lazy::Lazy<DomainInfo_FaultDomain_ZoneInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DomainInfo_FaultDomain_ZoneInfo,
        };
        unsafe {
            instance.get(DomainInfo_FaultDomain_ZoneInfo::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for DomainInfo_FaultDomain_ZoneInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DomainInfo_FaultDomain_ZoneInfo {
    fn new() -> DomainInfo_FaultDomain_ZoneInfo {
        DomainInfo_FaultDomain_ZoneInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DomainInfo_FaultDomain_ZoneInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    DomainInfo_FaultDomain_ZoneInfo::get_name_for_reflect,
                    DomainInfo_FaultDomain_ZoneInfo::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DomainInfo_FaultDomain_ZoneInfo>(
                    "DomainInfo_FaultDomain_ZoneInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DomainInfo_FaultDomain_ZoneInfo {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DomainInfo_FaultDomain_ZoneInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DomainInfo_FaultDomain_ZoneInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MasterInfo {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    ip: ::std::option::Option<u32>,
    port: ::std::option::Option<u32>,
    pid: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularPtrField<Address>,
    domain: ::protobuf::SingularPtrField<DomainInfo>,
    capabilities: ::protobuf::RepeatedField<MasterInfo_Capability>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MasterInfo {}

impl MasterInfo {
    pub fn new() -> MasterInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MasterInfo {
        static mut instance: ::protobuf::lazy::Lazy<MasterInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MasterInfo,
        };
        unsafe {
            instance.get(MasterInfo::new)
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.id
    }

    // required uint32 ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    fn get_ip_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ip
    }

    // required uint32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(5050u32)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.port
    }

    // optional string pid = 4;

    pub fn clear_pid(&mut self) {
        self.pid.clear();
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: ::std::string::String) {
        self.pid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pid(&mut self) -> &mut ::std::string::String {
        if self.pid.is_none() {
            self.pid.set_default();
        }
        self.pid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pid(&mut self) -> ::std::string::String {
        self.pid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pid(&self) -> &str {
        match self.pid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_pid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.pid
    }

    fn mut_pid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.pid
    }

    // optional string hostname = 5;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional string version = 6;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_version_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.version
    }

    // optional .mesos.v1.Address address = 7;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| Address::default_instance())
    }

    fn get_address_for_reflect(&self) -> &::protobuf::SingularPtrField<Address> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Address> {
        &mut self.address
    }

    // optional .mesos.v1.DomainInfo domain = 8;

    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: DomainInfo) {
        self.domain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut DomainInfo {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> DomainInfo {
        self.domain.take().unwrap_or_else(|| DomainInfo::new())
    }

    pub fn get_domain(&self) -> &DomainInfo {
        self.domain.as_ref().unwrap_or_else(|| DomainInfo::default_instance())
    }

    fn get_domain_for_reflect(&self) -> &::protobuf::SingularPtrField<DomainInfo> {
        &self.domain
    }

    fn mut_domain_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DomainInfo> {
        &mut self.domain
    }

    // repeated .mesos.v1.MasterInfo.Capability capabilities = 9;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::protobuf::RepeatedField<MasterInfo_Capability>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities(&mut self) -> &mut ::protobuf::RepeatedField<MasterInfo_Capability> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::protobuf::RepeatedField<MasterInfo_Capability> {
        ::std::mem::replace(&mut self.capabilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_capabilities(&self) -> &[MasterInfo_Capability] {
        &self.capabilities
    }

    fn get_capabilities_for_reflect(&self) -> &::protobuf::RepeatedField<MasterInfo_Capability> {
        &self.capabilities
    }

    fn mut_capabilities_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<MasterInfo_Capability> {
        &mut self.capabilities
    }
}

impl ::protobuf::Message for MasterInfo {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.ip.is_none() {
            return false;
        }
        if self.port.is_none() {
            return false;
        }
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.domain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.domain)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.capabilities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.domain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.capabilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.pid.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.capabilities {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MasterInfo {
    fn new() -> MasterInfo {
        MasterInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<MasterInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    MasterInfo::get_id_for_reflect,
                    MasterInfo::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ip",
                    MasterInfo::get_ip_for_reflect,
                    MasterInfo::mut_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    MasterInfo::get_port_for_reflect,
                    MasterInfo::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pid",
                    MasterInfo::get_pid_for_reflect,
                    MasterInfo::mut_pid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    MasterInfo::get_hostname_for_reflect,
                    MasterInfo::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    MasterInfo::get_version_for_reflect,
                    MasterInfo::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "address",
                    MasterInfo::get_address_for_reflect,
                    MasterInfo::mut_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DomainInfo>>(
                    "domain",
                    MasterInfo::get_domain_for_reflect,
                    MasterInfo::mut_domain_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MasterInfo_Capability>>(
                    "capabilities",
                    MasterInfo::get_capabilities_for_reflect,
                    MasterInfo::mut_capabilities_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MasterInfo>(
                    "MasterInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MasterInfo {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_ip();
        self.clear_port();
        self.clear_pid();
        self.clear_hostname();
        self.clear_version();
        self.clear_address();
        self.clear_domain();
        self.clear_capabilities();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MasterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MasterInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MasterInfo_Capability {
    // message fields
    field_type: ::std::option::Option<MasterInfo_Capability_Type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MasterInfo_Capability {}

impl MasterInfo_Capability {
    pub fn new() -> MasterInfo_Capability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MasterInfo_Capability {
        static mut instance: ::protobuf::lazy::Lazy<MasterInfo_Capability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MasterInfo_Capability,
        };
        unsafe {
            instance.get(MasterInfo_Capability::new)
        }
    }

    // optional .mesos.v1.MasterInfo.Capability.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: MasterInfo_Capability_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> MasterInfo_Capability_Type {
        self.field_type.unwrap_or(MasterInfo_Capability_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<MasterInfo_Capability_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<MasterInfo_Capability_Type> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for MasterInfo_Capability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MasterInfo_Capability {
    fn new() -> MasterInfo_Capability {
        MasterInfo_Capability::new()
    }

    fn descriptor_static(_: ::std::option::Option<MasterInfo_Capability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MasterInfo_Capability_Type>>(
                    "type",
                    MasterInfo_Capability::get_field_type_for_reflect,
                    MasterInfo_Capability::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MasterInfo_Capability>(
                    "MasterInfo_Capability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MasterInfo_Capability {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MasterInfo_Capability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MasterInfo_Capability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MasterInfo_Capability_Type {
    UNKNOWN = 0,
    AGENT_UPDATE = 1,
}

impl ::protobuf::ProtobufEnum for MasterInfo_Capability_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MasterInfo_Capability_Type> {
        match value {
            0 => ::std::option::Option::Some(MasterInfo_Capability_Type::UNKNOWN),
            1 => ::std::option::Option::Some(MasterInfo_Capability_Type::AGENT_UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MasterInfo_Capability_Type] = &[
            MasterInfo_Capability_Type::UNKNOWN,
            MasterInfo_Capability_Type::AGENT_UPDATE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<MasterInfo_Capability_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MasterInfo_Capability_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MasterInfo_Capability_Type {
}

impl ::protobuf::reflect::ProtobufValue for MasterInfo_Capability_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentInfo {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    resources: ::protobuf::RepeatedField<Resource>,
    attributes: ::protobuf::RepeatedField<Attribute>,
    id: ::protobuf::SingularPtrField<AgentID>,
    domain: ::protobuf::SingularPtrField<DomainInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AgentInfo {}

impl AgentInfo {
    pub fn new() -> AgentInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AgentInfo {
        static mut instance: ::protobuf::lazy::Lazy<AgentInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentInfo,
        };
        unsafe {
            instance.get(AgentInfo::new)
        }
    }

    // required string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional int32 port = 8;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(5051i32)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.port
    }

    // repeated .mesos.v1.Resource resources = 3;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // repeated .mesos.v1.Attribute attributes = 5;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Attribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Attribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes(&self) -> &[Attribute] {
        &self.attributes
    }

    fn get_attributes_for_reflect(&self) -> &::protobuf::RepeatedField<Attribute> {
        &self.attributes
    }

    fn mut_attributes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // optional .mesos.v1.AgentID id = 6;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: AgentID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut AgentID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> AgentID {
        self.id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_id(&self) -> &AgentID {
        self.id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.id
    }

    // optional .mesos.v1.DomainInfo domain = 10;

    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: DomainInfo) {
        self.domain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut DomainInfo {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> DomainInfo {
        self.domain.take().unwrap_or_else(|| DomainInfo::new())
    }

    pub fn get_domain(&self) -> &DomainInfo {
        self.domain.as_ref().unwrap_or_else(|| DomainInfo::default_instance())
    }

    fn get_domain_for_reflect(&self) -> &::protobuf::SingularPtrField<DomainInfo> {
        &self.domain
    }

    fn mut_domain_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DomainInfo> {
        &mut self.domain
    }
}

impl ::protobuf::Message for AgentInfo {
    fn is_initialized(&self) -> bool {
        if self.hostname.is_none() {
            return false;
        }
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.domain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.domain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.domain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(8, v)?;
        }
        for v in &self.resources {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.attributes {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AgentInfo {
    fn new() -> AgentInfo {
        AgentInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<AgentInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    AgentInfo::get_hostname_for_reflect,
                    AgentInfo::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    AgentInfo::get_port_for_reflect,
                    AgentInfo::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    AgentInfo::get_resources_for_reflect,
                    AgentInfo::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribute>>(
                    "attributes",
                    AgentInfo::get_attributes_for_reflect,
                    AgentInfo::mut_attributes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "id",
                    AgentInfo::get_id_for_reflect,
                    AgentInfo::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DomainInfo>>(
                    "domain",
                    AgentInfo::get_domain_for_reflect,
                    AgentInfo::mut_domain_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentInfo>(
                    "AgentInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AgentInfo {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_port();
        self.clear_resources();
        self.clear_attributes();
        self.clear_id();
        self.clear_domain();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentInfo_Capability {
    // message fields
    field_type: ::std::option::Option<AgentInfo_Capability_Type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AgentInfo_Capability {}

impl AgentInfo_Capability {
    pub fn new() -> AgentInfo_Capability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AgentInfo_Capability {
        static mut instance: ::protobuf::lazy::Lazy<AgentInfo_Capability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentInfo_Capability,
        };
        unsafe {
            instance.get(AgentInfo_Capability::new)
        }
    }

    // optional .mesos.v1.AgentInfo.Capability.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AgentInfo_Capability_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> AgentInfo_Capability_Type {
        self.field_type.unwrap_or(AgentInfo_Capability_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<AgentInfo_Capability_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<AgentInfo_Capability_Type> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for AgentInfo_Capability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AgentInfo_Capability {
    fn new() -> AgentInfo_Capability {
        AgentInfo_Capability::new()
    }

    fn descriptor_static(_: ::std::option::Option<AgentInfo_Capability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AgentInfo_Capability_Type>>(
                    "type",
                    AgentInfo_Capability::get_field_type_for_reflect,
                    AgentInfo_Capability::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentInfo_Capability>(
                    "AgentInfo_Capability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AgentInfo_Capability {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentInfo_Capability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentInfo_Capability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AgentInfo_Capability_Type {
    UNKNOWN = 0,
    MULTI_ROLE = 1,
    HIERARCHICAL_ROLE = 2,
    RESERVATION_REFINEMENT = 3,
    RESOURCE_PROVIDER = 4,
}

impl ::protobuf::ProtobufEnum for AgentInfo_Capability_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AgentInfo_Capability_Type> {
        match value {
            0 => ::std::option::Option::Some(AgentInfo_Capability_Type::UNKNOWN),
            1 => ::std::option::Option::Some(AgentInfo_Capability_Type::MULTI_ROLE),
            2 => ::std::option::Option::Some(AgentInfo_Capability_Type::HIERARCHICAL_ROLE),
            3 => ::std::option::Option::Some(AgentInfo_Capability_Type::RESERVATION_REFINEMENT),
            4 => ::std::option::Option::Some(AgentInfo_Capability_Type::RESOURCE_PROVIDER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AgentInfo_Capability_Type] = &[
            AgentInfo_Capability_Type::UNKNOWN,
            AgentInfo_Capability_Type::MULTI_ROLE,
            AgentInfo_Capability_Type::HIERARCHICAL_ROLE,
            AgentInfo_Capability_Type::RESERVATION_REFINEMENT,
            AgentInfo_Capability_Type::RESOURCE_PROVIDER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<AgentInfo_Capability_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AgentInfo_Capability_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AgentInfo_Capability_Type {
}

impl ::protobuf::reflect::ProtobufValue for AgentInfo_Capability_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSIPluginContainerInfo {
    // message fields
    services: ::std::vec::Vec<CSIPluginContainerInfo_Service>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    resources: ::protobuf::RepeatedField<Resource>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSIPluginContainerInfo {}

impl CSIPluginContainerInfo {
    pub fn new() -> CSIPluginContainerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSIPluginContainerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CSIPluginContainerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSIPluginContainerInfo,
        };
        unsafe {
            instance.get(CSIPluginContainerInfo::new)
        }
    }

    // repeated .mesos.v1.CSIPluginContainerInfo.Service services = 1;

    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::std::vec::Vec<CSIPluginContainerInfo_Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::std::vec::Vec<CSIPluginContainerInfo_Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::std::vec::Vec<CSIPluginContainerInfo_Service> {
        ::std::mem::replace(&mut self.services, ::std::vec::Vec::new())
    }

    pub fn get_services(&self) -> &[CSIPluginContainerInfo_Service] {
        &self.services
    }

    fn get_services_for_reflect(&self) -> &::std::vec::Vec<CSIPluginContainerInfo_Service> {
        &self.services
    }

    fn mut_services_for_reflect(&mut self) -> &mut ::std::vec::Vec<CSIPluginContainerInfo_Service> {
        &mut self.services
    }

    // optional .mesos.v1.CommandInfo command = 2;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command(&self) -> &CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    fn get_command_for_reflect(&self) -> &::protobuf::SingularPtrField<CommandInfo> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CommandInfo> {
        &mut self.command
    }

    // repeated .mesos.v1.Resource resources = 3;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // optional .mesos.v1.ContainerInfo container = 4;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container(&self) -> &ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    fn get_container_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerInfo> {
        &self.container
    }

    fn mut_container_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerInfo> {
        &mut self.container
    }
}

impl ::protobuf::Message for CSIPluginContainerInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.container {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.services)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.container.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_enum(1, v.value())?;
        };
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resources {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.container.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSIPluginContainerInfo {
    fn new() -> CSIPluginContainerInfo {
        CSIPluginContainerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSIPluginContainerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CSIPluginContainerInfo_Service>>(
                    "services",
                    CSIPluginContainerInfo::get_services_for_reflect,
                    CSIPluginContainerInfo::mut_services_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandInfo>>(
                    "command",
                    CSIPluginContainerInfo::get_command_for_reflect,
                    CSIPluginContainerInfo::mut_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    CSIPluginContainerInfo::get_resources_for_reflect,
                    CSIPluginContainerInfo::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerInfo>>(
                    "container",
                    CSIPluginContainerInfo::get_container_for_reflect,
                    CSIPluginContainerInfo::mut_container_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSIPluginContainerInfo>(
                    "CSIPluginContainerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSIPluginContainerInfo {
    fn clear(&mut self) {
        self.clear_services();
        self.clear_command();
        self.clear_resources();
        self.clear_container();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSIPluginContainerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSIPluginContainerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CSIPluginContainerInfo_Service {
    UNKNOWN = 0,
    CONTROLLER_SERVICE = 1,
    NODE_SERVICE = 2,
}

impl ::protobuf::ProtobufEnum for CSIPluginContainerInfo_Service {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CSIPluginContainerInfo_Service> {
        match value {
            0 => ::std::option::Option::Some(CSIPluginContainerInfo_Service::UNKNOWN),
            1 => ::std::option::Option::Some(CSIPluginContainerInfo_Service::CONTROLLER_SERVICE),
            2 => ::std::option::Option::Some(CSIPluginContainerInfo_Service::NODE_SERVICE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CSIPluginContainerInfo_Service] = &[
            CSIPluginContainerInfo_Service::UNKNOWN,
            CSIPluginContainerInfo_Service::CONTROLLER_SERVICE,
            CSIPluginContainerInfo_Service::NODE_SERVICE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CSIPluginContainerInfo_Service>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CSIPluginContainerInfo_Service", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CSIPluginContainerInfo_Service {
}

impl ::protobuf::reflect::ProtobufValue for CSIPluginContainerInfo_Service {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSIPluginInfo {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    containers: ::protobuf::RepeatedField<CSIPluginContainerInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSIPluginInfo {}

impl CSIPluginInfo {
    pub fn new() -> CSIPluginInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSIPluginInfo {
        static mut instance: ::protobuf::lazy::Lazy<CSIPluginInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSIPluginInfo,
        };
        unsafe {
            instance.get(CSIPluginInfo::new)
        }
    }

    // required string type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // required string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // repeated .mesos.v1.CSIPluginContainerInfo containers = 3;

    pub fn clear_containers(&mut self) {
        self.containers.clear();
    }

    // Param is passed by value, moved
    pub fn set_containers(&mut self, v: ::protobuf::RepeatedField<CSIPluginContainerInfo>) {
        self.containers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containers(&mut self) -> &mut ::protobuf::RepeatedField<CSIPluginContainerInfo> {
        &mut self.containers
    }

    // Take field
    pub fn take_containers(&mut self) -> ::protobuf::RepeatedField<CSIPluginContainerInfo> {
        ::std::mem::replace(&mut self.containers, ::protobuf::RepeatedField::new())
    }

    pub fn get_containers(&self) -> &[CSIPluginContainerInfo] {
        &self.containers
    }

    fn get_containers_for_reflect(&self) -> &::protobuf::RepeatedField<CSIPluginContainerInfo> {
        &self.containers
    }

    fn mut_containers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CSIPluginContainerInfo> {
        &mut self.containers
    }
}

impl ::protobuf::Message for CSIPluginInfo {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        for v in &self.containers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.containers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.containers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSIPluginInfo {
    fn new() -> CSIPluginInfo {
        CSIPluginInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSIPluginInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    CSIPluginInfo::get_field_type_for_reflect,
                    CSIPluginInfo::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CSIPluginInfo::get_name_for_reflect,
                    CSIPluginInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSIPluginContainerInfo>>(
                    "containers",
                    CSIPluginInfo::get_containers_for_reflect,
                    CSIPluginInfo::mut_containers_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSIPluginInfo>(
                    "CSIPluginInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSIPluginInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_name();
        self.clear_containers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSIPluginInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSIPluginInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceProviderInfo {
    // message fields
    id: ::protobuf::SingularPtrField<ResourceProviderID>,
    attributes: ::protobuf::RepeatedField<Attribute>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    default_reservations: ::protobuf::RepeatedField<Resource_ReservationInfo>,
    storage: ::protobuf::SingularPtrField<ResourceProviderInfo_Storage>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceProviderInfo {}

impl ResourceProviderInfo {
    pub fn new() -> ResourceProviderInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceProviderInfo {
        static mut instance: ::protobuf::lazy::Lazy<ResourceProviderInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceProviderInfo,
        };
        unsafe {
            instance.get(ResourceProviderInfo::new)
        }
    }

    // optional .mesos.v1.ResourceProviderID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ResourceProviderID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ResourceProviderID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ResourceProviderID {
        self.id.take().unwrap_or_else(|| ResourceProviderID::new())
    }

    pub fn get_id(&self) -> &ResourceProviderID {
        self.id.as_ref().unwrap_or_else(|| ResourceProviderID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceProviderID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceProviderID> {
        &mut self.id
    }

    // repeated .mesos.v1.Attribute attributes = 2;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Attribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Attribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes(&self) -> &[Attribute] {
        &self.attributes
    }

    fn get_attributes_for_reflect(&self) -> &::protobuf::RepeatedField<Attribute> {
        &self.attributes
    }

    fn mut_attributes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // required string type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // required string name = 4;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // repeated .mesos.v1.Resource.ReservationInfo default_reservations = 5;

    pub fn clear_default_reservations(&mut self) {
        self.default_reservations.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_reservations(&mut self, v: ::protobuf::RepeatedField<Resource_ReservationInfo>) {
        self.default_reservations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_default_reservations(&mut self) -> &mut ::protobuf::RepeatedField<Resource_ReservationInfo> {
        &mut self.default_reservations
    }

    // Take field
    pub fn take_default_reservations(&mut self) -> ::protobuf::RepeatedField<Resource_ReservationInfo> {
        ::std::mem::replace(&mut self.default_reservations, ::protobuf::RepeatedField::new())
    }

    pub fn get_default_reservations(&self) -> &[Resource_ReservationInfo] {
        &self.default_reservations
    }

    fn get_default_reservations_for_reflect(&self) -> &::protobuf::RepeatedField<Resource_ReservationInfo> {
        &self.default_reservations
    }

    fn mut_default_reservations_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource_ReservationInfo> {
        &mut self.default_reservations
    }

    // optional .mesos.v1.ResourceProviderInfo.Storage storage = 6;

    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    pub fn has_storage(&self) -> bool {
        self.storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: ResourceProviderInfo_Storage) {
        self.storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage(&mut self) -> &mut ResourceProviderInfo_Storage {
        if self.storage.is_none() {
            self.storage.set_default();
        }
        self.storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage(&mut self) -> ResourceProviderInfo_Storage {
        self.storage.take().unwrap_or_else(|| ResourceProviderInfo_Storage::new())
    }

    pub fn get_storage(&self) -> &ResourceProviderInfo_Storage {
        self.storage.as_ref().unwrap_or_else(|| ResourceProviderInfo_Storage::default_instance())
    }

    fn get_storage_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceProviderInfo_Storage> {
        &self.storage
    }

    fn mut_storage_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceProviderInfo_Storage> {
        &mut self.storage
    }
}

impl ::protobuf::Message for ResourceProviderInfo {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_reservations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.default_reservations)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.default_reservations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.attributes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.default_reservations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.storage.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceProviderInfo {
    fn new() -> ResourceProviderInfo {
        ResourceProviderInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceProviderInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceProviderID>>(
                    "id",
                    ResourceProviderInfo::get_id_for_reflect,
                    ResourceProviderInfo::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribute>>(
                    "attributes",
                    ResourceProviderInfo::get_attributes_for_reflect,
                    ResourceProviderInfo::mut_attributes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    ResourceProviderInfo::get_field_type_for_reflect,
                    ResourceProviderInfo::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ResourceProviderInfo::get_name_for_reflect,
                    ResourceProviderInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_ReservationInfo>>(
                    "default_reservations",
                    ResourceProviderInfo::get_default_reservations_for_reflect,
                    ResourceProviderInfo::mut_default_reservations_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceProviderInfo_Storage>>(
                    "storage",
                    ResourceProviderInfo::get_storage_for_reflect,
                    ResourceProviderInfo::mut_storage_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceProviderInfo>(
                    "ResourceProviderInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceProviderInfo {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_attributes();
        self.clear_field_type();
        self.clear_name();
        self.clear_default_reservations();
        self.clear_storage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceProviderInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceProviderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceProviderInfo_Storage {
    // message fields
    plugin: ::protobuf::SingularPtrField<CSIPluginInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceProviderInfo_Storage {}

impl ResourceProviderInfo_Storage {
    pub fn new() -> ResourceProviderInfo_Storage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceProviderInfo_Storage {
        static mut instance: ::protobuf::lazy::Lazy<ResourceProviderInfo_Storage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceProviderInfo_Storage,
        };
        unsafe {
            instance.get(ResourceProviderInfo_Storage::new)
        }
    }

    // required .mesos.v1.CSIPluginInfo plugin = 1;

    pub fn clear_plugin(&mut self) {
        self.plugin.clear();
    }

    pub fn has_plugin(&self) -> bool {
        self.plugin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin(&mut self, v: CSIPluginInfo) {
        self.plugin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin(&mut self) -> &mut CSIPluginInfo {
        if self.plugin.is_none() {
            self.plugin.set_default();
        }
        self.plugin.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin(&mut self) -> CSIPluginInfo {
        self.plugin.take().unwrap_or_else(|| CSIPluginInfo::new())
    }

    pub fn get_plugin(&self) -> &CSIPluginInfo {
        self.plugin.as_ref().unwrap_or_else(|| CSIPluginInfo::default_instance())
    }

    fn get_plugin_for_reflect(&self) -> &::protobuf::SingularPtrField<CSIPluginInfo> {
        &self.plugin
    }

    fn mut_plugin_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CSIPluginInfo> {
        &mut self.plugin
    }
}

impl ::protobuf::Message for ResourceProviderInfo_Storage {
    fn is_initialized(&self) -> bool {
        if self.plugin.is_none() {
            return false;
        }
        for v in &self.plugin {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plugin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.plugin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.plugin.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceProviderInfo_Storage {
    fn new() -> ResourceProviderInfo_Storage {
        ResourceProviderInfo_Storage::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceProviderInfo_Storage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSIPluginInfo>>(
                    "plugin",
                    ResourceProviderInfo_Storage::get_plugin_for_reflect,
                    ResourceProviderInfo_Storage::mut_plugin_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceProviderInfo_Storage>(
                    "ResourceProviderInfo_Storage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceProviderInfo_Storage {
    fn clear(&mut self) {
        self.clear_plugin();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceProviderInfo_Storage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceProviderInfo_Storage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value {
    // message fields
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    text: ::protobuf::SingularPtrField<Value_Text>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value {}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value {
        static mut instance: ::protobuf::lazy::Lazy<Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value,
        };
        unsafe {
            instance.get(Value::new)
        }
    }

    // required .mesos.v1.Value.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Value_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Value_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.Value.Scalar scalar = 2;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar(&mut self) -> &mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        }
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar(&self) -> &Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    fn get_scalar_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Scalar> {
        &self.scalar
    }

    fn mut_scalar_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Scalar> {
        &mut self.scalar
    }

    // optional .mesos.v1.Value.Ranges ranges = 3;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges(&mut self) -> &mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        }
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges(&self) -> &Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    fn get_ranges_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Ranges> {
        &self.ranges
    }

    fn mut_ranges_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Ranges> {
        &mut self.ranges
    }

    // optional .mesos.v1.Value.Set set = 4;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set(&mut self) -> &mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        }
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set(&self) -> &Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    fn get_set_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Set> {
        &self.set
    }

    fn mut_set_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Set> {
        &mut self.set
    }

    // optional .mesos.v1.Value.Text text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Value_Text) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut Value_Text {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> Value_Text {
        self.text.take().unwrap_or_else(|| Value_Text::new())
    }

    pub fn get_text(&self) -> &Value_Text {
        self.text.as_ref().unwrap_or_else(|| Value_Text::default_instance())
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Text> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Text> {
        &mut self.text
    }
}

impl ::protobuf::Message for Value {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.scalar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scalar)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranges)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.scalar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ranges.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.scalar.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ranges.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.set.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value {
    fn new() -> Value {
        Value::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Value_Type>>(
                    "type",
                    Value::get_field_type_for_reflect,
                    Value::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Scalar>>(
                    "scalar",
                    Value::get_scalar_for_reflect,
                    Value::mut_scalar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Ranges>>(
                    "ranges",
                    Value::get_ranges_for_reflect,
                    Value::mut_ranges_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Set>>(
                    "set",
                    Value::get_set_for_reflect,
                    Value::mut_set_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Text>>(
                    "text",
                    Value::get_text_for_reflect,
                    Value::mut_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value>(
                    "Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value_Scalar {
    // message fields
    value: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Scalar {}

impl Value_Scalar {
    pub fn new() -> Value_Scalar {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Scalar {
        static mut instance: ::protobuf::lazy::Lazy<Value_Scalar> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Scalar,
        };
        unsafe {
            instance.get(Value_Scalar::new)
        }
    }

    // required double value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> f64 {
        self.value.unwrap_or(0.)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.value
    }
}

impl ::protobuf::Message for Value_Scalar {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_double(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Scalar {
    fn new() -> Value_Scalar {
        Value_Scalar::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Scalar>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "value",
                    Value_Scalar::get_value_for_reflect,
                    Value_Scalar::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Scalar>(
                    "Value_Scalar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Scalar {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value_Scalar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value_Scalar {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value_Range {
    // message fields
    begin: ::std::option::Option<u64>,
    end: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Range {}

impl Value_Range {
    pub fn new() -> Value_Range {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Range {
        static mut instance: ::protobuf::lazy::Lazy<Value_Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Range,
        };
        unsafe {
            instance.get(Value_Range::new)
        }
    }

    // required uint64 begin = 1;

    pub fn clear_begin(&mut self) {
        self.begin = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: u64) {
        self.begin = ::std::option::Option::Some(v);
    }

    pub fn get_begin(&self) -> u64 {
        self.begin.unwrap_or(0)
    }

    fn get_begin_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.begin
    }

    fn mut_begin_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.begin
    }

    // required uint64 end = 2;

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }

    pub fn get_end(&self) -> u64 {
        self.end.unwrap_or(0)
    }

    fn get_end_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.end
    }

    fn mut_end_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.end
    }
}

impl ::protobuf::Message for Value_Range {
    fn is_initialized(&self) -> bool {
        if self.begin.is_none() {
            return false;
        }
        if self.end.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.begin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.begin {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.begin {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.end {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Range {
    fn new() -> Value_Range {
        Value_Range::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Range>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "begin",
                    Value_Range::get_begin_for_reflect,
                    Value_Range::mut_begin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "end",
                    Value_Range::get_end_for_reflect,
                    Value_Range::mut_end_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Range>(
                    "Value_Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Range {
    fn clear(&mut self) {
        self.clear_begin();
        self.clear_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value_Range {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value_Ranges {
    // message fields
    range: ::protobuf::RepeatedField<Value_Range>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Ranges {}

impl Value_Ranges {
    pub fn new() -> Value_Ranges {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Ranges {
        static mut instance: ::protobuf::lazy::Lazy<Value_Ranges> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Ranges,
        };
        unsafe {
            instance.get(Value_Ranges::new)
        }
    }

    // repeated .mesos.v1.Value.Range range = 1;

    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: ::protobuf::RepeatedField<Value_Range>) {
        self.range = v;
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut ::protobuf::RepeatedField<Value_Range> {
        &mut self.range
    }

    // Take field
    pub fn take_range(&mut self) -> ::protobuf::RepeatedField<Value_Range> {
        ::std::mem::replace(&mut self.range, ::protobuf::RepeatedField::new())
    }

    pub fn get_range(&self) -> &[Value_Range] {
        &self.range
    }

    fn get_range_for_reflect(&self) -> &::protobuf::RepeatedField<Value_Range> {
        &self.range
    }

    fn mut_range_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Value_Range> {
        &mut self.range
    }
}

impl ::protobuf::Message for Value_Ranges {
    fn is_initialized(&self) -> bool {
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.range {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.range {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Ranges {
    fn new() -> Value_Ranges {
        Value_Ranges::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Ranges>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Range>>(
                    "range",
                    Value_Ranges::get_range_for_reflect,
                    Value_Ranges::mut_range_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Ranges>(
                    "Value_Ranges",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Ranges {
    fn clear(&mut self) {
        self.clear_range();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value_Ranges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value_Ranges {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value_Set {
    // message fields
    item: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Set {}

impl Value_Set {
    pub fn new() -> Value_Set {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Set {
        static mut instance: ::protobuf::lazy::Lazy<Value_Set> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Set,
        };
        unsafe {
            instance.get(Value_Set::new)
        }
    }

    // repeated string item = 1;

    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.item = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.item
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.item, ::protobuf::RepeatedField::new())
    }

    pub fn get_item(&self) -> &[::std::string::String] {
        &self.item
    }

    fn get_item_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.item
    }

    fn mut_item_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.item
    }
}

impl ::protobuf::Message for Value_Set {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Set {
    fn new() -> Value_Set {
        Value_Set::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Set>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "item",
                    Value_Set::get_item_for_reflect,
                    Value_Set::mut_item_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Set>(
                    "Value_Set",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Set {
    fn clear(&mut self) {
        self.clear_item();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value_Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value_Set {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value_Text {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Text {}

impl Value_Text {
    pub fn new() -> Value_Text {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Text {
        static mut instance: ::protobuf::lazy::Lazy<Value_Text> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Text,
        };
        unsafe {
            instance.get(Value_Text::new)
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for Value_Text {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Text {
    fn new() -> Value_Text {
        Value_Text::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Text>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Value_Text::get_value_for_reflect,
                    Value_Text::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Text>(
                    "Value_Text",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Text {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value_Text {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value_Text {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Value_Type {
    SCALAR = 0,
    RANGES = 1,
    SET = 2,
    TEXT = 3,
}

impl ::protobuf::ProtobufEnum for Value_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Value_Type> {
        match value {
            0 => ::std::option::Option::Some(Value_Type::SCALAR),
            1 => ::std::option::Option::Some(Value_Type::RANGES),
            2 => ::std::option::Option::Some(Value_Type::SET),
            3 => ::std::option::Option::Some(Value_Type::TEXT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Value_Type] = &[
            Value_Type::SCALAR,
            Value_Type::RANGES,
            Value_Type::SET,
            Value_Type::TEXT,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Value_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Value_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Value_Type {
}

impl ::protobuf::reflect::ProtobufValue for Value_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attribute {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    text: ::protobuf::SingularPtrField<Value_Text>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Attribute {}

impl Attribute {
    pub fn new() -> Attribute {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Attribute {
        static mut instance: ::protobuf::lazy::Lazy<Attribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute,
        };
        unsafe {
            instance.get(Attribute::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required .mesos.v1.Value.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Value_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Value_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.Value.Scalar scalar = 3;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar(&mut self) -> &mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        }
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar(&self) -> &Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    fn get_scalar_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Scalar> {
        &self.scalar
    }

    fn mut_scalar_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Scalar> {
        &mut self.scalar
    }

    // optional .mesos.v1.Value.Ranges ranges = 4;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges(&mut self) -> &mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        }
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges(&self) -> &Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    fn get_ranges_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Ranges> {
        &self.ranges
    }

    fn mut_ranges_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Ranges> {
        &mut self.ranges
    }

    // optional .mesos.v1.Value.Set set = 6;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set(&mut self) -> &mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        }
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set(&self) -> &Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    fn get_set_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Set> {
        &self.set
    }

    fn mut_set_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Set> {
        &mut self.set
    }

    // optional .mesos.v1.Value.Text text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Value_Text) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut Value_Text {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> Value_Text {
        self.text.take().unwrap_or_else(|| Value_Text::new())
    }

    pub fn get_text(&self) -> &Value_Text {
        self.text.as_ref().unwrap_or_else(|| Value_Text::default_instance())
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Text> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Text> {
        &mut self.text
    }
}

impl ::protobuf::Message for Attribute {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.scalar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scalar)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranges)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.scalar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ranges.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.scalar.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ranges.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.set.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Attribute {
    fn new() -> Attribute {
        Attribute::new()
    }

    fn descriptor_static(_: ::std::option::Option<Attribute>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Attribute::get_name_for_reflect,
                    Attribute::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Value_Type>>(
                    "type",
                    Attribute::get_field_type_for_reflect,
                    Attribute::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Scalar>>(
                    "scalar",
                    Attribute::get_scalar_for_reflect,
                    Attribute::mut_scalar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Ranges>>(
                    "ranges",
                    Attribute::get_ranges_for_reflect,
                    Attribute::mut_ranges_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Set>>(
                    "set",
                    Attribute::get_set_for_reflect,
                    Attribute::mut_set_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Text>>(
                    "text",
                    Attribute::get_text_for_reflect,
                    Attribute::mut_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attribute>(
                    "Attribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Attribute {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource {
    // message fields
    provider_id: ::protobuf::SingularPtrField<ResourceProviderID>,
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    role: ::protobuf::SingularField<::std::string::String>,
    allocation_info: ::protobuf::SingularPtrField<Resource_AllocationInfo>,
    reservation: ::protobuf::SingularPtrField<Resource_ReservationInfo>,
    reservations: ::protobuf::RepeatedField<Resource_ReservationInfo>,
    disk: ::protobuf::SingularPtrField<Resource_DiskInfo>,
    revocable: ::protobuf::SingularPtrField<Resource_RevocableInfo>,
    shared: ::protobuf::SingularPtrField<Resource_SharedInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource {}

impl Resource {
    pub fn new() -> Resource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource {
        static mut instance: ::protobuf::lazy::Lazy<Resource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource,
        };
        unsafe {
            instance.get(Resource::new)
        }
    }

    // optional .mesos.v1.ResourceProviderID provider_id = 12;

    pub fn clear_provider_id(&mut self) {
        self.provider_id.clear();
    }

    pub fn has_provider_id(&self) -> bool {
        self.provider_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provider_id(&mut self, v: ResourceProviderID) {
        self.provider_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider_id(&mut self) -> &mut ResourceProviderID {
        if self.provider_id.is_none() {
            self.provider_id.set_default();
        }
        self.provider_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_provider_id(&mut self) -> ResourceProviderID {
        self.provider_id.take().unwrap_or_else(|| ResourceProviderID::new())
    }

    pub fn get_provider_id(&self) -> &ResourceProviderID {
        self.provider_id.as_ref().unwrap_or_else(|| ResourceProviderID::default_instance())
    }

    fn get_provider_id_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceProviderID> {
        &self.provider_id
    }

    fn mut_provider_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceProviderID> {
        &mut self.provider_id
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required .mesos.v1.Value.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Value_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Value_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.Value.Scalar scalar = 3;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar(&mut self) -> &mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        }
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar(&self) -> &Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    fn get_scalar_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Scalar> {
        &self.scalar
    }

    fn mut_scalar_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Scalar> {
        &mut self.scalar
    }

    // optional .mesos.v1.Value.Ranges ranges = 4;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges(&mut self) -> &mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        }
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges(&self) -> &Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    fn get_ranges_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Ranges> {
        &self.ranges
    }

    fn mut_ranges_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Ranges> {
        &mut self.ranges
    }

    // optional .mesos.v1.Value.Set set = 5;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set(&mut self) -> &mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        }
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set(&self) -> &Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    fn get_set_for_reflect(&self) -> &::protobuf::SingularPtrField<Value_Set> {
        &self.set
    }

    fn mut_set_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Value_Set> {
        &mut self.set
    }

    // optional string role = 6;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "*",
        }
    }

    fn get_role_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.role
    }

    // optional .mesos.v1.Resource.AllocationInfo allocation_info = 11;

    pub fn clear_allocation_info(&mut self) {
        self.allocation_info.clear();
    }

    pub fn has_allocation_info(&self) -> bool {
        self.allocation_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocation_info(&mut self, v: Resource_AllocationInfo) {
        self.allocation_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocation_info(&mut self) -> &mut Resource_AllocationInfo {
        if self.allocation_info.is_none() {
            self.allocation_info.set_default();
        }
        self.allocation_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_allocation_info(&mut self) -> Resource_AllocationInfo {
        self.allocation_info.take().unwrap_or_else(|| Resource_AllocationInfo::new())
    }

    pub fn get_allocation_info(&self) -> &Resource_AllocationInfo {
        self.allocation_info.as_ref().unwrap_or_else(|| Resource_AllocationInfo::default_instance())
    }

    fn get_allocation_info_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_AllocationInfo> {
        &self.allocation_info
    }

    fn mut_allocation_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_AllocationInfo> {
        &mut self.allocation_info
    }

    // optional .mesos.v1.Resource.ReservationInfo reservation = 8;

    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: Resource_ReservationInfo) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut Resource_ReservationInfo {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> Resource_ReservationInfo {
        self.reservation.take().unwrap_or_else(|| Resource_ReservationInfo::new())
    }

    pub fn get_reservation(&self) -> &Resource_ReservationInfo {
        self.reservation.as_ref().unwrap_or_else(|| Resource_ReservationInfo::default_instance())
    }

    fn get_reservation_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_ReservationInfo> {
        &self.reservation
    }

    fn mut_reservation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_ReservationInfo> {
        &mut self.reservation
    }

    // repeated .mesos.v1.Resource.ReservationInfo reservations = 13;

    pub fn clear_reservations(&mut self) {
        self.reservations.clear();
    }

    // Param is passed by value, moved
    pub fn set_reservations(&mut self, v: ::protobuf::RepeatedField<Resource_ReservationInfo>) {
        self.reservations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reservations(&mut self) -> &mut ::protobuf::RepeatedField<Resource_ReservationInfo> {
        &mut self.reservations
    }

    // Take field
    pub fn take_reservations(&mut self) -> ::protobuf::RepeatedField<Resource_ReservationInfo> {
        ::std::mem::replace(&mut self.reservations, ::protobuf::RepeatedField::new())
    }

    pub fn get_reservations(&self) -> &[Resource_ReservationInfo] {
        &self.reservations
    }

    fn get_reservations_for_reflect(&self) -> &::protobuf::RepeatedField<Resource_ReservationInfo> {
        &self.reservations
    }

    fn mut_reservations_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource_ReservationInfo> {
        &mut self.reservations
    }

    // optional .mesos.v1.Resource.DiskInfo disk = 7;

    pub fn clear_disk(&mut self) {
        self.disk.clear();
    }

    pub fn has_disk(&self) -> bool {
        self.disk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk(&mut self, v: Resource_DiskInfo) {
        self.disk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disk(&mut self) -> &mut Resource_DiskInfo {
        if self.disk.is_none() {
            self.disk.set_default();
        }
        self.disk.as_mut().unwrap()
    }

    // Take field
    pub fn take_disk(&mut self) -> Resource_DiskInfo {
        self.disk.take().unwrap_or_else(|| Resource_DiskInfo::new())
    }

    pub fn get_disk(&self) -> &Resource_DiskInfo {
        self.disk.as_ref().unwrap_or_else(|| Resource_DiskInfo::default_instance())
    }

    fn get_disk_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_DiskInfo> {
        &self.disk
    }

    fn mut_disk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_DiskInfo> {
        &mut self.disk
    }

    // optional .mesos.v1.Resource.RevocableInfo revocable = 9;

    pub fn clear_revocable(&mut self) {
        self.revocable.clear();
    }

    pub fn has_revocable(&self) -> bool {
        self.revocable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revocable(&mut self, v: Resource_RevocableInfo) {
        self.revocable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revocable(&mut self) -> &mut Resource_RevocableInfo {
        if self.revocable.is_none() {
            self.revocable.set_default();
        }
        self.revocable.as_mut().unwrap()
    }

    // Take field
    pub fn take_revocable(&mut self) -> Resource_RevocableInfo {
        self.revocable.take().unwrap_or_else(|| Resource_RevocableInfo::new())
    }

    pub fn get_revocable(&self) -> &Resource_RevocableInfo {
        self.revocable.as_ref().unwrap_or_else(|| Resource_RevocableInfo::default_instance())
    }

    fn get_revocable_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_RevocableInfo> {
        &self.revocable
    }

    fn mut_revocable_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_RevocableInfo> {
        &mut self.revocable
    }

    // optional .mesos.v1.Resource.SharedInfo shared = 10;

    pub fn clear_shared(&mut self) {
        self.shared.clear();
    }

    pub fn has_shared(&self) -> bool {
        self.shared.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared(&mut self, v: Resource_SharedInfo) {
        self.shared = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shared(&mut self) -> &mut Resource_SharedInfo {
        if self.shared.is_none() {
            self.shared.set_default();
        }
        self.shared.as_mut().unwrap()
    }

    // Take field
    pub fn take_shared(&mut self) -> Resource_SharedInfo {
        self.shared.take().unwrap_or_else(|| Resource_SharedInfo::new())
    }

    pub fn get_shared(&self) -> &Resource_SharedInfo {
        self.shared.as_ref().unwrap_or_else(|| Resource_SharedInfo::default_instance())
    }

    fn get_shared_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_SharedInfo> {
        &self.shared
    }

    fn mut_shared_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_SharedInfo> {
        &mut self.shared
    }
}

impl ::protobuf::Message for Resource {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.provider_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scalar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allocation_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reservations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revocable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shared {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.provider_id)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scalar)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranges)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allocation_info)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reservations)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.disk)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.revocable)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shared)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.provider_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.scalar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ranges.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.allocation_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.reservations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.disk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.revocable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shared.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.provider_id.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.scalar.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ranges.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.set.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.role.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.allocation_info.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.reservations {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.disk.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.revocable.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shared.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource {
    fn new() -> Resource {
        Resource::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceProviderID>>(
                    "provider_id",
                    Resource::get_provider_id_for_reflect,
                    Resource::mut_provider_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Resource::get_name_for_reflect,
                    Resource::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Value_Type>>(
                    "type",
                    Resource::get_field_type_for_reflect,
                    Resource::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Scalar>>(
                    "scalar",
                    Resource::get_scalar_for_reflect,
                    Resource::mut_scalar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Ranges>>(
                    "ranges",
                    Resource::get_ranges_for_reflect,
                    Resource::mut_ranges_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value_Set>>(
                    "set",
                    Resource::get_set_for_reflect,
                    Resource::mut_set_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    Resource::get_role_for_reflect,
                    Resource::mut_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_AllocationInfo>>(
                    "allocation_info",
                    Resource::get_allocation_info_for_reflect,
                    Resource::mut_allocation_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_ReservationInfo>>(
                    "reservation",
                    Resource::get_reservation_for_reflect,
                    Resource::mut_reservation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_ReservationInfo>>(
                    "reservations",
                    Resource::get_reservations_for_reflect,
                    Resource::mut_reservations_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_DiskInfo>>(
                    "disk",
                    Resource::get_disk_for_reflect,
                    Resource::mut_disk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_RevocableInfo>>(
                    "revocable",
                    Resource::get_revocable_for_reflect,
                    Resource::mut_revocable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_SharedInfo>>(
                    "shared",
                    Resource::get_shared_for_reflect,
                    Resource::mut_shared_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource>(
                    "Resource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource {
    fn clear(&mut self) {
        self.clear_provider_id();
        self.clear_name();
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_role();
        self.clear_allocation_info();
        self.clear_reservation();
        self.clear_reservations();
        self.clear_disk();
        self.clear_revocable();
        self.clear_shared();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_AllocationInfo {
    // message fields
    role: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_AllocationInfo {}

impl Resource_AllocationInfo {
    pub fn new() -> Resource_AllocationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_AllocationInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_AllocationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_AllocationInfo,
        };
        unsafe {
            instance.get(Resource_AllocationInfo::new)
        }
    }

    // optional string role = 1;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_role_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.role
    }
}

impl ::protobuf::Message for Resource_AllocationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.role.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_AllocationInfo {
    fn new() -> Resource_AllocationInfo {
        Resource_AllocationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_AllocationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    Resource_AllocationInfo::get_role_for_reflect,
                    Resource_AllocationInfo::mut_role_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_AllocationInfo>(
                    "Resource_AllocationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_AllocationInfo {
    fn clear(&mut self) {
        self.clear_role();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_AllocationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_AllocationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_ReservationInfo {
    // message fields
    field_type: ::std::option::Option<Resource_ReservationInfo_Type>,
    role: ::protobuf::SingularField<::std::string::String>,
    principal: ::protobuf::SingularField<::std::string::String>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_ReservationInfo {}

impl Resource_ReservationInfo {
    pub fn new() -> Resource_ReservationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_ReservationInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_ReservationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_ReservationInfo,
        };
        unsafe {
            instance.get(Resource_ReservationInfo::new)
        }
    }

    // optional .mesos.v1.Resource.ReservationInfo.Type type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Resource_ReservationInfo_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Resource_ReservationInfo_Type {
        self.field_type.unwrap_or(Resource_ReservationInfo_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Resource_ReservationInfo_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Resource_ReservationInfo_Type> {
        &mut self.field_type
    }

    // optional string role = 3;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_role_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.role
    }

    // optional string principal = 1;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal(&mut self) -> &mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        }
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal(&self) -> &str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_principal_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.principal
    }

    fn mut_principal_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.principal
    }

    // optional .mesos.v1.Labels labels = 2;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }
}

impl ::protobuf::Message for Resource_ReservationInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.principal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(4, v.value())?;
        }
        if let Some(ref v) = self.role.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.principal.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_ReservationInfo {
    fn new() -> Resource_ReservationInfo {
        Resource_ReservationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_ReservationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Resource_ReservationInfo_Type>>(
                    "type",
                    Resource_ReservationInfo::get_field_type_for_reflect,
                    Resource_ReservationInfo::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    Resource_ReservationInfo::get_role_for_reflect,
                    Resource_ReservationInfo::mut_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "principal",
                    Resource_ReservationInfo::get_principal_for_reflect,
                    Resource_ReservationInfo::mut_principal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    Resource_ReservationInfo::get_labels_for_reflect,
                    Resource_ReservationInfo::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_ReservationInfo>(
                    "Resource_ReservationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_ReservationInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_role();
        self.clear_principal();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_ReservationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_ReservationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Resource_ReservationInfo_Type {
    UNKNOWN = 0,
    STATIC = 1,
    DYNAMIC = 2,
}

impl ::protobuf::ProtobufEnum for Resource_ReservationInfo_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Resource_ReservationInfo_Type> {
        match value {
            0 => ::std::option::Option::Some(Resource_ReservationInfo_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Resource_ReservationInfo_Type::STATIC),
            2 => ::std::option::Option::Some(Resource_ReservationInfo_Type::DYNAMIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Resource_ReservationInfo_Type] = &[
            Resource_ReservationInfo_Type::UNKNOWN,
            Resource_ReservationInfo_Type::STATIC,
            Resource_ReservationInfo_Type::DYNAMIC,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Resource_ReservationInfo_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Resource_ReservationInfo_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Resource_ReservationInfo_Type {
}

impl ::protobuf::reflect::ProtobufValue for Resource_ReservationInfo_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_DiskInfo {
    // message fields
    persistence: ::protobuf::SingularPtrField<Resource_DiskInfo_Persistence>,
    volume: ::protobuf::SingularPtrField<Volume>,
    source: ::protobuf::SingularPtrField<Resource_DiskInfo_Source>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo {}

impl Resource_DiskInfo {
    pub fn new() -> Resource_DiskInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo,
        };
        unsafe {
            instance.get(Resource_DiskInfo::new)
        }
    }

    // optional .mesos.v1.Resource.DiskInfo.Persistence persistence = 1;

    pub fn clear_persistence(&mut self) {
        self.persistence.clear();
    }

    pub fn has_persistence(&self) -> bool {
        self.persistence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistence(&mut self, v: Resource_DiskInfo_Persistence) {
        self.persistence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistence(&mut self) -> &mut Resource_DiskInfo_Persistence {
        if self.persistence.is_none() {
            self.persistence.set_default();
        }
        self.persistence.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistence(&mut self) -> Resource_DiskInfo_Persistence {
        self.persistence.take().unwrap_or_else(|| Resource_DiskInfo_Persistence::new())
    }

    pub fn get_persistence(&self) -> &Resource_DiskInfo_Persistence {
        self.persistence.as_ref().unwrap_or_else(|| Resource_DiskInfo_Persistence::default_instance())
    }

    fn get_persistence_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_DiskInfo_Persistence> {
        &self.persistence
    }

    fn mut_persistence_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_DiskInfo_Persistence> {
        &mut self.persistence
    }

    // optional .mesos.v1.Volume volume = 2;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: Volume) {
        self.volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut Volume {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> Volume {
        self.volume.take().unwrap_or_else(|| Volume::new())
    }

    pub fn get_volume(&self) -> &Volume {
        self.volume.as_ref().unwrap_or_else(|| Volume::default_instance())
    }

    fn get_volume_for_reflect(&self) -> &::protobuf::SingularPtrField<Volume> {
        &self.volume
    }

    fn mut_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Volume> {
        &mut self.volume
    }

    // optional .mesos.v1.Resource.DiskInfo.Source source = 3;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Resource_DiskInfo_Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Resource_DiskInfo_Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Resource_DiskInfo_Source {
        self.source.take().unwrap_or_else(|| Resource_DiskInfo_Source::new())
    }

    pub fn get_source(&self) -> &Resource_DiskInfo_Source {
        self.source.as_ref().unwrap_or_else(|| Resource_DiskInfo_Source::default_instance())
    }

    fn get_source_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_DiskInfo_Source> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_DiskInfo_Source> {
        &mut self.source
    }
}

impl ::protobuf::Message for Resource_DiskInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.persistence {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistence)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volume)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.persistence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.persistence.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo {
    fn new() -> Resource_DiskInfo {
        Resource_DiskInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_DiskInfo_Persistence>>(
                    "persistence",
                    Resource_DiskInfo::get_persistence_for_reflect,
                    Resource_DiskInfo::mut_persistence_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume>>(
                    "volume",
                    Resource_DiskInfo::get_volume_for_reflect,
                    Resource_DiskInfo::mut_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_DiskInfo_Source>>(
                    "source",
                    Resource_DiskInfo::get_source_for_reflect,
                    Resource_DiskInfo::mut_source_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo>(
                    "Resource_DiskInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo {
    fn clear(&mut self) {
        self.clear_persistence();
        self.clear_volume();
        self.clear_source();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_DiskInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_DiskInfo_Persistence {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    principal: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Persistence {}

impl Resource_DiskInfo_Persistence {
    pub fn new() -> Resource_DiskInfo_Persistence {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Persistence {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Persistence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Persistence,
        };
        unsafe {
            instance.get(Resource_DiskInfo_Persistence::new)
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.id
    }

    // optional string principal = 2;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal(&mut self) -> &mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        }
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal(&self) -> &str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_principal_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.principal
    }

    fn mut_principal_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.principal
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Persistence {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.principal.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.principal.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Persistence {
    fn new() -> Resource_DiskInfo_Persistence {
        Resource_DiskInfo_Persistence::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Persistence>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    Resource_DiskInfo_Persistence::get_id_for_reflect,
                    Resource_DiskInfo_Persistence::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "principal",
                    Resource_DiskInfo_Persistence::get_principal_for_reflect,
                    Resource_DiskInfo_Persistence::mut_principal_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Persistence>(
                    "Resource_DiskInfo_Persistence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Persistence {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_principal();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Persistence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_DiskInfo_Persistence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_DiskInfo_Source {
    // message fields
    field_type: ::std::option::Option<Resource_DiskInfo_Source_Type>,
    path: ::protobuf::SingularPtrField<Resource_DiskInfo_Source_Path>,
    mount: ::protobuf::SingularPtrField<Resource_DiskInfo_Source_Mount>,
    id: ::protobuf::SingularField<::std::string::String>,
    metadata: ::protobuf::SingularPtrField<Labels>,
    profile: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Source {}

impl Resource_DiskInfo_Source {
    pub fn new() -> Resource_DiskInfo_Source {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Source {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Source> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Source,
        };
        unsafe {
            instance.get(Resource_DiskInfo_Source::new)
        }
    }

    // required .mesos.v1.Resource.DiskInfo.Source.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Resource_DiskInfo_Source_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Resource_DiskInfo_Source_Type {
        self.field_type.unwrap_or(Resource_DiskInfo_Source_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Resource_DiskInfo_Source_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Resource_DiskInfo_Source_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.Resource.DiskInfo.Source.Path path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Resource_DiskInfo_Source_Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Resource_DiskInfo_Source_Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Resource_DiskInfo_Source_Path {
        self.path.take().unwrap_or_else(|| Resource_DiskInfo_Source_Path::new())
    }

    pub fn get_path(&self) -> &Resource_DiskInfo_Source_Path {
        self.path.as_ref().unwrap_or_else(|| Resource_DiskInfo_Source_Path::default_instance())
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_DiskInfo_Source_Path> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_DiskInfo_Source_Path> {
        &mut self.path
    }

    // optional .mesos.v1.Resource.DiskInfo.Source.Mount mount = 3;

    pub fn clear_mount(&mut self) {
        self.mount.clear();
    }

    pub fn has_mount(&self) -> bool {
        self.mount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mount(&mut self, v: Resource_DiskInfo_Source_Mount) {
        self.mount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mount(&mut self) -> &mut Resource_DiskInfo_Source_Mount {
        if self.mount.is_none() {
            self.mount.set_default();
        }
        self.mount.as_mut().unwrap()
    }

    // Take field
    pub fn take_mount(&mut self) -> Resource_DiskInfo_Source_Mount {
        self.mount.take().unwrap_or_else(|| Resource_DiskInfo_Source_Mount::new())
    }

    pub fn get_mount(&self) -> &Resource_DiskInfo_Source_Mount {
        self.mount.as_ref().unwrap_or_else(|| Resource_DiskInfo_Source_Mount::default_instance())
    }

    fn get_mount_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_DiskInfo_Source_Mount> {
        &self.mount
    }

    fn mut_mount_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_DiskInfo_Source_Mount> {
        &mut self.mount
    }

    // optional string id = 4;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.id
    }

    // optional .mesos.v1.Labels metadata = 5;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: Labels) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut Labels {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> Labels {
        self.metadata.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_metadata(&self) -> &Labels {
        self.metadata.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.metadata
    }

    // optional string profile = 6;

    pub fn clear_profile(&mut self) {
        self.profile.clear();
    }

    pub fn has_profile(&self) -> bool {
        self.profile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile(&mut self, v: ::std::string::String) {
        self.profile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile(&mut self) -> &mut ::std::string::String {
        if self.profile.is_none() {
            self.profile.set_default();
        }
        self.profile.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile(&mut self) -> ::std::string::String {
        self.profile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_profile(&self) -> &str {
        match self.profile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_profile_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.profile
    }

    fn mut_profile_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.profile
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Source {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mount {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mount)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.profile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.profile.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mount.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.profile.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Source {
    fn new() -> Resource_DiskInfo_Source {
        Resource_DiskInfo_Source::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Source>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Resource_DiskInfo_Source_Type>>(
                    "type",
                    Resource_DiskInfo_Source::get_field_type_for_reflect,
                    Resource_DiskInfo_Source::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_DiskInfo_Source_Path>>(
                    "path",
                    Resource_DiskInfo_Source::get_path_for_reflect,
                    Resource_DiskInfo_Source::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_DiskInfo_Source_Mount>>(
                    "mount",
                    Resource_DiskInfo_Source::get_mount_for_reflect,
                    Resource_DiskInfo_Source::mut_mount_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    Resource_DiskInfo_Source::get_id_for_reflect,
                    Resource_DiskInfo_Source::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "metadata",
                    Resource_DiskInfo_Source::get_metadata_for_reflect,
                    Resource_DiskInfo_Source::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "profile",
                    Resource_DiskInfo_Source::get_profile_for_reflect,
                    Resource_DiskInfo_Source::mut_profile_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Source>(
                    "Resource_DiskInfo_Source",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Source {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_path();
        self.clear_mount();
        self.clear_id();
        self.clear_metadata();
        self.clear_profile();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Source {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_DiskInfo_Source {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_DiskInfo_Source_Path {
    // message fields
    root: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Source_Path {}

impl Resource_DiskInfo_Source_Path {
    pub fn new() -> Resource_DiskInfo_Source_Path {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Source_Path {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Source_Path> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Source_Path,
        };
        unsafe {
            instance.get(Resource_DiskInfo_Source_Path::new)
        }
    }

    // optional string root = 1;

    pub fn clear_root(&mut self) {
        self.root.clear();
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: ::std::string::String) {
        self.root = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root(&mut self) -> &mut ::std::string::String {
        if self.root.is_none() {
            self.root.set_default();
        }
        self.root.as_mut().unwrap()
    }

    // Take field
    pub fn take_root(&mut self) -> ::std::string::String {
        self.root.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_root(&self) -> &str {
        match self.root.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_root_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.root
    }

    fn mut_root_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.root
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Source_Path {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.root)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.root.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.root.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Source_Path {
    fn new() -> Resource_DiskInfo_Source_Path {
        Resource_DiskInfo_Source_Path::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Source_Path>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "root",
                    Resource_DiskInfo_Source_Path::get_root_for_reflect,
                    Resource_DiskInfo_Source_Path::mut_root_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Source_Path>(
                    "Resource_DiskInfo_Source_Path",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Source_Path {
    fn clear(&mut self) {
        self.clear_root();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Source_Path {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_DiskInfo_Source_Path {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_DiskInfo_Source_Mount {
    // message fields
    root: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Source_Mount {}

impl Resource_DiskInfo_Source_Mount {
    pub fn new() -> Resource_DiskInfo_Source_Mount {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Source_Mount {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Source_Mount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Source_Mount,
        };
        unsafe {
            instance.get(Resource_DiskInfo_Source_Mount::new)
        }
    }

    // optional string root = 1;

    pub fn clear_root(&mut self) {
        self.root.clear();
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: ::std::string::String) {
        self.root = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root(&mut self) -> &mut ::std::string::String {
        if self.root.is_none() {
            self.root.set_default();
        }
        self.root.as_mut().unwrap()
    }

    // Take field
    pub fn take_root(&mut self) -> ::std::string::String {
        self.root.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_root(&self) -> &str {
        match self.root.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_root_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.root
    }

    fn mut_root_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.root
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Source_Mount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.root)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.root.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.root.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Source_Mount {
    fn new() -> Resource_DiskInfo_Source_Mount {
        Resource_DiskInfo_Source_Mount::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Source_Mount>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "root",
                    Resource_DiskInfo_Source_Mount::get_root_for_reflect,
                    Resource_DiskInfo_Source_Mount::mut_root_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Source_Mount>(
                    "Resource_DiskInfo_Source_Mount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Source_Mount {
    fn clear(&mut self) {
        self.clear_root();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Source_Mount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_DiskInfo_Source_Mount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Resource_DiskInfo_Source_Type {
    UNKNOWN = 0,
    PATH = 1,
    MOUNT = 2,
    BLOCK = 3,
    RAW = 4,
}

impl ::protobuf::ProtobufEnum for Resource_DiskInfo_Source_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Resource_DiskInfo_Source_Type> {
        match value {
            0 => ::std::option::Option::Some(Resource_DiskInfo_Source_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Resource_DiskInfo_Source_Type::PATH),
            2 => ::std::option::Option::Some(Resource_DiskInfo_Source_Type::MOUNT),
            3 => ::std::option::Option::Some(Resource_DiskInfo_Source_Type::BLOCK),
            4 => ::std::option::Option::Some(Resource_DiskInfo_Source_Type::RAW),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Resource_DiskInfo_Source_Type] = &[
            Resource_DiskInfo_Source_Type::UNKNOWN,
            Resource_DiskInfo_Source_Type::PATH,
            Resource_DiskInfo_Source_Type::MOUNT,
            Resource_DiskInfo_Source_Type::BLOCK,
            Resource_DiskInfo_Source_Type::RAW,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Source_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Resource_DiskInfo_Source_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Resource_DiskInfo_Source_Type {
}

impl ::protobuf::reflect::ProtobufValue for Resource_DiskInfo_Source_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_RevocableInfo {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_RevocableInfo {}

impl Resource_RevocableInfo {
    pub fn new() -> Resource_RevocableInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_RevocableInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_RevocableInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_RevocableInfo,
        };
        unsafe {
            instance.get(Resource_RevocableInfo::new)
        }
    }
}

impl ::protobuf::Message for Resource_RevocableInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_RevocableInfo {
    fn new() -> Resource_RevocableInfo {
        Resource_RevocableInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_RevocableInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Resource_RevocableInfo>(
                    "Resource_RevocableInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_RevocableInfo {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_RevocableInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_RevocableInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resource_SharedInfo {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_SharedInfo {}

impl Resource_SharedInfo {
    pub fn new() -> Resource_SharedInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_SharedInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_SharedInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_SharedInfo,
        };
        unsafe {
            instance.get(Resource_SharedInfo::new)
        }
    }
}

impl ::protobuf::Message for Resource_SharedInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_SharedInfo {
    fn new() -> Resource_SharedInfo {
        Resource_SharedInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_SharedInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Resource_SharedInfo>(
                    "Resource_SharedInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_SharedInfo {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource_SharedInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource_SharedInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrafficControlStatistics {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    backlog: ::std::option::Option<u64>,
    bytes: ::std::option::Option<u64>,
    drops: ::std::option::Option<u64>,
    overlimits: ::std::option::Option<u64>,
    packets: ::std::option::Option<u64>,
    qlen: ::std::option::Option<u64>,
    ratebps: ::std::option::Option<u64>,
    ratepps: ::std::option::Option<u64>,
    requeues: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TrafficControlStatistics {}

impl TrafficControlStatistics {
    pub fn new() -> TrafficControlStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TrafficControlStatistics {
        static mut instance: ::protobuf::lazy::Lazy<TrafficControlStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TrafficControlStatistics,
        };
        unsafe {
            instance.get(TrafficControlStatistics::new)
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.id
    }

    // optional uint64 backlog = 2;

    pub fn clear_backlog(&mut self) {
        self.backlog = ::std::option::Option::None;
    }

    pub fn has_backlog(&self) -> bool {
        self.backlog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backlog(&mut self, v: u64) {
        self.backlog = ::std::option::Option::Some(v);
    }

    pub fn get_backlog(&self) -> u64 {
        self.backlog.unwrap_or(0)
    }

    fn get_backlog_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.backlog
    }

    fn mut_backlog_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.backlog
    }

    // optional uint64 bytes = 3;

    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = ::std::option::Option::Some(v);
    }

    pub fn get_bytes(&self) -> u64 {
        self.bytes.unwrap_or(0)
    }

    fn get_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.bytes
    }

    fn mut_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.bytes
    }

    // optional uint64 drops = 4;

    pub fn clear_drops(&mut self) {
        self.drops = ::std::option::Option::None;
    }

    pub fn has_drops(&self) -> bool {
        self.drops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drops(&mut self, v: u64) {
        self.drops = ::std::option::Option::Some(v);
    }

    pub fn get_drops(&self) -> u64 {
        self.drops.unwrap_or(0)
    }

    fn get_drops_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.drops
    }

    fn mut_drops_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.drops
    }

    // optional uint64 overlimits = 5;

    pub fn clear_overlimits(&mut self) {
        self.overlimits = ::std::option::Option::None;
    }

    pub fn has_overlimits(&self) -> bool {
        self.overlimits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlimits(&mut self, v: u64) {
        self.overlimits = ::std::option::Option::Some(v);
    }

    pub fn get_overlimits(&self) -> u64 {
        self.overlimits.unwrap_or(0)
    }

    fn get_overlimits_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.overlimits
    }

    fn mut_overlimits_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.overlimits
    }

    // optional uint64 packets = 6;

    pub fn clear_packets(&mut self) {
        self.packets = ::std::option::Option::None;
    }

    pub fn has_packets(&self) -> bool {
        self.packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: u64) {
        self.packets = ::std::option::Option::Some(v);
    }

    pub fn get_packets(&self) -> u64 {
        self.packets.unwrap_or(0)
    }

    fn get_packets_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.packets
    }

    fn mut_packets_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.packets
    }

    // optional uint64 qlen = 7;

    pub fn clear_qlen(&mut self) {
        self.qlen = ::std::option::Option::None;
    }

    pub fn has_qlen(&self) -> bool {
        self.qlen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qlen(&mut self, v: u64) {
        self.qlen = ::std::option::Option::Some(v);
    }

    pub fn get_qlen(&self) -> u64 {
        self.qlen.unwrap_or(0)
    }

    fn get_qlen_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.qlen
    }

    fn mut_qlen_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.qlen
    }

    // optional uint64 ratebps = 8;

    pub fn clear_ratebps(&mut self) {
        self.ratebps = ::std::option::Option::None;
    }

    pub fn has_ratebps(&self) -> bool {
        self.ratebps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratebps(&mut self, v: u64) {
        self.ratebps = ::std::option::Option::Some(v);
    }

    pub fn get_ratebps(&self) -> u64 {
        self.ratebps.unwrap_or(0)
    }

    fn get_ratebps_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ratebps
    }

    fn mut_ratebps_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ratebps
    }

    // optional uint64 ratepps = 9;

    pub fn clear_ratepps(&mut self) {
        self.ratepps = ::std::option::Option::None;
    }

    pub fn has_ratepps(&self) -> bool {
        self.ratepps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratepps(&mut self, v: u64) {
        self.ratepps = ::std::option::Option::Some(v);
    }

    pub fn get_ratepps(&self) -> u64 {
        self.ratepps.unwrap_or(0)
    }

    fn get_ratepps_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ratepps
    }

    fn mut_ratepps_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ratepps
    }

    // optional uint64 requeues = 10;

    pub fn clear_requeues(&mut self) {
        self.requeues = ::std::option::Option::None;
    }

    pub fn has_requeues(&self) -> bool {
        self.requeues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requeues(&mut self, v: u64) {
        self.requeues = ::std::option::Option::Some(v);
    }

    pub fn get_requeues(&self) -> u64 {
        self.requeues.unwrap_or(0)
    }

    fn get_requeues_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.requeues
    }

    fn mut_requeues_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.requeues
    }
}

impl ::protobuf::Message for TrafficControlStatistics {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.backlog = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.drops = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.overlimits = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.qlen = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ratebps = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ratepps = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.requeues = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.backlog {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.drops {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.overlimits {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.qlen {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ratebps {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ratepps {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.requeues {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.backlog {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.bytes {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.drops {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.overlimits {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.packets {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.qlen {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.ratebps {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.ratepps {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.requeues {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TrafficControlStatistics {
    fn new() -> TrafficControlStatistics {
        TrafficControlStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<TrafficControlStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    TrafficControlStatistics::get_id_for_reflect,
                    TrafficControlStatistics::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "backlog",
                    TrafficControlStatistics::get_backlog_for_reflect,
                    TrafficControlStatistics::mut_backlog_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes",
                    TrafficControlStatistics::get_bytes_for_reflect,
                    TrafficControlStatistics::mut_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "drops",
                    TrafficControlStatistics::get_drops_for_reflect,
                    TrafficControlStatistics::mut_drops_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "overlimits",
                    TrafficControlStatistics::get_overlimits_for_reflect,
                    TrafficControlStatistics::mut_overlimits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "packets",
                    TrafficControlStatistics::get_packets_for_reflect,
                    TrafficControlStatistics::mut_packets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "qlen",
                    TrafficControlStatistics::get_qlen_for_reflect,
                    TrafficControlStatistics::mut_qlen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ratebps",
                    TrafficControlStatistics::get_ratebps_for_reflect,
                    TrafficControlStatistics::mut_ratebps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ratepps",
                    TrafficControlStatistics::get_ratepps_for_reflect,
                    TrafficControlStatistics::mut_ratepps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "requeues",
                    TrafficControlStatistics::get_requeues_for_reflect,
                    TrafficControlStatistics::mut_requeues_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TrafficControlStatistics>(
                    "TrafficControlStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TrafficControlStatistics {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_backlog();
        self.clear_bytes();
        self.clear_drops();
        self.clear_overlimits();
        self.clear_packets();
        self.clear_qlen();
        self.clear_ratebps();
        self.clear_ratepps();
        self.clear_requeues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficControlStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficControlStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IpStatistics {
    // message fields
    Forwarding: ::std::option::Option<i64>,
    DefaultTTL: ::std::option::Option<i64>,
    InReceives: ::std::option::Option<i64>,
    InHdrErrors: ::std::option::Option<i64>,
    InAddrErrors: ::std::option::Option<i64>,
    ForwDatagrams: ::std::option::Option<i64>,
    InUnknownProtos: ::std::option::Option<i64>,
    InDiscards: ::std::option::Option<i64>,
    InDelivers: ::std::option::Option<i64>,
    OutRequests: ::std::option::Option<i64>,
    OutDiscards: ::std::option::Option<i64>,
    OutNoRoutes: ::std::option::Option<i64>,
    ReasmTimeout: ::std::option::Option<i64>,
    ReasmReqds: ::std::option::Option<i64>,
    ReasmOKs: ::std::option::Option<i64>,
    ReasmFails: ::std::option::Option<i64>,
    FragOKs: ::std::option::Option<i64>,
    FragFails: ::std::option::Option<i64>,
    FragCreates: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IpStatistics {}

impl IpStatistics {
    pub fn new() -> IpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<IpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IpStatistics,
        };
        unsafe {
            instance.get(IpStatistics::new)
        }
    }

    // optional int64 Forwarding = 1;

    pub fn clear_Forwarding(&mut self) {
        self.Forwarding = ::std::option::Option::None;
    }

    pub fn has_Forwarding(&self) -> bool {
        self.Forwarding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Forwarding(&mut self, v: i64) {
        self.Forwarding = ::std::option::Option::Some(v);
    }

    pub fn get_Forwarding(&self) -> i64 {
        self.Forwarding.unwrap_or(0)
    }

    fn get_Forwarding_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.Forwarding
    }

    fn mut_Forwarding_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.Forwarding
    }

    // optional int64 DefaultTTL = 2;

    pub fn clear_DefaultTTL(&mut self) {
        self.DefaultTTL = ::std::option::Option::None;
    }

    pub fn has_DefaultTTL(&self) -> bool {
        self.DefaultTTL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DefaultTTL(&mut self, v: i64) {
        self.DefaultTTL = ::std::option::Option::Some(v);
    }

    pub fn get_DefaultTTL(&self) -> i64 {
        self.DefaultTTL.unwrap_or(0)
    }

    fn get_DefaultTTL_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.DefaultTTL
    }

    fn mut_DefaultTTL_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.DefaultTTL
    }

    // optional int64 InReceives = 3;

    pub fn clear_InReceives(&mut self) {
        self.InReceives = ::std::option::Option::None;
    }

    pub fn has_InReceives(&self) -> bool {
        self.InReceives.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InReceives(&mut self, v: i64) {
        self.InReceives = ::std::option::Option::Some(v);
    }

    pub fn get_InReceives(&self) -> i64 {
        self.InReceives.unwrap_or(0)
    }

    fn get_InReceives_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InReceives
    }

    fn mut_InReceives_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InReceives
    }

    // optional int64 InHdrErrors = 4;

    pub fn clear_InHdrErrors(&mut self) {
        self.InHdrErrors = ::std::option::Option::None;
    }

    pub fn has_InHdrErrors(&self) -> bool {
        self.InHdrErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InHdrErrors(&mut self, v: i64) {
        self.InHdrErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InHdrErrors(&self) -> i64 {
        self.InHdrErrors.unwrap_or(0)
    }

    fn get_InHdrErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InHdrErrors
    }

    fn mut_InHdrErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InHdrErrors
    }

    // optional int64 InAddrErrors = 5;

    pub fn clear_InAddrErrors(&mut self) {
        self.InAddrErrors = ::std::option::Option::None;
    }

    pub fn has_InAddrErrors(&self) -> bool {
        self.InAddrErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InAddrErrors(&mut self, v: i64) {
        self.InAddrErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InAddrErrors(&self) -> i64 {
        self.InAddrErrors.unwrap_or(0)
    }

    fn get_InAddrErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InAddrErrors
    }

    fn mut_InAddrErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InAddrErrors
    }

    // optional int64 ForwDatagrams = 6;

    pub fn clear_ForwDatagrams(&mut self) {
        self.ForwDatagrams = ::std::option::Option::None;
    }

    pub fn has_ForwDatagrams(&self) -> bool {
        self.ForwDatagrams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ForwDatagrams(&mut self, v: i64) {
        self.ForwDatagrams = ::std::option::Option::Some(v);
    }

    pub fn get_ForwDatagrams(&self) -> i64 {
        self.ForwDatagrams.unwrap_or(0)
    }

    fn get_ForwDatagrams_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.ForwDatagrams
    }

    fn mut_ForwDatagrams_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.ForwDatagrams
    }

    // optional int64 InUnknownProtos = 7;

    pub fn clear_InUnknownProtos(&mut self) {
        self.InUnknownProtos = ::std::option::Option::None;
    }

    pub fn has_InUnknownProtos(&self) -> bool {
        self.InUnknownProtos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InUnknownProtos(&mut self, v: i64) {
        self.InUnknownProtos = ::std::option::Option::Some(v);
    }

    pub fn get_InUnknownProtos(&self) -> i64 {
        self.InUnknownProtos.unwrap_or(0)
    }

    fn get_InUnknownProtos_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InUnknownProtos
    }

    fn mut_InUnknownProtos_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InUnknownProtos
    }

    // optional int64 InDiscards = 8;

    pub fn clear_InDiscards(&mut self) {
        self.InDiscards = ::std::option::Option::None;
    }

    pub fn has_InDiscards(&self) -> bool {
        self.InDiscards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDiscards(&mut self, v: i64) {
        self.InDiscards = ::std::option::Option::Some(v);
    }

    pub fn get_InDiscards(&self) -> i64 {
        self.InDiscards.unwrap_or(0)
    }

    fn get_InDiscards_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InDiscards
    }

    fn mut_InDiscards_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InDiscards
    }

    // optional int64 InDelivers = 9;

    pub fn clear_InDelivers(&mut self) {
        self.InDelivers = ::std::option::Option::None;
    }

    pub fn has_InDelivers(&self) -> bool {
        self.InDelivers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDelivers(&mut self, v: i64) {
        self.InDelivers = ::std::option::Option::Some(v);
    }

    pub fn get_InDelivers(&self) -> i64 {
        self.InDelivers.unwrap_or(0)
    }

    fn get_InDelivers_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InDelivers
    }

    fn mut_InDelivers_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InDelivers
    }

    // optional int64 OutRequests = 10;

    pub fn clear_OutRequests(&mut self) {
        self.OutRequests = ::std::option::Option::None;
    }

    pub fn has_OutRequests(&self) -> bool {
        self.OutRequests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutRequests(&mut self, v: i64) {
        self.OutRequests = ::std::option::Option::Some(v);
    }

    pub fn get_OutRequests(&self) -> i64 {
        self.OutRequests.unwrap_or(0)
    }

    fn get_OutRequests_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutRequests
    }

    fn mut_OutRequests_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutRequests
    }

    // optional int64 OutDiscards = 11;

    pub fn clear_OutDiscards(&mut self) {
        self.OutDiscards = ::std::option::Option::None;
    }

    pub fn has_OutDiscards(&self) -> bool {
        self.OutDiscards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutDiscards(&mut self, v: i64) {
        self.OutDiscards = ::std::option::Option::Some(v);
    }

    pub fn get_OutDiscards(&self) -> i64 {
        self.OutDiscards.unwrap_or(0)
    }

    fn get_OutDiscards_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutDiscards
    }

    fn mut_OutDiscards_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutDiscards
    }

    // optional int64 OutNoRoutes = 12;

    pub fn clear_OutNoRoutes(&mut self) {
        self.OutNoRoutes = ::std::option::Option::None;
    }

    pub fn has_OutNoRoutes(&self) -> bool {
        self.OutNoRoutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutNoRoutes(&mut self, v: i64) {
        self.OutNoRoutes = ::std::option::Option::Some(v);
    }

    pub fn get_OutNoRoutes(&self) -> i64 {
        self.OutNoRoutes.unwrap_or(0)
    }

    fn get_OutNoRoutes_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutNoRoutes
    }

    fn mut_OutNoRoutes_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutNoRoutes
    }

    // optional int64 ReasmTimeout = 13;

    pub fn clear_ReasmTimeout(&mut self) {
        self.ReasmTimeout = ::std::option::Option::None;
    }

    pub fn has_ReasmTimeout(&self) -> bool {
        self.ReasmTimeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmTimeout(&mut self, v: i64) {
        self.ReasmTimeout = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmTimeout(&self) -> i64 {
        self.ReasmTimeout.unwrap_or(0)
    }

    fn get_ReasmTimeout_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.ReasmTimeout
    }

    fn mut_ReasmTimeout_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.ReasmTimeout
    }

    // optional int64 ReasmReqds = 14;

    pub fn clear_ReasmReqds(&mut self) {
        self.ReasmReqds = ::std::option::Option::None;
    }

    pub fn has_ReasmReqds(&self) -> bool {
        self.ReasmReqds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmReqds(&mut self, v: i64) {
        self.ReasmReqds = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmReqds(&self) -> i64 {
        self.ReasmReqds.unwrap_or(0)
    }

    fn get_ReasmReqds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.ReasmReqds
    }

    fn mut_ReasmReqds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.ReasmReqds
    }

    // optional int64 ReasmOKs = 15;

    pub fn clear_ReasmOKs(&mut self) {
        self.ReasmOKs = ::std::option::Option::None;
    }

    pub fn has_ReasmOKs(&self) -> bool {
        self.ReasmOKs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmOKs(&mut self, v: i64) {
        self.ReasmOKs = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmOKs(&self) -> i64 {
        self.ReasmOKs.unwrap_or(0)
    }

    fn get_ReasmOKs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.ReasmOKs
    }

    fn mut_ReasmOKs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.ReasmOKs
    }

    // optional int64 ReasmFails = 16;

    pub fn clear_ReasmFails(&mut self) {
        self.ReasmFails = ::std::option::Option::None;
    }

    pub fn has_ReasmFails(&self) -> bool {
        self.ReasmFails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmFails(&mut self, v: i64) {
        self.ReasmFails = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmFails(&self) -> i64 {
        self.ReasmFails.unwrap_or(0)
    }

    fn get_ReasmFails_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.ReasmFails
    }

    fn mut_ReasmFails_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.ReasmFails
    }

    // optional int64 FragOKs = 17;

    pub fn clear_FragOKs(&mut self) {
        self.FragOKs = ::std::option::Option::None;
    }

    pub fn has_FragOKs(&self) -> bool {
        self.FragOKs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FragOKs(&mut self, v: i64) {
        self.FragOKs = ::std::option::Option::Some(v);
    }

    pub fn get_FragOKs(&self) -> i64 {
        self.FragOKs.unwrap_or(0)
    }

    fn get_FragOKs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.FragOKs
    }

    fn mut_FragOKs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.FragOKs
    }

    // optional int64 FragFails = 18;

    pub fn clear_FragFails(&mut self) {
        self.FragFails = ::std::option::Option::None;
    }

    pub fn has_FragFails(&self) -> bool {
        self.FragFails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FragFails(&mut self, v: i64) {
        self.FragFails = ::std::option::Option::Some(v);
    }

    pub fn get_FragFails(&self) -> i64 {
        self.FragFails.unwrap_or(0)
    }

    fn get_FragFails_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.FragFails
    }

    fn mut_FragFails_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.FragFails
    }

    // optional int64 FragCreates = 19;

    pub fn clear_FragCreates(&mut self) {
        self.FragCreates = ::std::option::Option::None;
    }

    pub fn has_FragCreates(&self) -> bool {
        self.FragCreates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FragCreates(&mut self, v: i64) {
        self.FragCreates = ::std::option::Option::Some(v);
    }

    pub fn get_FragCreates(&self) -> i64 {
        self.FragCreates.unwrap_or(0)
    }

    fn get_FragCreates_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.FragCreates
    }

    fn mut_FragCreates_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.FragCreates
    }
}

impl ::protobuf::Message for IpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Forwarding = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.DefaultTTL = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InReceives = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InHdrErrors = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InAddrErrors = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ForwDatagrams = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InUnknownProtos = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InDiscards = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InDelivers = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutRequests = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutDiscards = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutNoRoutes = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ReasmTimeout = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ReasmReqds = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ReasmOKs = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ReasmFails = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.FragOKs = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.FragFails = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.FragCreates = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Forwarding {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.DefaultTTL {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InReceives {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InHdrErrors {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InAddrErrors {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ForwDatagrams {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InUnknownProtos {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InDiscards {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InDelivers {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutRequests {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutDiscards {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutNoRoutes {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ReasmTimeout {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ReasmReqds {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ReasmOKs {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ReasmFails {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.FragOKs {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.FragFails {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.FragCreates {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Forwarding {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.DefaultTTL {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.InReceives {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.InHdrErrors {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.InAddrErrors {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.ForwDatagrams {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.InUnknownProtos {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.InDiscards {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.InDelivers {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.OutRequests {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.OutDiscards {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.OutNoRoutes {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.ReasmTimeout {
            os.write_int64(13, v)?;
        }
        if let Some(v) = self.ReasmReqds {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.ReasmOKs {
            os.write_int64(15, v)?;
        }
        if let Some(v) = self.ReasmFails {
            os.write_int64(16, v)?;
        }
        if let Some(v) = self.FragOKs {
            os.write_int64(17, v)?;
        }
        if let Some(v) = self.FragFails {
            os.write_int64(18, v)?;
        }
        if let Some(v) = self.FragCreates {
            os.write_int64(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IpStatistics {
    fn new() -> IpStatistics {
        IpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<IpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Forwarding",
                    IpStatistics::get_Forwarding_for_reflect,
                    IpStatistics::mut_Forwarding_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "DefaultTTL",
                    IpStatistics::get_DefaultTTL_for_reflect,
                    IpStatistics::mut_DefaultTTL_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InReceives",
                    IpStatistics::get_InReceives_for_reflect,
                    IpStatistics::mut_InReceives_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InHdrErrors",
                    IpStatistics::get_InHdrErrors_for_reflect,
                    IpStatistics::mut_InHdrErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InAddrErrors",
                    IpStatistics::get_InAddrErrors_for_reflect,
                    IpStatistics::mut_InAddrErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ForwDatagrams",
                    IpStatistics::get_ForwDatagrams_for_reflect,
                    IpStatistics::mut_ForwDatagrams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InUnknownProtos",
                    IpStatistics::get_InUnknownProtos_for_reflect,
                    IpStatistics::mut_InUnknownProtos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InDiscards",
                    IpStatistics::get_InDiscards_for_reflect,
                    IpStatistics::mut_InDiscards_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InDelivers",
                    IpStatistics::get_InDelivers_for_reflect,
                    IpStatistics::mut_InDelivers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutRequests",
                    IpStatistics::get_OutRequests_for_reflect,
                    IpStatistics::mut_OutRequests_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutDiscards",
                    IpStatistics::get_OutDiscards_for_reflect,
                    IpStatistics::mut_OutDiscards_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutNoRoutes",
                    IpStatistics::get_OutNoRoutes_for_reflect,
                    IpStatistics::mut_OutNoRoutes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ReasmTimeout",
                    IpStatistics::get_ReasmTimeout_for_reflect,
                    IpStatistics::mut_ReasmTimeout_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ReasmReqds",
                    IpStatistics::get_ReasmReqds_for_reflect,
                    IpStatistics::mut_ReasmReqds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ReasmOKs",
                    IpStatistics::get_ReasmOKs_for_reflect,
                    IpStatistics::mut_ReasmOKs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ReasmFails",
                    IpStatistics::get_ReasmFails_for_reflect,
                    IpStatistics::mut_ReasmFails_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "FragOKs",
                    IpStatistics::get_FragOKs_for_reflect,
                    IpStatistics::mut_FragOKs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "FragFails",
                    IpStatistics::get_FragFails_for_reflect,
                    IpStatistics::mut_FragFails_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "FragCreates",
                    IpStatistics::get_FragCreates_for_reflect,
                    IpStatistics::mut_FragCreates_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IpStatistics>(
                    "IpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IpStatistics {
    fn clear(&mut self) {
        self.clear_Forwarding();
        self.clear_DefaultTTL();
        self.clear_InReceives();
        self.clear_InHdrErrors();
        self.clear_InAddrErrors();
        self.clear_ForwDatagrams();
        self.clear_InUnknownProtos();
        self.clear_InDiscards();
        self.clear_InDelivers();
        self.clear_OutRequests();
        self.clear_OutDiscards();
        self.clear_OutNoRoutes();
        self.clear_ReasmTimeout();
        self.clear_ReasmReqds();
        self.clear_ReasmOKs();
        self.clear_ReasmFails();
        self.clear_FragOKs();
        self.clear_FragFails();
        self.clear_FragCreates();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IcmpStatistics {
    // message fields
    InMsgs: ::std::option::Option<i64>,
    InErrors: ::std::option::Option<i64>,
    InCsumErrors: ::std::option::Option<i64>,
    InDestUnreachs: ::std::option::Option<i64>,
    InTimeExcds: ::std::option::Option<i64>,
    InParmProbs: ::std::option::Option<i64>,
    InSrcQuenchs: ::std::option::Option<i64>,
    InRedirects: ::std::option::Option<i64>,
    InEchos: ::std::option::Option<i64>,
    InEchoReps: ::std::option::Option<i64>,
    InTimestamps: ::std::option::Option<i64>,
    InTimestampReps: ::std::option::Option<i64>,
    InAddrMasks: ::std::option::Option<i64>,
    InAddrMaskReps: ::std::option::Option<i64>,
    OutMsgs: ::std::option::Option<i64>,
    OutErrors: ::std::option::Option<i64>,
    OutDestUnreachs: ::std::option::Option<i64>,
    OutTimeExcds: ::std::option::Option<i64>,
    OutParmProbs: ::std::option::Option<i64>,
    OutSrcQuenchs: ::std::option::Option<i64>,
    OutRedirects: ::std::option::Option<i64>,
    OutEchos: ::std::option::Option<i64>,
    OutEchoReps: ::std::option::Option<i64>,
    OutTimestamps: ::std::option::Option<i64>,
    OutTimestampReps: ::std::option::Option<i64>,
    OutAddrMasks: ::std::option::Option<i64>,
    OutAddrMaskReps: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IcmpStatistics {}

impl IcmpStatistics {
    pub fn new() -> IcmpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IcmpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<IcmpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IcmpStatistics,
        };
        unsafe {
            instance.get(IcmpStatistics::new)
        }
    }

    // optional int64 InMsgs = 1;

    pub fn clear_InMsgs(&mut self) {
        self.InMsgs = ::std::option::Option::None;
    }

    pub fn has_InMsgs(&self) -> bool {
        self.InMsgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InMsgs(&mut self, v: i64) {
        self.InMsgs = ::std::option::Option::Some(v);
    }

    pub fn get_InMsgs(&self) -> i64 {
        self.InMsgs.unwrap_or(0)
    }

    fn get_InMsgs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InMsgs
    }

    fn mut_InMsgs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InMsgs
    }

    // optional int64 InErrors = 2;

    pub fn clear_InErrors(&mut self) {
        self.InErrors = ::std::option::Option::None;
    }

    pub fn has_InErrors(&self) -> bool {
        self.InErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InErrors(&mut self, v: i64) {
        self.InErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InErrors(&self) -> i64 {
        self.InErrors.unwrap_or(0)
    }

    fn get_InErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InErrors
    }

    fn mut_InErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InErrors
    }

    // optional int64 InCsumErrors = 3;

    pub fn clear_InCsumErrors(&mut self) {
        self.InCsumErrors = ::std::option::Option::None;
    }

    pub fn has_InCsumErrors(&self) -> bool {
        self.InCsumErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InCsumErrors(&mut self, v: i64) {
        self.InCsumErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InCsumErrors(&self) -> i64 {
        self.InCsumErrors.unwrap_or(0)
    }

    fn get_InCsumErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InCsumErrors
    }

    fn mut_InCsumErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InCsumErrors
    }

    // optional int64 InDestUnreachs = 4;

    pub fn clear_InDestUnreachs(&mut self) {
        self.InDestUnreachs = ::std::option::Option::None;
    }

    pub fn has_InDestUnreachs(&self) -> bool {
        self.InDestUnreachs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDestUnreachs(&mut self, v: i64) {
        self.InDestUnreachs = ::std::option::Option::Some(v);
    }

    pub fn get_InDestUnreachs(&self) -> i64 {
        self.InDestUnreachs.unwrap_or(0)
    }

    fn get_InDestUnreachs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InDestUnreachs
    }

    fn mut_InDestUnreachs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InDestUnreachs
    }

    // optional int64 InTimeExcds = 5;

    pub fn clear_InTimeExcds(&mut self) {
        self.InTimeExcds = ::std::option::Option::None;
    }

    pub fn has_InTimeExcds(&self) -> bool {
        self.InTimeExcds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InTimeExcds(&mut self, v: i64) {
        self.InTimeExcds = ::std::option::Option::Some(v);
    }

    pub fn get_InTimeExcds(&self) -> i64 {
        self.InTimeExcds.unwrap_or(0)
    }

    fn get_InTimeExcds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InTimeExcds
    }

    fn mut_InTimeExcds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InTimeExcds
    }

    // optional int64 InParmProbs = 6;

    pub fn clear_InParmProbs(&mut self) {
        self.InParmProbs = ::std::option::Option::None;
    }

    pub fn has_InParmProbs(&self) -> bool {
        self.InParmProbs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InParmProbs(&mut self, v: i64) {
        self.InParmProbs = ::std::option::Option::Some(v);
    }

    pub fn get_InParmProbs(&self) -> i64 {
        self.InParmProbs.unwrap_or(0)
    }

    fn get_InParmProbs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InParmProbs
    }

    fn mut_InParmProbs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InParmProbs
    }

    // optional int64 InSrcQuenchs = 7;

    pub fn clear_InSrcQuenchs(&mut self) {
        self.InSrcQuenchs = ::std::option::Option::None;
    }

    pub fn has_InSrcQuenchs(&self) -> bool {
        self.InSrcQuenchs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InSrcQuenchs(&mut self, v: i64) {
        self.InSrcQuenchs = ::std::option::Option::Some(v);
    }

    pub fn get_InSrcQuenchs(&self) -> i64 {
        self.InSrcQuenchs.unwrap_or(0)
    }

    fn get_InSrcQuenchs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InSrcQuenchs
    }

    fn mut_InSrcQuenchs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InSrcQuenchs
    }

    // optional int64 InRedirects = 8;

    pub fn clear_InRedirects(&mut self) {
        self.InRedirects = ::std::option::Option::None;
    }

    pub fn has_InRedirects(&self) -> bool {
        self.InRedirects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InRedirects(&mut self, v: i64) {
        self.InRedirects = ::std::option::Option::Some(v);
    }

    pub fn get_InRedirects(&self) -> i64 {
        self.InRedirects.unwrap_or(0)
    }

    fn get_InRedirects_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InRedirects
    }

    fn mut_InRedirects_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InRedirects
    }

    // optional int64 InEchos = 9;

    pub fn clear_InEchos(&mut self) {
        self.InEchos = ::std::option::Option::None;
    }

    pub fn has_InEchos(&self) -> bool {
        self.InEchos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InEchos(&mut self, v: i64) {
        self.InEchos = ::std::option::Option::Some(v);
    }

    pub fn get_InEchos(&self) -> i64 {
        self.InEchos.unwrap_or(0)
    }

    fn get_InEchos_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InEchos
    }

    fn mut_InEchos_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InEchos
    }

    // optional int64 InEchoReps = 10;

    pub fn clear_InEchoReps(&mut self) {
        self.InEchoReps = ::std::option::Option::None;
    }

    pub fn has_InEchoReps(&self) -> bool {
        self.InEchoReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InEchoReps(&mut self, v: i64) {
        self.InEchoReps = ::std::option::Option::Some(v);
    }

    pub fn get_InEchoReps(&self) -> i64 {
        self.InEchoReps.unwrap_or(0)
    }

    fn get_InEchoReps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InEchoReps
    }

    fn mut_InEchoReps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InEchoReps
    }

    // optional int64 InTimestamps = 11;

    pub fn clear_InTimestamps(&mut self) {
        self.InTimestamps = ::std::option::Option::None;
    }

    pub fn has_InTimestamps(&self) -> bool {
        self.InTimestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InTimestamps(&mut self, v: i64) {
        self.InTimestamps = ::std::option::Option::Some(v);
    }

    pub fn get_InTimestamps(&self) -> i64 {
        self.InTimestamps.unwrap_or(0)
    }

    fn get_InTimestamps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InTimestamps
    }

    fn mut_InTimestamps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InTimestamps
    }

    // optional int64 InTimestampReps = 12;

    pub fn clear_InTimestampReps(&mut self) {
        self.InTimestampReps = ::std::option::Option::None;
    }

    pub fn has_InTimestampReps(&self) -> bool {
        self.InTimestampReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InTimestampReps(&mut self, v: i64) {
        self.InTimestampReps = ::std::option::Option::Some(v);
    }

    pub fn get_InTimestampReps(&self) -> i64 {
        self.InTimestampReps.unwrap_or(0)
    }

    fn get_InTimestampReps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InTimestampReps
    }

    fn mut_InTimestampReps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InTimestampReps
    }

    // optional int64 InAddrMasks = 13;

    pub fn clear_InAddrMasks(&mut self) {
        self.InAddrMasks = ::std::option::Option::None;
    }

    pub fn has_InAddrMasks(&self) -> bool {
        self.InAddrMasks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InAddrMasks(&mut self, v: i64) {
        self.InAddrMasks = ::std::option::Option::Some(v);
    }

    pub fn get_InAddrMasks(&self) -> i64 {
        self.InAddrMasks.unwrap_or(0)
    }

    fn get_InAddrMasks_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InAddrMasks
    }

    fn mut_InAddrMasks_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InAddrMasks
    }

    // optional int64 InAddrMaskReps = 14;

    pub fn clear_InAddrMaskReps(&mut self) {
        self.InAddrMaskReps = ::std::option::Option::None;
    }

    pub fn has_InAddrMaskReps(&self) -> bool {
        self.InAddrMaskReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InAddrMaskReps(&mut self, v: i64) {
        self.InAddrMaskReps = ::std::option::Option::Some(v);
    }

    pub fn get_InAddrMaskReps(&self) -> i64 {
        self.InAddrMaskReps.unwrap_or(0)
    }

    fn get_InAddrMaskReps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InAddrMaskReps
    }

    fn mut_InAddrMaskReps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InAddrMaskReps
    }

    // optional int64 OutMsgs = 15;

    pub fn clear_OutMsgs(&mut self) {
        self.OutMsgs = ::std::option::Option::None;
    }

    pub fn has_OutMsgs(&self) -> bool {
        self.OutMsgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutMsgs(&mut self, v: i64) {
        self.OutMsgs = ::std::option::Option::Some(v);
    }

    pub fn get_OutMsgs(&self) -> i64 {
        self.OutMsgs.unwrap_or(0)
    }

    fn get_OutMsgs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutMsgs
    }

    fn mut_OutMsgs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutMsgs
    }

    // optional int64 OutErrors = 16;

    pub fn clear_OutErrors(&mut self) {
        self.OutErrors = ::std::option::Option::None;
    }

    pub fn has_OutErrors(&self) -> bool {
        self.OutErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutErrors(&mut self, v: i64) {
        self.OutErrors = ::std::option::Option::Some(v);
    }

    pub fn get_OutErrors(&self) -> i64 {
        self.OutErrors.unwrap_or(0)
    }

    fn get_OutErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutErrors
    }

    fn mut_OutErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutErrors
    }

    // optional int64 OutDestUnreachs = 17;

    pub fn clear_OutDestUnreachs(&mut self) {
        self.OutDestUnreachs = ::std::option::Option::None;
    }

    pub fn has_OutDestUnreachs(&self) -> bool {
        self.OutDestUnreachs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutDestUnreachs(&mut self, v: i64) {
        self.OutDestUnreachs = ::std::option::Option::Some(v);
    }

    pub fn get_OutDestUnreachs(&self) -> i64 {
        self.OutDestUnreachs.unwrap_or(0)
    }

    fn get_OutDestUnreachs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutDestUnreachs
    }

    fn mut_OutDestUnreachs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutDestUnreachs
    }

    // optional int64 OutTimeExcds = 18;

    pub fn clear_OutTimeExcds(&mut self) {
        self.OutTimeExcds = ::std::option::Option::None;
    }

    pub fn has_OutTimeExcds(&self) -> bool {
        self.OutTimeExcds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutTimeExcds(&mut self, v: i64) {
        self.OutTimeExcds = ::std::option::Option::Some(v);
    }

    pub fn get_OutTimeExcds(&self) -> i64 {
        self.OutTimeExcds.unwrap_or(0)
    }

    fn get_OutTimeExcds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutTimeExcds
    }

    fn mut_OutTimeExcds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutTimeExcds
    }

    // optional int64 OutParmProbs = 19;

    pub fn clear_OutParmProbs(&mut self) {
        self.OutParmProbs = ::std::option::Option::None;
    }

    pub fn has_OutParmProbs(&self) -> bool {
        self.OutParmProbs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutParmProbs(&mut self, v: i64) {
        self.OutParmProbs = ::std::option::Option::Some(v);
    }

    pub fn get_OutParmProbs(&self) -> i64 {
        self.OutParmProbs.unwrap_or(0)
    }

    fn get_OutParmProbs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutParmProbs
    }

    fn mut_OutParmProbs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutParmProbs
    }

    // optional int64 OutSrcQuenchs = 20;

    pub fn clear_OutSrcQuenchs(&mut self) {
        self.OutSrcQuenchs = ::std::option::Option::None;
    }

    pub fn has_OutSrcQuenchs(&self) -> bool {
        self.OutSrcQuenchs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutSrcQuenchs(&mut self, v: i64) {
        self.OutSrcQuenchs = ::std::option::Option::Some(v);
    }

    pub fn get_OutSrcQuenchs(&self) -> i64 {
        self.OutSrcQuenchs.unwrap_or(0)
    }

    fn get_OutSrcQuenchs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutSrcQuenchs
    }

    fn mut_OutSrcQuenchs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutSrcQuenchs
    }

    // optional int64 OutRedirects = 21;

    pub fn clear_OutRedirects(&mut self) {
        self.OutRedirects = ::std::option::Option::None;
    }

    pub fn has_OutRedirects(&self) -> bool {
        self.OutRedirects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutRedirects(&mut self, v: i64) {
        self.OutRedirects = ::std::option::Option::Some(v);
    }

    pub fn get_OutRedirects(&self) -> i64 {
        self.OutRedirects.unwrap_or(0)
    }

    fn get_OutRedirects_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutRedirects
    }

    fn mut_OutRedirects_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutRedirects
    }

    // optional int64 OutEchos = 22;

    pub fn clear_OutEchos(&mut self) {
        self.OutEchos = ::std::option::Option::None;
    }

    pub fn has_OutEchos(&self) -> bool {
        self.OutEchos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutEchos(&mut self, v: i64) {
        self.OutEchos = ::std::option::Option::Some(v);
    }

    pub fn get_OutEchos(&self) -> i64 {
        self.OutEchos.unwrap_or(0)
    }

    fn get_OutEchos_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutEchos
    }

    fn mut_OutEchos_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutEchos
    }

    // optional int64 OutEchoReps = 23;

    pub fn clear_OutEchoReps(&mut self) {
        self.OutEchoReps = ::std::option::Option::None;
    }

    pub fn has_OutEchoReps(&self) -> bool {
        self.OutEchoReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutEchoReps(&mut self, v: i64) {
        self.OutEchoReps = ::std::option::Option::Some(v);
    }

    pub fn get_OutEchoReps(&self) -> i64 {
        self.OutEchoReps.unwrap_or(0)
    }

    fn get_OutEchoReps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutEchoReps
    }

    fn mut_OutEchoReps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutEchoReps
    }

    // optional int64 OutTimestamps = 24;

    pub fn clear_OutTimestamps(&mut self) {
        self.OutTimestamps = ::std::option::Option::None;
    }

    pub fn has_OutTimestamps(&self) -> bool {
        self.OutTimestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutTimestamps(&mut self, v: i64) {
        self.OutTimestamps = ::std::option::Option::Some(v);
    }

    pub fn get_OutTimestamps(&self) -> i64 {
        self.OutTimestamps.unwrap_or(0)
    }

    fn get_OutTimestamps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutTimestamps
    }

    fn mut_OutTimestamps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutTimestamps
    }

    // optional int64 OutTimestampReps = 25;

    pub fn clear_OutTimestampReps(&mut self) {
        self.OutTimestampReps = ::std::option::Option::None;
    }

    pub fn has_OutTimestampReps(&self) -> bool {
        self.OutTimestampReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutTimestampReps(&mut self, v: i64) {
        self.OutTimestampReps = ::std::option::Option::Some(v);
    }

    pub fn get_OutTimestampReps(&self) -> i64 {
        self.OutTimestampReps.unwrap_or(0)
    }

    fn get_OutTimestampReps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutTimestampReps
    }

    fn mut_OutTimestampReps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutTimestampReps
    }

    // optional int64 OutAddrMasks = 26;

    pub fn clear_OutAddrMasks(&mut self) {
        self.OutAddrMasks = ::std::option::Option::None;
    }

    pub fn has_OutAddrMasks(&self) -> bool {
        self.OutAddrMasks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutAddrMasks(&mut self, v: i64) {
        self.OutAddrMasks = ::std::option::Option::Some(v);
    }

    pub fn get_OutAddrMasks(&self) -> i64 {
        self.OutAddrMasks.unwrap_or(0)
    }

    fn get_OutAddrMasks_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutAddrMasks
    }

    fn mut_OutAddrMasks_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutAddrMasks
    }

    // optional int64 OutAddrMaskReps = 27;

    pub fn clear_OutAddrMaskReps(&mut self) {
        self.OutAddrMaskReps = ::std::option::Option::None;
    }

    pub fn has_OutAddrMaskReps(&self) -> bool {
        self.OutAddrMaskReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutAddrMaskReps(&mut self, v: i64) {
        self.OutAddrMaskReps = ::std::option::Option::Some(v);
    }

    pub fn get_OutAddrMaskReps(&self) -> i64 {
        self.OutAddrMaskReps.unwrap_or(0)
    }

    fn get_OutAddrMaskReps_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutAddrMaskReps
    }

    fn mut_OutAddrMaskReps_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutAddrMaskReps
    }
}

impl ::protobuf::Message for IcmpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InMsgs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InErrors = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InCsumErrors = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InDestUnreachs = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InTimeExcds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InParmProbs = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InSrcQuenchs = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InRedirects = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InEchos = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InEchoReps = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InTimestamps = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InTimestampReps = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InAddrMasks = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InAddrMaskReps = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutMsgs = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutErrors = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutDestUnreachs = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutTimeExcds = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutParmProbs = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutSrcQuenchs = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutRedirects = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutEchos = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutEchoReps = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutTimestamps = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutTimestampReps = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutAddrMasks = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutAddrMaskReps = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.InMsgs {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InErrors {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InCsumErrors {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InDestUnreachs {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InTimeExcds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InParmProbs {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InSrcQuenchs {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InRedirects {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InEchos {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InEchoReps {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InTimestamps {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InTimestampReps {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InAddrMasks {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InAddrMaskReps {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutMsgs {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutErrors {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutDestUnreachs {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutTimeExcds {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutParmProbs {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutSrcQuenchs {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutRedirects {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutEchos {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutEchoReps {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutTimestamps {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutTimestampReps {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutAddrMasks {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutAddrMaskReps {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.InMsgs {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.InErrors {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.InCsumErrors {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.InDestUnreachs {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.InTimeExcds {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.InParmProbs {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.InSrcQuenchs {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.InRedirects {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.InEchos {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.InEchoReps {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.InTimestamps {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.InTimestampReps {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.InAddrMasks {
            os.write_int64(13, v)?;
        }
        if let Some(v) = self.InAddrMaskReps {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.OutMsgs {
            os.write_int64(15, v)?;
        }
        if let Some(v) = self.OutErrors {
            os.write_int64(16, v)?;
        }
        if let Some(v) = self.OutDestUnreachs {
            os.write_int64(17, v)?;
        }
        if let Some(v) = self.OutTimeExcds {
            os.write_int64(18, v)?;
        }
        if let Some(v) = self.OutParmProbs {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.OutSrcQuenchs {
            os.write_int64(20, v)?;
        }
        if let Some(v) = self.OutRedirects {
            os.write_int64(21, v)?;
        }
        if let Some(v) = self.OutEchos {
            os.write_int64(22, v)?;
        }
        if let Some(v) = self.OutEchoReps {
            os.write_int64(23, v)?;
        }
        if let Some(v) = self.OutTimestamps {
            os.write_int64(24, v)?;
        }
        if let Some(v) = self.OutTimestampReps {
            os.write_int64(25, v)?;
        }
        if let Some(v) = self.OutAddrMasks {
            os.write_int64(26, v)?;
        }
        if let Some(v) = self.OutAddrMaskReps {
            os.write_int64(27, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IcmpStatistics {
    fn new() -> IcmpStatistics {
        IcmpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<IcmpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InMsgs",
                    IcmpStatistics::get_InMsgs_for_reflect,
                    IcmpStatistics::mut_InMsgs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InErrors",
                    IcmpStatistics::get_InErrors_for_reflect,
                    IcmpStatistics::mut_InErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InCsumErrors",
                    IcmpStatistics::get_InCsumErrors_for_reflect,
                    IcmpStatistics::mut_InCsumErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InDestUnreachs",
                    IcmpStatistics::get_InDestUnreachs_for_reflect,
                    IcmpStatistics::mut_InDestUnreachs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InTimeExcds",
                    IcmpStatistics::get_InTimeExcds_for_reflect,
                    IcmpStatistics::mut_InTimeExcds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InParmProbs",
                    IcmpStatistics::get_InParmProbs_for_reflect,
                    IcmpStatistics::mut_InParmProbs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InSrcQuenchs",
                    IcmpStatistics::get_InSrcQuenchs_for_reflect,
                    IcmpStatistics::mut_InSrcQuenchs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InRedirects",
                    IcmpStatistics::get_InRedirects_for_reflect,
                    IcmpStatistics::mut_InRedirects_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InEchos",
                    IcmpStatistics::get_InEchos_for_reflect,
                    IcmpStatistics::mut_InEchos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InEchoReps",
                    IcmpStatistics::get_InEchoReps_for_reflect,
                    IcmpStatistics::mut_InEchoReps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InTimestamps",
                    IcmpStatistics::get_InTimestamps_for_reflect,
                    IcmpStatistics::mut_InTimestamps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InTimestampReps",
                    IcmpStatistics::get_InTimestampReps_for_reflect,
                    IcmpStatistics::mut_InTimestampReps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InAddrMasks",
                    IcmpStatistics::get_InAddrMasks_for_reflect,
                    IcmpStatistics::mut_InAddrMasks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InAddrMaskReps",
                    IcmpStatistics::get_InAddrMaskReps_for_reflect,
                    IcmpStatistics::mut_InAddrMaskReps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutMsgs",
                    IcmpStatistics::get_OutMsgs_for_reflect,
                    IcmpStatistics::mut_OutMsgs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutErrors",
                    IcmpStatistics::get_OutErrors_for_reflect,
                    IcmpStatistics::mut_OutErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutDestUnreachs",
                    IcmpStatistics::get_OutDestUnreachs_for_reflect,
                    IcmpStatistics::mut_OutDestUnreachs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutTimeExcds",
                    IcmpStatistics::get_OutTimeExcds_for_reflect,
                    IcmpStatistics::mut_OutTimeExcds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutParmProbs",
                    IcmpStatistics::get_OutParmProbs_for_reflect,
                    IcmpStatistics::mut_OutParmProbs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutSrcQuenchs",
                    IcmpStatistics::get_OutSrcQuenchs_for_reflect,
                    IcmpStatistics::mut_OutSrcQuenchs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutRedirects",
                    IcmpStatistics::get_OutRedirects_for_reflect,
                    IcmpStatistics::mut_OutRedirects_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutEchos",
                    IcmpStatistics::get_OutEchos_for_reflect,
                    IcmpStatistics::mut_OutEchos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutEchoReps",
                    IcmpStatistics::get_OutEchoReps_for_reflect,
                    IcmpStatistics::mut_OutEchoReps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutTimestamps",
                    IcmpStatistics::get_OutTimestamps_for_reflect,
                    IcmpStatistics::mut_OutTimestamps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutTimestampReps",
                    IcmpStatistics::get_OutTimestampReps_for_reflect,
                    IcmpStatistics::mut_OutTimestampReps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutAddrMasks",
                    IcmpStatistics::get_OutAddrMasks_for_reflect,
                    IcmpStatistics::mut_OutAddrMasks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutAddrMaskReps",
                    IcmpStatistics::get_OutAddrMaskReps_for_reflect,
                    IcmpStatistics::mut_OutAddrMaskReps_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IcmpStatistics>(
                    "IcmpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IcmpStatistics {
    fn clear(&mut self) {
        self.clear_InMsgs();
        self.clear_InErrors();
        self.clear_InCsumErrors();
        self.clear_InDestUnreachs();
        self.clear_InTimeExcds();
        self.clear_InParmProbs();
        self.clear_InSrcQuenchs();
        self.clear_InRedirects();
        self.clear_InEchos();
        self.clear_InEchoReps();
        self.clear_InTimestamps();
        self.clear_InTimestampReps();
        self.clear_InAddrMasks();
        self.clear_InAddrMaskReps();
        self.clear_OutMsgs();
        self.clear_OutErrors();
        self.clear_OutDestUnreachs();
        self.clear_OutTimeExcds();
        self.clear_OutParmProbs();
        self.clear_OutSrcQuenchs();
        self.clear_OutRedirects();
        self.clear_OutEchos();
        self.clear_OutEchoReps();
        self.clear_OutTimestamps();
        self.clear_OutTimestampReps();
        self.clear_OutAddrMasks();
        self.clear_OutAddrMaskReps();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IcmpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IcmpStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TcpStatistics {
    // message fields
    RtoAlgorithm: ::std::option::Option<i64>,
    RtoMin: ::std::option::Option<i64>,
    RtoMax: ::std::option::Option<i64>,
    MaxConn: ::std::option::Option<i64>,
    ActiveOpens: ::std::option::Option<i64>,
    PassiveOpens: ::std::option::Option<i64>,
    AttemptFails: ::std::option::Option<i64>,
    EstabResets: ::std::option::Option<i64>,
    CurrEstab: ::std::option::Option<i64>,
    InSegs: ::std::option::Option<i64>,
    OutSegs: ::std::option::Option<i64>,
    RetransSegs: ::std::option::Option<i64>,
    InErrs: ::std::option::Option<i64>,
    OutRsts: ::std::option::Option<i64>,
    InCsumErrors: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TcpStatistics {}

impl TcpStatistics {
    pub fn new() -> TcpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TcpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<TcpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TcpStatistics,
        };
        unsafe {
            instance.get(TcpStatistics::new)
        }
    }

    // optional int64 RtoAlgorithm = 1;

    pub fn clear_RtoAlgorithm(&mut self) {
        self.RtoAlgorithm = ::std::option::Option::None;
    }

    pub fn has_RtoAlgorithm(&self) -> bool {
        self.RtoAlgorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RtoAlgorithm(&mut self, v: i64) {
        self.RtoAlgorithm = ::std::option::Option::Some(v);
    }

    pub fn get_RtoAlgorithm(&self) -> i64 {
        self.RtoAlgorithm.unwrap_or(0)
    }

    fn get_RtoAlgorithm_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.RtoAlgorithm
    }

    fn mut_RtoAlgorithm_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.RtoAlgorithm
    }

    // optional int64 RtoMin = 2;

    pub fn clear_RtoMin(&mut self) {
        self.RtoMin = ::std::option::Option::None;
    }

    pub fn has_RtoMin(&self) -> bool {
        self.RtoMin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RtoMin(&mut self, v: i64) {
        self.RtoMin = ::std::option::Option::Some(v);
    }

    pub fn get_RtoMin(&self) -> i64 {
        self.RtoMin.unwrap_or(0)
    }

    fn get_RtoMin_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.RtoMin
    }

    fn mut_RtoMin_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.RtoMin
    }

    // optional int64 RtoMax = 3;

    pub fn clear_RtoMax(&mut self) {
        self.RtoMax = ::std::option::Option::None;
    }

    pub fn has_RtoMax(&self) -> bool {
        self.RtoMax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RtoMax(&mut self, v: i64) {
        self.RtoMax = ::std::option::Option::Some(v);
    }

    pub fn get_RtoMax(&self) -> i64 {
        self.RtoMax.unwrap_or(0)
    }

    fn get_RtoMax_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.RtoMax
    }

    fn mut_RtoMax_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.RtoMax
    }

    // optional int64 MaxConn = 4;

    pub fn clear_MaxConn(&mut self) {
        self.MaxConn = ::std::option::Option::None;
    }

    pub fn has_MaxConn(&self) -> bool {
        self.MaxConn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_MaxConn(&mut self, v: i64) {
        self.MaxConn = ::std::option::Option::Some(v);
    }

    pub fn get_MaxConn(&self) -> i64 {
        self.MaxConn.unwrap_or(0)
    }

    fn get_MaxConn_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.MaxConn
    }

    fn mut_MaxConn_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.MaxConn
    }

    // optional int64 ActiveOpens = 5;

    pub fn clear_ActiveOpens(&mut self) {
        self.ActiveOpens = ::std::option::Option::None;
    }

    pub fn has_ActiveOpens(&self) -> bool {
        self.ActiveOpens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ActiveOpens(&mut self, v: i64) {
        self.ActiveOpens = ::std::option::Option::Some(v);
    }

    pub fn get_ActiveOpens(&self) -> i64 {
        self.ActiveOpens.unwrap_or(0)
    }

    fn get_ActiveOpens_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.ActiveOpens
    }

    fn mut_ActiveOpens_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.ActiveOpens
    }

    // optional int64 PassiveOpens = 6;

    pub fn clear_PassiveOpens(&mut self) {
        self.PassiveOpens = ::std::option::Option::None;
    }

    pub fn has_PassiveOpens(&self) -> bool {
        self.PassiveOpens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PassiveOpens(&mut self, v: i64) {
        self.PassiveOpens = ::std::option::Option::Some(v);
    }

    pub fn get_PassiveOpens(&self) -> i64 {
        self.PassiveOpens.unwrap_or(0)
    }

    fn get_PassiveOpens_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.PassiveOpens
    }

    fn mut_PassiveOpens_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.PassiveOpens
    }

    // optional int64 AttemptFails = 7;

    pub fn clear_AttemptFails(&mut self) {
        self.AttemptFails = ::std::option::Option::None;
    }

    pub fn has_AttemptFails(&self) -> bool {
        self.AttemptFails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AttemptFails(&mut self, v: i64) {
        self.AttemptFails = ::std::option::Option::Some(v);
    }

    pub fn get_AttemptFails(&self) -> i64 {
        self.AttemptFails.unwrap_or(0)
    }

    fn get_AttemptFails_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.AttemptFails
    }

    fn mut_AttemptFails_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.AttemptFails
    }

    // optional int64 EstabResets = 8;

    pub fn clear_EstabResets(&mut self) {
        self.EstabResets = ::std::option::Option::None;
    }

    pub fn has_EstabResets(&self) -> bool {
        self.EstabResets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EstabResets(&mut self, v: i64) {
        self.EstabResets = ::std::option::Option::Some(v);
    }

    pub fn get_EstabResets(&self) -> i64 {
        self.EstabResets.unwrap_or(0)
    }

    fn get_EstabResets_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.EstabResets
    }

    fn mut_EstabResets_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.EstabResets
    }

    // optional int64 CurrEstab = 9;

    pub fn clear_CurrEstab(&mut self) {
        self.CurrEstab = ::std::option::Option::None;
    }

    pub fn has_CurrEstab(&self) -> bool {
        self.CurrEstab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CurrEstab(&mut self, v: i64) {
        self.CurrEstab = ::std::option::Option::Some(v);
    }

    pub fn get_CurrEstab(&self) -> i64 {
        self.CurrEstab.unwrap_or(0)
    }

    fn get_CurrEstab_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.CurrEstab
    }

    fn mut_CurrEstab_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.CurrEstab
    }

    // optional int64 InSegs = 10;

    pub fn clear_InSegs(&mut self) {
        self.InSegs = ::std::option::Option::None;
    }

    pub fn has_InSegs(&self) -> bool {
        self.InSegs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InSegs(&mut self, v: i64) {
        self.InSegs = ::std::option::Option::Some(v);
    }

    pub fn get_InSegs(&self) -> i64 {
        self.InSegs.unwrap_or(0)
    }

    fn get_InSegs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InSegs
    }

    fn mut_InSegs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InSegs
    }

    // optional int64 OutSegs = 11;

    pub fn clear_OutSegs(&mut self) {
        self.OutSegs = ::std::option::Option::None;
    }

    pub fn has_OutSegs(&self) -> bool {
        self.OutSegs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutSegs(&mut self, v: i64) {
        self.OutSegs = ::std::option::Option::Some(v);
    }

    pub fn get_OutSegs(&self) -> i64 {
        self.OutSegs.unwrap_or(0)
    }

    fn get_OutSegs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutSegs
    }

    fn mut_OutSegs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutSegs
    }

    // optional int64 RetransSegs = 12;

    pub fn clear_RetransSegs(&mut self) {
        self.RetransSegs = ::std::option::Option::None;
    }

    pub fn has_RetransSegs(&self) -> bool {
        self.RetransSegs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RetransSegs(&mut self, v: i64) {
        self.RetransSegs = ::std::option::Option::Some(v);
    }

    pub fn get_RetransSegs(&self) -> i64 {
        self.RetransSegs.unwrap_or(0)
    }

    fn get_RetransSegs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.RetransSegs
    }

    fn mut_RetransSegs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.RetransSegs
    }

    // optional int64 InErrs = 13;

    pub fn clear_InErrs(&mut self) {
        self.InErrs = ::std::option::Option::None;
    }

    pub fn has_InErrs(&self) -> bool {
        self.InErrs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InErrs(&mut self, v: i64) {
        self.InErrs = ::std::option::Option::Some(v);
    }

    pub fn get_InErrs(&self) -> i64 {
        self.InErrs.unwrap_or(0)
    }

    fn get_InErrs_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InErrs
    }

    fn mut_InErrs_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InErrs
    }

    // optional int64 OutRsts = 14;

    pub fn clear_OutRsts(&mut self) {
        self.OutRsts = ::std::option::Option::None;
    }

    pub fn has_OutRsts(&self) -> bool {
        self.OutRsts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutRsts(&mut self, v: i64) {
        self.OutRsts = ::std::option::Option::Some(v);
    }

    pub fn get_OutRsts(&self) -> i64 {
        self.OutRsts.unwrap_or(0)
    }

    fn get_OutRsts_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutRsts
    }

    fn mut_OutRsts_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutRsts
    }

    // optional int64 InCsumErrors = 15;

    pub fn clear_InCsumErrors(&mut self) {
        self.InCsumErrors = ::std::option::Option::None;
    }

    pub fn has_InCsumErrors(&self) -> bool {
        self.InCsumErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InCsumErrors(&mut self, v: i64) {
        self.InCsumErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InCsumErrors(&self) -> i64 {
        self.InCsumErrors.unwrap_or(0)
    }

    fn get_InCsumErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InCsumErrors
    }

    fn mut_InCsumErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InCsumErrors
    }
}

impl ::protobuf::Message for TcpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.RtoAlgorithm = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.RtoMin = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.RtoMax = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.MaxConn = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ActiveOpens = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.PassiveOpens = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.AttemptFails = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.EstabResets = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.CurrEstab = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InSegs = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutSegs = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.RetransSegs = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InErrs = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutRsts = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InCsumErrors = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.RtoAlgorithm {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.RtoMin {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.RtoMax {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.MaxConn {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ActiveOpens {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.PassiveOpens {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.AttemptFails {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.EstabResets {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.CurrEstab {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InSegs {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutSegs {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.RetransSegs {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InErrs {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutRsts {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InCsumErrors {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.RtoAlgorithm {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.RtoMin {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.RtoMax {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.MaxConn {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.ActiveOpens {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.PassiveOpens {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.AttemptFails {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.EstabResets {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.CurrEstab {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.InSegs {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.OutSegs {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.RetransSegs {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.InErrs {
            os.write_int64(13, v)?;
        }
        if let Some(v) = self.OutRsts {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.InCsumErrors {
            os.write_int64(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TcpStatistics {
    fn new() -> TcpStatistics {
        TcpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<TcpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "RtoAlgorithm",
                    TcpStatistics::get_RtoAlgorithm_for_reflect,
                    TcpStatistics::mut_RtoAlgorithm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "RtoMin",
                    TcpStatistics::get_RtoMin_for_reflect,
                    TcpStatistics::mut_RtoMin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "RtoMax",
                    TcpStatistics::get_RtoMax_for_reflect,
                    TcpStatistics::mut_RtoMax_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "MaxConn",
                    TcpStatistics::get_MaxConn_for_reflect,
                    TcpStatistics::mut_MaxConn_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ActiveOpens",
                    TcpStatistics::get_ActiveOpens_for_reflect,
                    TcpStatistics::mut_ActiveOpens_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "PassiveOpens",
                    TcpStatistics::get_PassiveOpens_for_reflect,
                    TcpStatistics::mut_PassiveOpens_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "AttemptFails",
                    TcpStatistics::get_AttemptFails_for_reflect,
                    TcpStatistics::mut_AttemptFails_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "EstabResets",
                    TcpStatistics::get_EstabResets_for_reflect,
                    TcpStatistics::mut_EstabResets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "CurrEstab",
                    TcpStatistics::get_CurrEstab_for_reflect,
                    TcpStatistics::mut_CurrEstab_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InSegs",
                    TcpStatistics::get_InSegs_for_reflect,
                    TcpStatistics::mut_InSegs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutSegs",
                    TcpStatistics::get_OutSegs_for_reflect,
                    TcpStatistics::mut_OutSegs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "RetransSegs",
                    TcpStatistics::get_RetransSegs_for_reflect,
                    TcpStatistics::mut_RetransSegs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InErrs",
                    TcpStatistics::get_InErrs_for_reflect,
                    TcpStatistics::mut_InErrs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutRsts",
                    TcpStatistics::get_OutRsts_for_reflect,
                    TcpStatistics::mut_OutRsts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InCsumErrors",
                    TcpStatistics::get_InCsumErrors_for_reflect,
                    TcpStatistics::mut_InCsumErrors_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TcpStatistics>(
                    "TcpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TcpStatistics {
    fn clear(&mut self) {
        self.clear_RtoAlgorithm();
        self.clear_RtoMin();
        self.clear_RtoMax();
        self.clear_MaxConn();
        self.clear_ActiveOpens();
        self.clear_PassiveOpens();
        self.clear_AttemptFails();
        self.clear_EstabResets();
        self.clear_CurrEstab();
        self.clear_InSegs();
        self.clear_OutSegs();
        self.clear_RetransSegs();
        self.clear_InErrs();
        self.clear_OutRsts();
        self.clear_InCsumErrors();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TcpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TcpStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UdpStatistics {
    // message fields
    InDatagrams: ::std::option::Option<i64>,
    NoPorts: ::std::option::Option<i64>,
    InErrors: ::std::option::Option<i64>,
    OutDatagrams: ::std::option::Option<i64>,
    RcvbufErrors: ::std::option::Option<i64>,
    SndbufErrors: ::std::option::Option<i64>,
    InCsumErrors: ::std::option::Option<i64>,
    IgnoredMulti: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UdpStatistics {}

impl UdpStatistics {
    pub fn new() -> UdpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UdpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<UdpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UdpStatistics,
        };
        unsafe {
            instance.get(UdpStatistics::new)
        }
    }

    // optional int64 InDatagrams = 1;

    pub fn clear_InDatagrams(&mut self) {
        self.InDatagrams = ::std::option::Option::None;
    }

    pub fn has_InDatagrams(&self) -> bool {
        self.InDatagrams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDatagrams(&mut self, v: i64) {
        self.InDatagrams = ::std::option::Option::Some(v);
    }

    pub fn get_InDatagrams(&self) -> i64 {
        self.InDatagrams.unwrap_or(0)
    }

    fn get_InDatagrams_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InDatagrams
    }

    fn mut_InDatagrams_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InDatagrams
    }

    // optional int64 NoPorts = 2;

    pub fn clear_NoPorts(&mut self) {
        self.NoPorts = ::std::option::Option::None;
    }

    pub fn has_NoPorts(&self) -> bool {
        self.NoPorts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_NoPorts(&mut self, v: i64) {
        self.NoPorts = ::std::option::Option::Some(v);
    }

    pub fn get_NoPorts(&self) -> i64 {
        self.NoPorts.unwrap_or(0)
    }

    fn get_NoPorts_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.NoPorts
    }

    fn mut_NoPorts_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.NoPorts
    }

    // optional int64 InErrors = 3;

    pub fn clear_InErrors(&mut self) {
        self.InErrors = ::std::option::Option::None;
    }

    pub fn has_InErrors(&self) -> bool {
        self.InErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InErrors(&mut self, v: i64) {
        self.InErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InErrors(&self) -> i64 {
        self.InErrors.unwrap_or(0)
    }

    fn get_InErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InErrors
    }

    fn mut_InErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InErrors
    }

    // optional int64 OutDatagrams = 4;

    pub fn clear_OutDatagrams(&mut self) {
        self.OutDatagrams = ::std::option::Option::None;
    }

    pub fn has_OutDatagrams(&self) -> bool {
        self.OutDatagrams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutDatagrams(&mut self, v: i64) {
        self.OutDatagrams = ::std::option::Option::Some(v);
    }

    pub fn get_OutDatagrams(&self) -> i64 {
        self.OutDatagrams.unwrap_or(0)
    }

    fn get_OutDatagrams_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.OutDatagrams
    }

    fn mut_OutDatagrams_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.OutDatagrams
    }

    // optional int64 RcvbufErrors = 5;

    pub fn clear_RcvbufErrors(&mut self) {
        self.RcvbufErrors = ::std::option::Option::None;
    }

    pub fn has_RcvbufErrors(&self) -> bool {
        self.RcvbufErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RcvbufErrors(&mut self, v: i64) {
        self.RcvbufErrors = ::std::option::Option::Some(v);
    }

    pub fn get_RcvbufErrors(&self) -> i64 {
        self.RcvbufErrors.unwrap_or(0)
    }

    fn get_RcvbufErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.RcvbufErrors
    }

    fn mut_RcvbufErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.RcvbufErrors
    }

    // optional int64 SndbufErrors = 6;

    pub fn clear_SndbufErrors(&mut self) {
        self.SndbufErrors = ::std::option::Option::None;
    }

    pub fn has_SndbufErrors(&self) -> bool {
        self.SndbufErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SndbufErrors(&mut self, v: i64) {
        self.SndbufErrors = ::std::option::Option::Some(v);
    }

    pub fn get_SndbufErrors(&self) -> i64 {
        self.SndbufErrors.unwrap_or(0)
    }

    fn get_SndbufErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.SndbufErrors
    }

    fn mut_SndbufErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.SndbufErrors
    }

    // optional int64 InCsumErrors = 7;

    pub fn clear_InCsumErrors(&mut self) {
        self.InCsumErrors = ::std::option::Option::None;
    }

    pub fn has_InCsumErrors(&self) -> bool {
        self.InCsumErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InCsumErrors(&mut self, v: i64) {
        self.InCsumErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InCsumErrors(&self) -> i64 {
        self.InCsumErrors.unwrap_or(0)
    }

    fn get_InCsumErrors_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.InCsumErrors
    }

    fn mut_InCsumErrors_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.InCsumErrors
    }

    // optional int64 IgnoredMulti = 8;

    pub fn clear_IgnoredMulti(&mut self) {
        self.IgnoredMulti = ::std::option::Option::None;
    }

    pub fn has_IgnoredMulti(&self) -> bool {
        self.IgnoredMulti.is_some()
    }

    // Param is passed by value, moved
    pub fn set_IgnoredMulti(&mut self, v: i64) {
        self.IgnoredMulti = ::std::option::Option::Some(v);
    }

    pub fn get_IgnoredMulti(&self) -> i64 {
        self.IgnoredMulti.unwrap_or(0)
    }

    fn get_IgnoredMulti_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.IgnoredMulti
    }

    fn mut_IgnoredMulti_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.IgnoredMulti
    }
}

impl ::protobuf::Message for UdpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InDatagrams = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NoPorts = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InErrors = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OutDatagrams = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.RcvbufErrors = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.SndbufErrors = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.InCsumErrors = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.IgnoredMulti = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.InDatagrams {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.NoPorts {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InErrors {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.OutDatagrams {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.RcvbufErrors {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.SndbufErrors {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.InCsumErrors {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.IgnoredMulti {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.InDatagrams {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.NoPorts {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.InErrors {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.OutDatagrams {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.RcvbufErrors {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.SndbufErrors {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.InCsumErrors {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.IgnoredMulti {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UdpStatistics {
    fn new() -> UdpStatistics {
        UdpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<UdpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InDatagrams",
                    UdpStatistics::get_InDatagrams_for_reflect,
                    UdpStatistics::mut_InDatagrams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "NoPorts",
                    UdpStatistics::get_NoPorts_for_reflect,
                    UdpStatistics::mut_NoPorts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InErrors",
                    UdpStatistics::get_InErrors_for_reflect,
                    UdpStatistics::mut_InErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OutDatagrams",
                    UdpStatistics::get_OutDatagrams_for_reflect,
                    UdpStatistics::mut_OutDatagrams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "RcvbufErrors",
                    UdpStatistics::get_RcvbufErrors_for_reflect,
                    UdpStatistics::mut_RcvbufErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "SndbufErrors",
                    UdpStatistics::get_SndbufErrors_for_reflect,
                    UdpStatistics::mut_SndbufErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "InCsumErrors",
                    UdpStatistics::get_InCsumErrors_for_reflect,
                    UdpStatistics::mut_InCsumErrors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "IgnoredMulti",
                    UdpStatistics::get_IgnoredMulti_for_reflect,
                    UdpStatistics::mut_IgnoredMulti_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UdpStatistics>(
                    "UdpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UdpStatistics {
    fn clear(&mut self) {
        self.clear_InDatagrams();
        self.clear_NoPorts();
        self.clear_InErrors();
        self.clear_OutDatagrams();
        self.clear_RcvbufErrors();
        self.clear_SndbufErrors();
        self.clear_InCsumErrors();
        self.clear_IgnoredMulti();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UdpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UdpStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SNMPStatistics {
    // message fields
    ip_stats: ::protobuf::SingularPtrField<IpStatistics>,
    icmp_stats: ::protobuf::SingularPtrField<IcmpStatistics>,
    tcp_stats: ::protobuf::SingularPtrField<TcpStatistics>,
    udp_stats: ::protobuf::SingularPtrField<UdpStatistics>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SNMPStatistics {}

impl SNMPStatistics {
    pub fn new() -> SNMPStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SNMPStatistics {
        static mut instance: ::protobuf::lazy::Lazy<SNMPStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SNMPStatistics,
        };
        unsafe {
            instance.get(SNMPStatistics::new)
        }
    }

    // optional .mesos.v1.IpStatistics ip_stats = 1;

    pub fn clear_ip_stats(&mut self) {
        self.ip_stats.clear();
    }

    pub fn has_ip_stats(&self) -> bool {
        self.ip_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_stats(&mut self, v: IpStatistics) {
        self.ip_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_stats(&mut self) -> &mut IpStatistics {
        if self.ip_stats.is_none() {
            self.ip_stats.set_default();
        }
        self.ip_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_stats(&mut self) -> IpStatistics {
        self.ip_stats.take().unwrap_or_else(|| IpStatistics::new())
    }

    pub fn get_ip_stats(&self) -> &IpStatistics {
        self.ip_stats.as_ref().unwrap_or_else(|| IpStatistics::default_instance())
    }

    fn get_ip_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<IpStatistics> {
        &self.ip_stats
    }

    fn mut_ip_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<IpStatistics> {
        &mut self.ip_stats
    }

    // optional .mesos.v1.IcmpStatistics icmp_stats = 2;

    pub fn clear_icmp_stats(&mut self) {
        self.icmp_stats.clear();
    }

    pub fn has_icmp_stats(&self) -> bool {
        self.icmp_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icmp_stats(&mut self, v: IcmpStatistics) {
        self.icmp_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icmp_stats(&mut self) -> &mut IcmpStatistics {
        if self.icmp_stats.is_none() {
            self.icmp_stats.set_default();
        }
        self.icmp_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_icmp_stats(&mut self) -> IcmpStatistics {
        self.icmp_stats.take().unwrap_or_else(|| IcmpStatistics::new())
    }

    pub fn get_icmp_stats(&self) -> &IcmpStatistics {
        self.icmp_stats.as_ref().unwrap_or_else(|| IcmpStatistics::default_instance())
    }

    fn get_icmp_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<IcmpStatistics> {
        &self.icmp_stats
    }

    fn mut_icmp_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<IcmpStatistics> {
        &mut self.icmp_stats
    }

    // optional .mesos.v1.TcpStatistics tcp_stats = 3;

    pub fn clear_tcp_stats(&mut self) {
        self.tcp_stats.clear();
    }

    pub fn has_tcp_stats(&self) -> bool {
        self.tcp_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_stats(&mut self, v: TcpStatistics) {
        self.tcp_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcp_stats(&mut self) -> &mut TcpStatistics {
        if self.tcp_stats.is_none() {
            self.tcp_stats.set_default();
        }
        self.tcp_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcp_stats(&mut self) -> TcpStatistics {
        self.tcp_stats.take().unwrap_or_else(|| TcpStatistics::new())
    }

    pub fn get_tcp_stats(&self) -> &TcpStatistics {
        self.tcp_stats.as_ref().unwrap_or_else(|| TcpStatistics::default_instance())
    }

    fn get_tcp_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<TcpStatistics> {
        &self.tcp_stats
    }

    fn mut_tcp_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TcpStatistics> {
        &mut self.tcp_stats
    }

    // optional .mesos.v1.UdpStatistics udp_stats = 4;

    pub fn clear_udp_stats(&mut self) {
        self.udp_stats.clear();
    }

    pub fn has_udp_stats(&self) -> bool {
        self.udp_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_stats(&mut self, v: UdpStatistics) {
        self.udp_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_udp_stats(&mut self) -> &mut UdpStatistics {
        if self.udp_stats.is_none() {
            self.udp_stats.set_default();
        }
        self.udp_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_udp_stats(&mut self) -> UdpStatistics {
        self.udp_stats.take().unwrap_or_else(|| UdpStatistics::new())
    }

    pub fn get_udp_stats(&self) -> &UdpStatistics {
        self.udp_stats.as_ref().unwrap_or_else(|| UdpStatistics::default_instance())
    }

    fn get_udp_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<UdpStatistics> {
        &self.udp_stats
    }

    fn mut_udp_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<UdpStatistics> {
        &mut self.udp_stats
    }
}

impl ::protobuf::Message for SNMPStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.ip_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.icmp_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcp_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.udp_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ip_stats)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.icmp_stats)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcp_stats)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.udp_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.icmp_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tcp_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.udp_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip_stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.icmp_stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tcp_stats.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.udp_stats.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SNMPStatistics {
    fn new() -> SNMPStatistics {
        SNMPStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<SNMPStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpStatistics>>(
                    "ip_stats",
                    SNMPStatistics::get_ip_stats_for_reflect,
                    SNMPStatistics::mut_ip_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IcmpStatistics>>(
                    "icmp_stats",
                    SNMPStatistics::get_icmp_stats_for_reflect,
                    SNMPStatistics::mut_icmp_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TcpStatistics>>(
                    "tcp_stats",
                    SNMPStatistics::get_tcp_stats_for_reflect,
                    SNMPStatistics::mut_tcp_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UdpStatistics>>(
                    "udp_stats",
                    SNMPStatistics::get_udp_stats_for_reflect,
                    SNMPStatistics::mut_udp_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SNMPStatistics>(
                    "SNMPStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SNMPStatistics {
    fn clear(&mut self) {
        self.clear_ip_stats();
        self.clear_icmp_stats();
        self.clear_tcp_stats();
        self.clear_udp_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SNMPStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SNMPStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiskStatistics {
    // message fields
    source: ::protobuf::SingularPtrField<Resource_DiskInfo_Source>,
    persistence: ::protobuf::SingularPtrField<Resource_DiskInfo_Persistence>,
    limit_bytes: ::std::option::Option<u64>,
    used_bytes: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DiskStatistics {}

impl DiskStatistics {
    pub fn new() -> DiskStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DiskStatistics {
        static mut instance: ::protobuf::lazy::Lazy<DiskStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiskStatistics,
        };
        unsafe {
            instance.get(DiskStatistics::new)
        }
    }

    // optional .mesos.v1.Resource.DiskInfo.Source source = 1;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Resource_DiskInfo_Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Resource_DiskInfo_Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Resource_DiskInfo_Source {
        self.source.take().unwrap_or_else(|| Resource_DiskInfo_Source::new())
    }

    pub fn get_source(&self) -> &Resource_DiskInfo_Source {
        self.source.as_ref().unwrap_or_else(|| Resource_DiskInfo_Source::default_instance())
    }

    fn get_source_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_DiskInfo_Source> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_DiskInfo_Source> {
        &mut self.source
    }

    // optional .mesos.v1.Resource.DiskInfo.Persistence persistence = 2;

    pub fn clear_persistence(&mut self) {
        self.persistence.clear();
    }

    pub fn has_persistence(&self) -> bool {
        self.persistence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistence(&mut self, v: Resource_DiskInfo_Persistence) {
        self.persistence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistence(&mut self) -> &mut Resource_DiskInfo_Persistence {
        if self.persistence.is_none() {
            self.persistence.set_default();
        }
        self.persistence.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistence(&mut self) -> Resource_DiskInfo_Persistence {
        self.persistence.take().unwrap_or_else(|| Resource_DiskInfo_Persistence::new())
    }

    pub fn get_persistence(&self) -> &Resource_DiskInfo_Persistence {
        self.persistence.as_ref().unwrap_or_else(|| Resource_DiskInfo_Persistence::default_instance())
    }

    fn get_persistence_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_DiskInfo_Persistence> {
        &self.persistence
    }

    fn mut_persistence_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_DiskInfo_Persistence> {
        &mut self.persistence
    }

    // optional uint64 limit_bytes = 3;

    pub fn clear_limit_bytes(&mut self) {
        self.limit_bytes = ::std::option::Option::None;
    }

    pub fn has_limit_bytes(&self) -> bool {
        self.limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit_bytes(&mut self, v: u64) {
        self.limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_limit_bytes(&self) -> u64 {
        self.limit_bytes.unwrap_or(0)
    }

    fn get_limit_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.limit_bytes
    }

    fn mut_limit_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.limit_bytes
    }

    // optional uint64 used_bytes = 4;

    pub fn clear_used_bytes(&mut self) {
        self.used_bytes = ::std::option::Option::None;
    }

    pub fn has_used_bytes(&self) -> bool {
        self.used_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used_bytes(&mut self, v: u64) {
        self.used_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_used_bytes(&self) -> u64 {
        self.used_bytes.unwrap_or(0)
    }

    fn get_used_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.used_bytes
    }

    fn mut_used_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.used_bytes
    }
}

impl ::protobuf::Message for DiskStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.persistence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistence)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit_bytes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used_bytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.persistence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.limit_bytes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.used_bytes {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.persistence.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.limit_bytes {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.used_bytes {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DiskStatistics {
    fn new() -> DiskStatistics {
        DiskStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<DiskStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_DiskInfo_Source>>(
                    "source",
                    DiskStatistics::get_source_for_reflect,
                    DiskStatistics::mut_source_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_DiskInfo_Persistence>>(
                    "persistence",
                    DiskStatistics::get_persistence_for_reflect,
                    DiskStatistics::mut_persistence_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit_bytes",
                    DiskStatistics::get_limit_bytes_for_reflect,
                    DiskStatistics::mut_limit_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "used_bytes",
                    DiskStatistics::get_used_bytes_for_reflect,
                    DiskStatistics::mut_used_bytes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiskStatistics>(
                    "DiskStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DiskStatistics {
    fn clear(&mut self) {
        self.clear_source();
        self.clear_persistence();
        self.clear_limit_bytes();
        self.clear_used_bytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiskStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiskStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceStatistics {
    // message fields
    timestamp: ::std::option::Option<f64>,
    processes: ::std::option::Option<u32>,
    threads: ::std::option::Option<u32>,
    cpus_user_time_secs: ::std::option::Option<f64>,
    cpus_system_time_secs: ::std::option::Option<f64>,
    cpus_limit: ::std::option::Option<f64>,
    cpus_nr_periods: ::std::option::Option<u32>,
    cpus_nr_throttled: ::std::option::Option<u32>,
    cpus_throttled_time_secs: ::std::option::Option<f64>,
    mem_total_bytes: ::std::option::Option<u64>,
    mem_total_memsw_bytes: ::std::option::Option<u64>,
    mem_limit_bytes: ::std::option::Option<u64>,
    mem_soft_limit_bytes: ::std::option::Option<u64>,
    mem_file_bytes: ::std::option::Option<u64>,
    mem_anon_bytes: ::std::option::Option<u64>,
    mem_cache_bytes: ::std::option::Option<u64>,
    mem_rss_bytes: ::std::option::Option<u64>,
    mem_mapped_file_bytes: ::std::option::Option<u64>,
    mem_swap_bytes: ::std::option::Option<u64>,
    mem_unevictable_bytes: ::std::option::Option<u64>,
    mem_low_pressure_counter: ::std::option::Option<u64>,
    mem_medium_pressure_counter: ::std::option::Option<u64>,
    mem_critical_pressure_counter: ::std::option::Option<u64>,
    disk_limit_bytes: ::std::option::Option<u64>,
    disk_used_bytes: ::std::option::Option<u64>,
    disk_statistics: ::protobuf::RepeatedField<DiskStatistics>,
    blkio_statistics: ::protobuf::SingularPtrField<CgroupInfo_Blkio_Statistics>,
    perf: ::protobuf::SingularPtrField<PerfStatistics>,
    net_rx_packets: ::std::option::Option<u64>,
    net_rx_bytes: ::std::option::Option<u64>,
    net_rx_errors: ::std::option::Option<u64>,
    net_rx_dropped: ::std::option::Option<u64>,
    net_tx_packets: ::std::option::Option<u64>,
    net_tx_bytes: ::std::option::Option<u64>,
    net_tx_errors: ::std::option::Option<u64>,
    net_tx_dropped: ::std::option::Option<u64>,
    net_tcp_rtt_microsecs_p50: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p90: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p95: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p99: ::std::option::Option<f64>,
    net_tcp_active_connections: ::std::option::Option<f64>,
    net_tcp_time_wait_connections: ::std::option::Option<f64>,
    net_traffic_control_statistics: ::protobuf::RepeatedField<TrafficControlStatistics>,
    net_snmp_statistics: ::protobuf::SingularPtrField<SNMPStatistics>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceStatistics {}

impl ResourceStatistics {
    pub fn new() -> ResourceStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceStatistics {
        static mut instance: ::protobuf::lazy::Lazy<ResourceStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceStatistics,
        };
        unsafe {
            instance.get(ResourceStatistics::new)
        }
    }

    // required double timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.timestamp
    }

    // optional uint32 processes = 30;

    pub fn clear_processes(&mut self) {
        self.processes = ::std::option::Option::None;
    }

    pub fn has_processes(&self) -> bool {
        self.processes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processes(&mut self, v: u32) {
        self.processes = ::std::option::Option::Some(v);
    }

    pub fn get_processes(&self) -> u32 {
        self.processes.unwrap_or(0)
    }

    fn get_processes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.processes
    }

    fn mut_processes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.processes
    }

    // optional uint32 threads = 31;

    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: u32) {
        self.threads = ::std::option::Option::Some(v);
    }

    pub fn get_threads(&self) -> u32 {
        self.threads.unwrap_or(0)
    }

    fn get_threads_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.threads
    }

    fn mut_threads_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.threads
    }

    // optional double cpus_user_time_secs = 2;

    pub fn clear_cpus_user_time_secs(&mut self) {
        self.cpus_user_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_user_time_secs(&self) -> bool {
        self.cpus_user_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_user_time_secs(&mut self, v: f64) {
        self.cpus_user_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_user_time_secs(&self) -> f64 {
        self.cpus_user_time_secs.unwrap_or(0.)
    }

    fn get_cpus_user_time_secs_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.cpus_user_time_secs
    }

    fn mut_cpus_user_time_secs_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.cpus_user_time_secs
    }

    // optional double cpus_system_time_secs = 3;

    pub fn clear_cpus_system_time_secs(&mut self) {
        self.cpus_system_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_system_time_secs(&self) -> bool {
        self.cpus_system_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_system_time_secs(&mut self, v: f64) {
        self.cpus_system_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_system_time_secs(&self) -> f64 {
        self.cpus_system_time_secs.unwrap_or(0.)
    }

    fn get_cpus_system_time_secs_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.cpus_system_time_secs
    }

    fn mut_cpus_system_time_secs_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.cpus_system_time_secs
    }

    // optional double cpus_limit = 4;

    pub fn clear_cpus_limit(&mut self) {
        self.cpus_limit = ::std::option::Option::None;
    }

    pub fn has_cpus_limit(&self) -> bool {
        self.cpus_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_limit(&mut self, v: f64) {
        self.cpus_limit = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_limit(&self) -> f64 {
        self.cpus_limit.unwrap_or(0.)
    }

    fn get_cpus_limit_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.cpus_limit
    }

    fn mut_cpus_limit_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.cpus_limit
    }

    // optional uint32 cpus_nr_periods = 7;

    pub fn clear_cpus_nr_periods(&mut self) {
        self.cpus_nr_periods = ::std::option::Option::None;
    }

    pub fn has_cpus_nr_periods(&self) -> bool {
        self.cpus_nr_periods.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_nr_periods(&mut self, v: u32) {
        self.cpus_nr_periods = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_nr_periods(&self) -> u32 {
        self.cpus_nr_periods.unwrap_or(0)
    }

    fn get_cpus_nr_periods_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cpus_nr_periods
    }

    fn mut_cpus_nr_periods_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cpus_nr_periods
    }

    // optional uint32 cpus_nr_throttled = 8;

    pub fn clear_cpus_nr_throttled(&mut self) {
        self.cpus_nr_throttled = ::std::option::Option::None;
    }

    pub fn has_cpus_nr_throttled(&self) -> bool {
        self.cpus_nr_throttled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_nr_throttled(&mut self, v: u32) {
        self.cpus_nr_throttled = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_nr_throttled(&self) -> u32 {
        self.cpus_nr_throttled.unwrap_or(0)
    }

    fn get_cpus_nr_throttled_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cpus_nr_throttled
    }

    fn mut_cpus_nr_throttled_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cpus_nr_throttled
    }

    // optional double cpus_throttled_time_secs = 9;

    pub fn clear_cpus_throttled_time_secs(&mut self) {
        self.cpus_throttled_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_throttled_time_secs(&self) -> bool {
        self.cpus_throttled_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_throttled_time_secs(&mut self, v: f64) {
        self.cpus_throttled_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_throttled_time_secs(&self) -> f64 {
        self.cpus_throttled_time_secs.unwrap_or(0.)
    }

    fn get_cpus_throttled_time_secs_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.cpus_throttled_time_secs
    }

    fn mut_cpus_throttled_time_secs_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.cpus_throttled_time_secs
    }

    // optional uint64 mem_total_bytes = 36;

    pub fn clear_mem_total_bytes(&mut self) {
        self.mem_total_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_total_bytes(&self) -> bool {
        self.mem_total_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_total_bytes(&mut self, v: u64) {
        self.mem_total_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_total_bytes(&self) -> u64 {
        self.mem_total_bytes.unwrap_or(0)
    }

    fn get_mem_total_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_total_bytes
    }

    fn mut_mem_total_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_total_bytes
    }

    // optional uint64 mem_total_memsw_bytes = 37;

    pub fn clear_mem_total_memsw_bytes(&mut self) {
        self.mem_total_memsw_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_total_memsw_bytes(&self) -> bool {
        self.mem_total_memsw_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_total_memsw_bytes(&mut self, v: u64) {
        self.mem_total_memsw_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_total_memsw_bytes(&self) -> u64 {
        self.mem_total_memsw_bytes.unwrap_or(0)
    }

    fn get_mem_total_memsw_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_total_memsw_bytes
    }

    fn mut_mem_total_memsw_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_total_memsw_bytes
    }

    // optional uint64 mem_limit_bytes = 6;

    pub fn clear_mem_limit_bytes(&mut self) {
        self.mem_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_limit_bytes(&self) -> bool {
        self.mem_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_limit_bytes(&mut self, v: u64) {
        self.mem_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_limit_bytes(&self) -> u64 {
        self.mem_limit_bytes.unwrap_or(0)
    }

    fn get_mem_limit_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_limit_bytes
    }

    fn mut_mem_limit_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_limit_bytes
    }

    // optional uint64 mem_soft_limit_bytes = 38;

    pub fn clear_mem_soft_limit_bytes(&mut self) {
        self.mem_soft_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_soft_limit_bytes(&self) -> bool {
        self.mem_soft_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_soft_limit_bytes(&mut self, v: u64) {
        self.mem_soft_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_soft_limit_bytes(&self) -> u64 {
        self.mem_soft_limit_bytes.unwrap_or(0)
    }

    fn get_mem_soft_limit_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_soft_limit_bytes
    }

    fn mut_mem_soft_limit_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_soft_limit_bytes
    }

    // optional uint64 mem_file_bytes = 10;

    pub fn clear_mem_file_bytes(&mut self) {
        self.mem_file_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_file_bytes(&self) -> bool {
        self.mem_file_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_file_bytes(&mut self, v: u64) {
        self.mem_file_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_file_bytes(&self) -> u64 {
        self.mem_file_bytes.unwrap_or(0)
    }

    fn get_mem_file_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_file_bytes
    }

    fn mut_mem_file_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_file_bytes
    }

    // optional uint64 mem_anon_bytes = 11;

    pub fn clear_mem_anon_bytes(&mut self) {
        self.mem_anon_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_anon_bytes(&self) -> bool {
        self.mem_anon_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_anon_bytes(&mut self, v: u64) {
        self.mem_anon_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_anon_bytes(&self) -> u64 {
        self.mem_anon_bytes.unwrap_or(0)
    }

    fn get_mem_anon_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_anon_bytes
    }

    fn mut_mem_anon_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_anon_bytes
    }

    // optional uint64 mem_cache_bytes = 39;

    pub fn clear_mem_cache_bytes(&mut self) {
        self.mem_cache_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_cache_bytes(&self) -> bool {
        self.mem_cache_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_cache_bytes(&mut self, v: u64) {
        self.mem_cache_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_cache_bytes(&self) -> u64 {
        self.mem_cache_bytes.unwrap_or(0)
    }

    fn get_mem_cache_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_cache_bytes
    }

    fn mut_mem_cache_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_cache_bytes
    }

    // optional uint64 mem_rss_bytes = 5;

    pub fn clear_mem_rss_bytes(&mut self) {
        self.mem_rss_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_rss_bytes(&self) -> bool {
        self.mem_rss_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_rss_bytes(&mut self, v: u64) {
        self.mem_rss_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_rss_bytes(&self) -> u64 {
        self.mem_rss_bytes.unwrap_or(0)
    }

    fn get_mem_rss_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_rss_bytes
    }

    fn mut_mem_rss_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_rss_bytes
    }

    // optional uint64 mem_mapped_file_bytes = 12;

    pub fn clear_mem_mapped_file_bytes(&mut self) {
        self.mem_mapped_file_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_mapped_file_bytes(&self) -> bool {
        self.mem_mapped_file_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_mapped_file_bytes(&mut self, v: u64) {
        self.mem_mapped_file_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_mapped_file_bytes(&self) -> u64 {
        self.mem_mapped_file_bytes.unwrap_or(0)
    }

    fn get_mem_mapped_file_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_mapped_file_bytes
    }

    fn mut_mem_mapped_file_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_mapped_file_bytes
    }

    // optional uint64 mem_swap_bytes = 40;

    pub fn clear_mem_swap_bytes(&mut self) {
        self.mem_swap_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_swap_bytes(&self) -> bool {
        self.mem_swap_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_swap_bytes(&mut self, v: u64) {
        self.mem_swap_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_swap_bytes(&self) -> u64 {
        self.mem_swap_bytes.unwrap_or(0)
    }

    fn get_mem_swap_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_swap_bytes
    }

    fn mut_mem_swap_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_swap_bytes
    }

    // optional uint64 mem_unevictable_bytes = 41;

    pub fn clear_mem_unevictable_bytes(&mut self) {
        self.mem_unevictable_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_unevictable_bytes(&self) -> bool {
        self.mem_unevictable_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_unevictable_bytes(&mut self, v: u64) {
        self.mem_unevictable_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_unevictable_bytes(&self) -> u64 {
        self.mem_unevictable_bytes.unwrap_or(0)
    }

    fn get_mem_unevictable_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_unevictable_bytes
    }

    fn mut_mem_unevictable_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_unevictable_bytes
    }

    // optional uint64 mem_low_pressure_counter = 32;

    pub fn clear_mem_low_pressure_counter(&mut self) {
        self.mem_low_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_low_pressure_counter(&self) -> bool {
        self.mem_low_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_low_pressure_counter(&mut self, v: u64) {
        self.mem_low_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_low_pressure_counter(&self) -> u64 {
        self.mem_low_pressure_counter.unwrap_or(0)
    }

    fn get_mem_low_pressure_counter_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_low_pressure_counter
    }

    fn mut_mem_low_pressure_counter_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_low_pressure_counter
    }

    // optional uint64 mem_medium_pressure_counter = 33;

    pub fn clear_mem_medium_pressure_counter(&mut self) {
        self.mem_medium_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_medium_pressure_counter(&self) -> bool {
        self.mem_medium_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_medium_pressure_counter(&mut self, v: u64) {
        self.mem_medium_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_medium_pressure_counter(&self) -> u64 {
        self.mem_medium_pressure_counter.unwrap_or(0)
    }

    fn get_mem_medium_pressure_counter_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_medium_pressure_counter
    }

    fn mut_mem_medium_pressure_counter_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_medium_pressure_counter
    }

    // optional uint64 mem_critical_pressure_counter = 34;

    pub fn clear_mem_critical_pressure_counter(&mut self) {
        self.mem_critical_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_critical_pressure_counter(&self) -> bool {
        self.mem_critical_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_critical_pressure_counter(&mut self, v: u64) {
        self.mem_critical_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_critical_pressure_counter(&self) -> u64 {
        self.mem_critical_pressure_counter.unwrap_or(0)
    }

    fn get_mem_critical_pressure_counter_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mem_critical_pressure_counter
    }

    fn mut_mem_critical_pressure_counter_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mem_critical_pressure_counter
    }

    // optional uint64 disk_limit_bytes = 26;

    pub fn clear_disk_limit_bytes(&mut self) {
        self.disk_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_disk_limit_bytes(&self) -> bool {
        self.disk_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk_limit_bytes(&mut self, v: u64) {
        self.disk_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_disk_limit_bytes(&self) -> u64 {
        self.disk_limit_bytes.unwrap_or(0)
    }

    fn get_disk_limit_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.disk_limit_bytes
    }

    fn mut_disk_limit_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.disk_limit_bytes
    }

    // optional uint64 disk_used_bytes = 27;

    pub fn clear_disk_used_bytes(&mut self) {
        self.disk_used_bytes = ::std::option::Option::None;
    }

    pub fn has_disk_used_bytes(&self) -> bool {
        self.disk_used_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk_used_bytes(&mut self, v: u64) {
        self.disk_used_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_disk_used_bytes(&self) -> u64 {
        self.disk_used_bytes.unwrap_or(0)
    }

    fn get_disk_used_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.disk_used_bytes
    }

    fn mut_disk_used_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.disk_used_bytes
    }

    // repeated .mesos.v1.DiskStatistics disk_statistics = 43;

    pub fn clear_disk_statistics(&mut self) {
        self.disk_statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_disk_statistics(&mut self, v: ::protobuf::RepeatedField<DiskStatistics>) {
        self.disk_statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_disk_statistics(&mut self) -> &mut ::protobuf::RepeatedField<DiskStatistics> {
        &mut self.disk_statistics
    }

    // Take field
    pub fn take_disk_statistics(&mut self) -> ::protobuf::RepeatedField<DiskStatistics> {
        ::std::mem::replace(&mut self.disk_statistics, ::protobuf::RepeatedField::new())
    }

    pub fn get_disk_statistics(&self) -> &[DiskStatistics] {
        &self.disk_statistics
    }

    fn get_disk_statistics_for_reflect(&self) -> &::protobuf::RepeatedField<DiskStatistics> {
        &self.disk_statistics
    }

    fn mut_disk_statistics_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DiskStatistics> {
        &mut self.disk_statistics
    }

    // optional .mesos.v1.CgroupInfo.Blkio.Statistics blkio_statistics = 44;

    pub fn clear_blkio_statistics(&mut self) {
        self.blkio_statistics.clear();
    }

    pub fn has_blkio_statistics(&self) -> bool {
        self.blkio_statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkio_statistics(&mut self, v: CgroupInfo_Blkio_Statistics) {
        self.blkio_statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkio_statistics(&mut self) -> &mut CgroupInfo_Blkio_Statistics {
        if self.blkio_statistics.is_none() {
            self.blkio_statistics.set_default();
        }
        self.blkio_statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkio_statistics(&mut self) -> CgroupInfo_Blkio_Statistics {
        self.blkio_statistics.take().unwrap_or_else(|| CgroupInfo_Blkio_Statistics::new())
    }

    pub fn get_blkio_statistics(&self) -> &CgroupInfo_Blkio_Statistics {
        self.blkio_statistics.as_ref().unwrap_or_else(|| CgroupInfo_Blkio_Statistics::default_instance())
    }

    fn get_blkio_statistics_for_reflect(&self) -> &::protobuf::SingularPtrField<CgroupInfo_Blkio_Statistics> {
        &self.blkio_statistics
    }

    fn mut_blkio_statistics_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CgroupInfo_Blkio_Statistics> {
        &mut self.blkio_statistics
    }

    // optional .mesos.v1.PerfStatistics perf = 13;

    pub fn clear_perf(&mut self) {
        self.perf.clear();
    }

    pub fn has_perf(&self) -> bool {
        self.perf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf(&mut self, v: PerfStatistics) {
        self.perf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perf(&mut self) -> &mut PerfStatistics {
        if self.perf.is_none() {
            self.perf.set_default();
        }
        self.perf.as_mut().unwrap()
    }

    // Take field
    pub fn take_perf(&mut self) -> PerfStatistics {
        self.perf.take().unwrap_or_else(|| PerfStatistics::new())
    }

    pub fn get_perf(&self) -> &PerfStatistics {
        self.perf.as_ref().unwrap_or_else(|| PerfStatistics::default_instance())
    }

    fn get_perf_for_reflect(&self) -> &::protobuf::SingularPtrField<PerfStatistics> {
        &self.perf
    }

    fn mut_perf_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PerfStatistics> {
        &mut self.perf
    }

    // optional uint64 net_rx_packets = 14;

    pub fn clear_net_rx_packets(&mut self) {
        self.net_rx_packets = ::std::option::Option::None;
    }

    pub fn has_net_rx_packets(&self) -> bool {
        self.net_rx_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_packets(&mut self, v: u64) {
        self.net_rx_packets = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_packets(&self) -> u64 {
        self.net_rx_packets.unwrap_or(0)
    }

    fn get_net_rx_packets_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_rx_packets
    }

    fn mut_net_rx_packets_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_rx_packets
    }

    // optional uint64 net_rx_bytes = 15;

    pub fn clear_net_rx_bytes(&mut self) {
        self.net_rx_bytes = ::std::option::Option::None;
    }

    pub fn has_net_rx_bytes(&self) -> bool {
        self.net_rx_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_bytes(&mut self, v: u64) {
        self.net_rx_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_bytes(&self) -> u64 {
        self.net_rx_bytes.unwrap_or(0)
    }

    fn get_net_rx_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_rx_bytes
    }

    fn mut_net_rx_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_rx_bytes
    }

    // optional uint64 net_rx_errors = 16;

    pub fn clear_net_rx_errors(&mut self) {
        self.net_rx_errors = ::std::option::Option::None;
    }

    pub fn has_net_rx_errors(&self) -> bool {
        self.net_rx_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_errors(&mut self, v: u64) {
        self.net_rx_errors = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_errors(&self) -> u64 {
        self.net_rx_errors.unwrap_or(0)
    }

    fn get_net_rx_errors_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_rx_errors
    }

    fn mut_net_rx_errors_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_rx_errors
    }

    // optional uint64 net_rx_dropped = 17;

    pub fn clear_net_rx_dropped(&mut self) {
        self.net_rx_dropped = ::std::option::Option::None;
    }

    pub fn has_net_rx_dropped(&self) -> bool {
        self.net_rx_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_dropped(&mut self, v: u64) {
        self.net_rx_dropped = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_dropped(&self) -> u64 {
        self.net_rx_dropped.unwrap_or(0)
    }

    fn get_net_rx_dropped_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_rx_dropped
    }

    fn mut_net_rx_dropped_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_rx_dropped
    }

    // optional uint64 net_tx_packets = 18;

    pub fn clear_net_tx_packets(&mut self) {
        self.net_tx_packets = ::std::option::Option::None;
    }

    pub fn has_net_tx_packets(&self) -> bool {
        self.net_tx_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_packets(&mut self, v: u64) {
        self.net_tx_packets = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_packets(&self) -> u64 {
        self.net_tx_packets.unwrap_or(0)
    }

    fn get_net_tx_packets_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_tx_packets
    }

    fn mut_net_tx_packets_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_tx_packets
    }

    // optional uint64 net_tx_bytes = 19;

    pub fn clear_net_tx_bytes(&mut self) {
        self.net_tx_bytes = ::std::option::Option::None;
    }

    pub fn has_net_tx_bytes(&self) -> bool {
        self.net_tx_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_bytes(&mut self, v: u64) {
        self.net_tx_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_bytes(&self) -> u64 {
        self.net_tx_bytes.unwrap_or(0)
    }

    fn get_net_tx_bytes_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_tx_bytes
    }

    fn mut_net_tx_bytes_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_tx_bytes
    }

    // optional uint64 net_tx_errors = 20;

    pub fn clear_net_tx_errors(&mut self) {
        self.net_tx_errors = ::std::option::Option::None;
    }

    pub fn has_net_tx_errors(&self) -> bool {
        self.net_tx_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_errors(&mut self, v: u64) {
        self.net_tx_errors = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_errors(&self) -> u64 {
        self.net_tx_errors.unwrap_or(0)
    }

    fn get_net_tx_errors_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_tx_errors
    }

    fn mut_net_tx_errors_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_tx_errors
    }

    // optional uint64 net_tx_dropped = 21;

    pub fn clear_net_tx_dropped(&mut self) {
        self.net_tx_dropped = ::std::option::Option::None;
    }

    pub fn has_net_tx_dropped(&self) -> bool {
        self.net_tx_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_dropped(&mut self, v: u64) {
        self.net_tx_dropped = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_dropped(&self) -> u64 {
        self.net_tx_dropped.unwrap_or(0)
    }

    fn get_net_tx_dropped_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.net_tx_dropped
    }

    fn mut_net_tx_dropped_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.net_tx_dropped
    }

    // optional double net_tcp_rtt_microsecs_p50 = 22;

    pub fn clear_net_tcp_rtt_microsecs_p50(&mut self) {
        self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p50(&self) -> bool {
        self.net_tcp_rtt_microsecs_p50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p50(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p50(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p50.unwrap_or(0.)
    }

    fn get_net_tcp_rtt_microsecs_p50_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.net_tcp_rtt_microsecs_p50
    }

    fn mut_net_tcp_rtt_microsecs_p50_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.net_tcp_rtt_microsecs_p50
    }

    // optional double net_tcp_rtt_microsecs_p90 = 23;

    pub fn clear_net_tcp_rtt_microsecs_p90(&mut self) {
        self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p90(&self) -> bool {
        self.net_tcp_rtt_microsecs_p90.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p90(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p90(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p90.unwrap_or(0.)
    }

    fn get_net_tcp_rtt_microsecs_p90_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.net_tcp_rtt_microsecs_p90
    }

    fn mut_net_tcp_rtt_microsecs_p90_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.net_tcp_rtt_microsecs_p90
    }

    // optional double net_tcp_rtt_microsecs_p95 = 24;

    pub fn clear_net_tcp_rtt_microsecs_p95(&mut self) {
        self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p95(&self) -> bool {
        self.net_tcp_rtt_microsecs_p95.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p95(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p95(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p95.unwrap_or(0.)
    }

    fn get_net_tcp_rtt_microsecs_p95_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.net_tcp_rtt_microsecs_p95
    }

    fn mut_net_tcp_rtt_microsecs_p95_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.net_tcp_rtt_microsecs_p95
    }

    // optional double net_tcp_rtt_microsecs_p99 = 25;

    pub fn clear_net_tcp_rtt_microsecs_p99(&mut self) {
        self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p99(&self) -> bool {
        self.net_tcp_rtt_microsecs_p99.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p99(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p99(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p99.unwrap_or(0.)
    }

    fn get_net_tcp_rtt_microsecs_p99_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.net_tcp_rtt_microsecs_p99
    }

    fn mut_net_tcp_rtt_microsecs_p99_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.net_tcp_rtt_microsecs_p99
    }

    // optional double net_tcp_active_connections = 28;

    pub fn clear_net_tcp_active_connections(&mut self) {
        self.net_tcp_active_connections = ::std::option::Option::None;
    }

    pub fn has_net_tcp_active_connections(&self) -> bool {
        self.net_tcp_active_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_active_connections(&mut self, v: f64) {
        self.net_tcp_active_connections = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_active_connections(&self) -> f64 {
        self.net_tcp_active_connections.unwrap_or(0.)
    }

    fn get_net_tcp_active_connections_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.net_tcp_active_connections
    }

    fn mut_net_tcp_active_connections_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.net_tcp_active_connections
    }

    // optional double net_tcp_time_wait_connections = 29;

    pub fn clear_net_tcp_time_wait_connections(&mut self) {
        self.net_tcp_time_wait_connections = ::std::option::Option::None;
    }

    pub fn has_net_tcp_time_wait_connections(&self) -> bool {
        self.net_tcp_time_wait_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_time_wait_connections(&mut self, v: f64) {
        self.net_tcp_time_wait_connections = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_time_wait_connections(&self) -> f64 {
        self.net_tcp_time_wait_connections.unwrap_or(0.)
    }

    fn get_net_tcp_time_wait_connections_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.net_tcp_time_wait_connections
    }

    fn mut_net_tcp_time_wait_connections_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.net_tcp_time_wait_connections
    }

    // repeated .mesos.v1.TrafficControlStatistics net_traffic_control_statistics = 35;

    pub fn clear_net_traffic_control_statistics(&mut self) {
        self.net_traffic_control_statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_net_traffic_control_statistics(&mut self, v: ::protobuf::RepeatedField<TrafficControlStatistics>) {
        self.net_traffic_control_statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_net_traffic_control_statistics(&mut self) -> &mut ::protobuf::RepeatedField<TrafficControlStatistics> {
        &mut self.net_traffic_control_statistics
    }

    // Take field
    pub fn take_net_traffic_control_statistics(&mut self) -> ::protobuf::RepeatedField<TrafficControlStatistics> {
        ::std::mem::replace(&mut self.net_traffic_control_statistics, ::protobuf::RepeatedField::new())
    }

    pub fn get_net_traffic_control_statistics(&self) -> &[TrafficControlStatistics] {
        &self.net_traffic_control_statistics
    }

    fn get_net_traffic_control_statistics_for_reflect(&self) -> &::protobuf::RepeatedField<TrafficControlStatistics> {
        &self.net_traffic_control_statistics
    }

    fn mut_net_traffic_control_statistics_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TrafficControlStatistics> {
        &mut self.net_traffic_control_statistics
    }

    // optional .mesos.v1.SNMPStatistics net_snmp_statistics = 42;

    pub fn clear_net_snmp_statistics(&mut self) {
        self.net_snmp_statistics.clear();
    }

    pub fn has_net_snmp_statistics(&self) -> bool {
        self.net_snmp_statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_snmp_statistics(&mut self, v: SNMPStatistics) {
        self.net_snmp_statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_snmp_statistics(&mut self) -> &mut SNMPStatistics {
        if self.net_snmp_statistics.is_none() {
            self.net_snmp_statistics.set_default();
        }
        self.net_snmp_statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_snmp_statistics(&mut self) -> SNMPStatistics {
        self.net_snmp_statistics.take().unwrap_or_else(|| SNMPStatistics::new())
    }

    pub fn get_net_snmp_statistics(&self) -> &SNMPStatistics {
        self.net_snmp_statistics.as_ref().unwrap_or_else(|| SNMPStatistics::default_instance())
    }

    fn get_net_snmp_statistics_for_reflect(&self) -> &::protobuf::SingularPtrField<SNMPStatistics> {
        &self.net_snmp_statistics
    }

    fn mut_net_snmp_statistics_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SNMPStatistics> {
        &mut self.net_snmp_statistics
    }
}

impl ::protobuf::Message for ResourceStatistics {
    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        }
        for v in &self.disk_statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blkio_statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.net_traffic_control_statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.net_snmp_statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.processes = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.threads = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpus_user_time_secs = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpus_system_time_secs = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpus_limit = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cpus_nr_periods = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cpus_nr_throttled = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpus_throttled_time_secs = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_total_bytes = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_total_memsw_bytes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_limit_bytes = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_soft_limit_bytes = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_file_bytes = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_anon_bytes = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_cache_bytes = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_rss_bytes = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_mapped_file_bytes = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_swap_bytes = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_unevictable_bytes = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_low_pressure_counter = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_medium_pressure_counter = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_critical_pressure_counter = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.disk_limit_bytes = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.disk_used_bytes = ::std::option::Option::Some(tmp);
                },
                43 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.disk_statistics)?;
                },
                44 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkio_statistics)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.perf)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_rx_packets = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_rx_bytes = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_rx_errors = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_rx_dropped = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_tx_packets = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_tx_bytes = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_tx_errors = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.net_tx_dropped = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.net_tcp_active_connections = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.net_tcp_time_wait_connections = ::std::option::Option::Some(tmp);
                },
                35 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.net_traffic_control_statistics)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.net_snmp_statistics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += 9;
        }
        if let Some(v) = self.processes {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.threads {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cpus_user_time_secs {
            my_size += 9;
        }
        if let Some(v) = self.cpus_system_time_secs {
            my_size += 9;
        }
        if let Some(v) = self.cpus_limit {
            my_size += 9;
        }
        if let Some(v) = self.cpus_nr_periods {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cpus_nr_throttled {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cpus_throttled_time_secs {
            my_size += 9;
        }
        if let Some(v) = self.mem_total_bytes {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_total_memsw_bytes {
            my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_limit_bytes {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_soft_limit_bytes {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_file_bytes {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_anon_bytes {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_cache_bytes {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_rss_bytes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_mapped_file_bytes {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_swap_bytes {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_unevictable_bytes {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_low_pressure_counter {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_medium_pressure_counter {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_critical_pressure_counter {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.disk_limit_bytes {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.disk_used_bytes {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.disk_statistics {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.blkio_statistics.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.perf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.net_rx_packets {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_rx_bytes {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_rx_errors {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_rx_dropped {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_tx_packets {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_tx_bytes {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_tx_errors {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_tx_dropped {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p50 {
            my_size += 10;
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p90 {
            my_size += 10;
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p95 {
            my_size += 10;
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p99 {
            my_size += 10;
        }
        if let Some(v) = self.net_tcp_active_connections {
            my_size += 10;
        }
        if let Some(v) = self.net_tcp_time_wait_connections {
            my_size += 10;
        }
        for value in &self.net_traffic_control_statistics {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.net_snmp_statistics.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.processes {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.threads {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.cpus_user_time_secs {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.cpus_system_time_secs {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.cpus_limit {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.cpus_nr_periods {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.cpus_nr_throttled {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.cpus_throttled_time_secs {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.mem_total_bytes {
            os.write_uint64(36, v)?;
        }
        if let Some(v) = self.mem_total_memsw_bytes {
            os.write_uint64(37, v)?;
        }
        if let Some(v) = self.mem_limit_bytes {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.mem_soft_limit_bytes {
            os.write_uint64(38, v)?;
        }
        if let Some(v) = self.mem_file_bytes {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.mem_anon_bytes {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.mem_cache_bytes {
            os.write_uint64(39, v)?;
        }
        if let Some(v) = self.mem_rss_bytes {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.mem_mapped_file_bytes {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.mem_swap_bytes {
            os.write_uint64(40, v)?;
        }
        if let Some(v) = self.mem_unevictable_bytes {
            os.write_uint64(41, v)?;
        }
        if let Some(v) = self.mem_low_pressure_counter {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.mem_medium_pressure_counter {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.mem_critical_pressure_counter {
            os.write_uint64(34, v)?;
        }
        if let Some(v) = self.disk_limit_bytes {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.disk_used_bytes {
            os.write_uint64(27, v)?;
        }
        for v in &self.disk_statistics {
            os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.blkio_statistics.as_ref() {
            os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.perf.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.net_rx_packets {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.net_rx_bytes {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.net_rx_errors {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.net_rx_dropped {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.net_tx_packets {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.net_tx_bytes {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.net_tx_errors {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.net_tx_dropped {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p50 {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p90 {
            os.write_double(23, v)?;
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p95 {
            os.write_double(24, v)?;
        }
        if let Some(v) = self.net_tcp_rtt_microsecs_p99 {
            os.write_double(25, v)?;
        }
        if let Some(v) = self.net_tcp_active_connections {
            os.write_double(28, v)?;
        }
        if let Some(v) = self.net_tcp_time_wait_connections {
            os.write_double(29, v)?;
        }
        for v in &self.net_traffic_control_statistics {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.net_snmp_statistics.as_ref() {
            os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceStatistics {
    fn new() -> ResourceStatistics {
        ResourceStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "timestamp",
                    ResourceStatistics::get_timestamp_for_reflect,
                    ResourceStatistics::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "processes",
                    ResourceStatistics::get_processes_for_reflect,
                    ResourceStatistics::mut_processes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "threads",
                    ResourceStatistics::get_threads_for_reflect,
                    ResourceStatistics::mut_threads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpus_user_time_secs",
                    ResourceStatistics::get_cpus_user_time_secs_for_reflect,
                    ResourceStatistics::mut_cpus_user_time_secs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpus_system_time_secs",
                    ResourceStatistics::get_cpus_system_time_secs_for_reflect,
                    ResourceStatistics::mut_cpus_system_time_secs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpus_limit",
                    ResourceStatistics::get_cpus_limit_for_reflect,
                    ResourceStatistics::mut_cpus_limit_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cpus_nr_periods",
                    ResourceStatistics::get_cpus_nr_periods_for_reflect,
                    ResourceStatistics::mut_cpus_nr_periods_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cpus_nr_throttled",
                    ResourceStatistics::get_cpus_nr_throttled_for_reflect,
                    ResourceStatistics::mut_cpus_nr_throttled_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpus_throttled_time_secs",
                    ResourceStatistics::get_cpus_throttled_time_secs_for_reflect,
                    ResourceStatistics::mut_cpus_throttled_time_secs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_total_bytes",
                    ResourceStatistics::get_mem_total_bytes_for_reflect,
                    ResourceStatistics::mut_mem_total_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_total_memsw_bytes",
                    ResourceStatistics::get_mem_total_memsw_bytes_for_reflect,
                    ResourceStatistics::mut_mem_total_memsw_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_limit_bytes",
                    ResourceStatistics::get_mem_limit_bytes_for_reflect,
                    ResourceStatistics::mut_mem_limit_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_soft_limit_bytes",
                    ResourceStatistics::get_mem_soft_limit_bytes_for_reflect,
                    ResourceStatistics::mut_mem_soft_limit_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_file_bytes",
                    ResourceStatistics::get_mem_file_bytes_for_reflect,
                    ResourceStatistics::mut_mem_file_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_anon_bytes",
                    ResourceStatistics::get_mem_anon_bytes_for_reflect,
                    ResourceStatistics::mut_mem_anon_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_cache_bytes",
                    ResourceStatistics::get_mem_cache_bytes_for_reflect,
                    ResourceStatistics::mut_mem_cache_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_rss_bytes",
                    ResourceStatistics::get_mem_rss_bytes_for_reflect,
                    ResourceStatistics::mut_mem_rss_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_mapped_file_bytes",
                    ResourceStatistics::get_mem_mapped_file_bytes_for_reflect,
                    ResourceStatistics::mut_mem_mapped_file_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_swap_bytes",
                    ResourceStatistics::get_mem_swap_bytes_for_reflect,
                    ResourceStatistics::mut_mem_swap_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_unevictable_bytes",
                    ResourceStatistics::get_mem_unevictable_bytes_for_reflect,
                    ResourceStatistics::mut_mem_unevictable_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_low_pressure_counter",
                    ResourceStatistics::get_mem_low_pressure_counter_for_reflect,
                    ResourceStatistics::mut_mem_low_pressure_counter_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_medium_pressure_counter",
                    ResourceStatistics::get_mem_medium_pressure_counter_for_reflect,
                    ResourceStatistics::mut_mem_medium_pressure_counter_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_critical_pressure_counter",
                    ResourceStatistics::get_mem_critical_pressure_counter_for_reflect,
                    ResourceStatistics::mut_mem_critical_pressure_counter_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "disk_limit_bytes",
                    ResourceStatistics::get_disk_limit_bytes_for_reflect,
                    ResourceStatistics::mut_disk_limit_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "disk_used_bytes",
                    ResourceStatistics::get_disk_used_bytes_for_reflect,
                    ResourceStatistics::mut_disk_used_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiskStatistics>>(
                    "disk_statistics",
                    ResourceStatistics::get_disk_statistics_for_reflect,
                    ResourceStatistics::mut_disk_statistics_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Statistics>>(
                    "blkio_statistics",
                    ResourceStatistics::get_blkio_statistics_for_reflect,
                    ResourceStatistics::mut_blkio_statistics_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerfStatistics>>(
                    "perf",
                    ResourceStatistics::get_perf_for_reflect,
                    ResourceStatistics::mut_perf_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_rx_packets",
                    ResourceStatistics::get_net_rx_packets_for_reflect,
                    ResourceStatistics::mut_net_rx_packets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_rx_bytes",
                    ResourceStatistics::get_net_rx_bytes_for_reflect,
                    ResourceStatistics::mut_net_rx_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_rx_errors",
                    ResourceStatistics::get_net_rx_errors_for_reflect,
                    ResourceStatistics::mut_net_rx_errors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_rx_dropped",
                    ResourceStatistics::get_net_rx_dropped_for_reflect,
                    ResourceStatistics::mut_net_rx_dropped_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_tx_packets",
                    ResourceStatistics::get_net_tx_packets_for_reflect,
                    ResourceStatistics::mut_net_tx_packets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_tx_bytes",
                    ResourceStatistics::get_net_tx_bytes_for_reflect,
                    ResourceStatistics::mut_net_tx_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_tx_errors",
                    ResourceStatistics::get_net_tx_errors_for_reflect,
                    ResourceStatistics::mut_net_tx_errors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "net_tx_dropped",
                    ResourceStatistics::get_net_tx_dropped_for_reflect,
                    ResourceStatistics::mut_net_tx_dropped_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "net_tcp_rtt_microsecs_p50",
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p50_for_reflect,
                    ResourceStatistics::mut_net_tcp_rtt_microsecs_p50_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "net_tcp_rtt_microsecs_p90",
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p90_for_reflect,
                    ResourceStatistics::mut_net_tcp_rtt_microsecs_p90_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "net_tcp_rtt_microsecs_p95",
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p95_for_reflect,
                    ResourceStatistics::mut_net_tcp_rtt_microsecs_p95_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "net_tcp_rtt_microsecs_p99",
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p99_for_reflect,
                    ResourceStatistics::mut_net_tcp_rtt_microsecs_p99_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "net_tcp_active_connections",
                    ResourceStatistics::get_net_tcp_active_connections_for_reflect,
                    ResourceStatistics::mut_net_tcp_active_connections_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "net_tcp_time_wait_connections",
                    ResourceStatistics::get_net_tcp_time_wait_connections_for_reflect,
                    ResourceStatistics::mut_net_tcp_time_wait_connections_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrafficControlStatistics>>(
                    "net_traffic_control_statistics",
                    ResourceStatistics::get_net_traffic_control_statistics_for_reflect,
                    ResourceStatistics::mut_net_traffic_control_statistics_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SNMPStatistics>>(
                    "net_snmp_statistics",
                    ResourceStatistics::get_net_snmp_statistics_for_reflect,
                    ResourceStatistics::mut_net_snmp_statistics_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceStatistics>(
                    "ResourceStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceStatistics {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_processes();
        self.clear_threads();
        self.clear_cpus_user_time_secs();
        self.clear_cpus_system_time_secs();
        self.clear_cpus_limit();
        self.clear_cpus_nr_periods();
        self.clear_cpus_nr_throttled();
        self.clear_cpus_throttled_time_secs();
        self.clear_mem_total_bytes();
        self.clear_mem_total_memsw_bytes();
        self.clear_mem_limit_bytes();
        self.clear_mem_soft_limit_bytes();
        self.clear_mem_file_bytes();
        self.clear_mem_anon_bytes();
        self.clear_mem_cache_bytes();
        self.clear_mem_rss_bytes();
        self.clear_mem_mapped_file_bytes();
        self.clear_mem_swap_bytes();
        self.clear_mem_unevictable_bytes();
        self.clear_mem_low_pressure_counter();
        self.clear_mem_medium_pressure_counter();
        self.clear_mem_critical_pressure_counter();
        self.clear_disk_limit_bytes();
        self.clear_disk_used_bytes();
        self.clear_disk_statistics();
        self.clear_blkio_statistics();
        self.clear_perf();
        self.clear_net_rx_packets();
        self.clear_net_rx_bytes();
        self.clear_net_rx_errors();
        self.clear_net_rx_dropped();
        self.clear_net_tx_packets();
        self.clear_net_tx_bytes();
        self.clear_net_tx_errors();
        self.clear_net_tx_dropped();
        self.clear_net_tcp_rtt_microsecs_p50();
        self.clear_net_tcp_rtt_microsecs_p90();
        self.clear_net_tcp_rtt_microsecs_p95();
        self.clear_net_tcp_rtt_microsecs_p99();
        self.clear_net_tcp_active_connections();
        self.clear_net_tcp_time_wait_connections();
        self.clear_net_traffic_control_statistics();
        self.clear_net_snmp_statistics();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceUsage {
    // message fields
    executors: ::protobuf::RepeatedField<ResourceUsage_Executor>,
    total: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceUsage {}

impl ResourceUsage {
    pub fn new() -> ResourceUsage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceUsage {
        static mut instance: ::protobuf::lazy::Lazy<ResourceUsage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceUsage,
        };
        unsafe {
            instance.get(ResourceUsage::new)
        }
    }

    // repeated .mesos.v1.ResourceUsage.Executor executors = 1;

    pub fn clear_executors(&mut self) {
        self.executors.clear();
    }

    // Param is passed by value, moved
    pub fn set_executors(&mut self, v: ::protobuf::RepeatedField<ResourceUsage_Executor>) {
        self.executors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_executors(&mut self) -> &mut ::protobuf::RepeatedField<ResourceUsage_Executor> {
        &mut self.executors
    }

    // Take field
    pub fn take_executors(&mut self) -> ::protobuf::RepeatedField<ResourceUsage_Executor> {
        ::std::mem::replace(&mut self.executors, ::protobuf::RepeatedField::new())
    }

    pub fn get_executors(&self) -> &[ResourceUsage_Executor] {
        &self.executors
    }

    fn get_executors_for_reflect(&self) -> &::protobuf::RepeatedField<ResourceUsage_Executor> {
        &self.executors
    }

    fn mut_executors_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ResourceUsage_Executor> {
        &mut self.executors
    }

    // repeated .mesos.v1.Resource total = 2;

    pub fn clear_total(&mut self) {
        self.total.clear();
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_total(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.total
    }

    // Take field
    pub fn take_total(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.total, ::protobuf::RepeatedField::new())
    }

    pub fn get_total(&self) -> &[Resource] {
        &self.total
    }

    fn get_total_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.total
    }
}

impl ::protobuf::Message for ResourceUsage {
    fn is_initialized(&self) -> bool {
        for v in &self.executors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.total {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.executors)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.total)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.executors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.total {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.executors {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.total {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceUsage {
    fn new() -> ResourceUsage {
        ResourceUsage::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceUsage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceUsage_Executor>>(
                    "executors",
                    ResourceUsage::get_executors_for_reflect,
                    ResourceUsage::mut_executors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "total",
                    ResourceUsage::get_total_for_reflect,
                    ResourceUsage::mut_total_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceUsage>(
                    "ResourceUsage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceUsage {
    fn clear(&mut self) {
        self.clear_executors();
        self.clear_total();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceUsage_Executor {
    // message fields
    executor_info: ::protobuf::SingularPtrField<ExecutorInfo>,
    allocated: ::protobuf::RepeatedField<Resource>,
    statistics: ::protobuf::SingularPtrField<ResourceStatistics>,
    container_id: ::protobuf::SingularPtrField<ContainerID>,
    tasks: ::protobuf::RepeatedField<ResourceUsage_Executor_Task>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceUsage_Executor {}

impl ResourceUsage_Executor {
    pub fn new() -> ResourceUsage_Executor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceUsage_Executor {
        static mut instance: ::protobuf::lazy::Lazy<ResourceUsage_Executor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceUsage_Executor,
        };
        unsafe {
            instance.get(ResourceUsage_Executor::new)
        }
    }

    // required .mesos.v1.ExecutorInfo executor_info = 1;

    pub fn clear_executor_info(&mut self) {
        self.executor_info.clear();
    }

    pub fn has_executor_info(&self) -> bool {
        self.executor_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_info(&mut self, v: ExecutorInfo) {
        self.executor_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_info(&mut self) -> &mut ExecutorInfo {
        if self.executor_info.is_none() {
            self.executor_info.set_default();
        }
        self.executor_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_info(&mut self) -> ExecutorInfo {
        self.executor_info.take().unwrap_or_else(|| ExecutorInfo::new())
    }

    pub fn get_executor_info(&self) -> &ExecutorInfo {
        self.executor_info.as_ref().unwrap_or_else(|| ExecutorInfo::default_instance())
    }

    fn get_executor_info_for_reflect(&self) -> &::protobuf::SingularPtrField<ExecutorInfo> {
        &self.executor_info
    }

    fn mut_executor_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ExecutorInfo> {
        &mut self.executor_info
    }

    // repeated .mesos.v1.Resource allocated = 2;

    pub fn clear_allocated(&mut self) {
        self.allocated.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocated(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.allocated = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocated(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.allocated
    }

    // Take field
    pub fn take_allocated(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.allocated, ::protobuf::RepeatedField::new())
    }

    pub fn get_allocated(&self) -> &[Resource] {
        &self.allocated
    }

    fn get_allocated_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.allocated
    }

    fn mut_allocated_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.allocated
    }

    // optional .mesos.v1.ResourceStatistics statistics = 3;

    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    pub fn has_statistics(&self) -> bool {
        self.statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ResourceStatistics) {
        self.statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics(&mut self) -> &mut ResourceStatistics {
        if self.statistics.is_none() {
            self.statistics.set_default();
        }
        self.statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics(&mut self) -> ResourceStatistics {
        self.statistics.take().unwrap_or_else(|| ResourceStatistics::new())
    }

    pub fn get_statistics(&self) -> &ResourceStatistics {
        self.statistics.as_ref().unwrap_or_else(|| ResourceStatistics::default_instance())
    }

    fn get_statistics_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceStatistics> {
        &self.statistics
    }

    fn mut_statistics_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceStatistics> {
        &mut self.statistics
    }

    // required .mesos.v1.ContainerID container_id = 4;

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    pub fn has_container_id(&self) -> bool {
        self.container_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ContainerID) {
        self.container_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ContainerID {
        if self.container_id.is_none() {
            self.container_id.set_default();
        }
        self.container_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_id(&mut self) -> ContainerID {
        self.container_id.take().unwrap_or_else(|| ContainerID::new())
    }

    pub fn get_container_id(&self) -> &ContainerID {
        self.container_id.as_ref().unwrap_or_else(|| ContainerID::default_instance())
    }

    fn get_container_id_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerID> {
        &self.container_id
    }

    fn mut_container_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerID> {
        &mut self.container_id
    }

    // repeated .mesos.v1.ResourceUsage.Executor.Task tasks = 5;

    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<ResourceUsage_Executor_Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<ResourceUsage_Executor_Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<ResourceUsage_Executor_Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }

    pub fn get_tasks(&self) -> &[ResourceUsage_Executor_Task] {
        &self.tasks
    }

    fn get_tasks_for_reflect(&self) -> &::protobuf::RepeatedField<ResourceUsage_Executor_Task> {
        &self.tasks
    }

    fn mut_tasks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ResourceUsage_Executor_Task> {
        &mut self.tasks
    }
}

impl ::protobuf::Message for ResourceUsage_Executor {
    fn is_initialized(&self) -> bool {
        if self.executor_info.is_none() {
            return false;
        }
        if self.container_id.is_none() {
            return false;
        }
        for v in &self.executor_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allocated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.container_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allocated)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statistics)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container_id)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.executor_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.allocated {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.statistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.container_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.executor_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.allocated {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.statistics.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.container_id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tasks {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceUsage_Executor {
    fn new() -> ResourceUsage_Executor {
        ResourceUsage_Executor::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceUsage_Executor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorInfo>>(
                    "executor_info",
                    ResourceUsage_Executor::get_executor_info_for_reflect,
                    ResourceUsage_Executor::mut_executor_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "allocated",
                    ResourceUsage_Executor::get_allocated_for_reflect,
                    ResourceUsage_Executor::mut_allocated_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceStatistics>>(
                    "statistics",
                    ResourceUsage_Executor::get_statistics_for_reflect,
                    ResourceUsage_Executor::mut_statistics_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerID>>(
                    "container_id",
                    ResourceUsage_Executor::get_container_id_for_reflect,
                    ResourceUsage_Executor::mut_container_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceUsage_Executor_Task>>(
                    "tasks",
                    ResourceUsage_Executor::get_tasks_for_reflect,
                    ResourceUsage_Executor::mut_tasks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceUsage_Executor>(
                    "ResourceUsage_Executor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceUsage_Executor {
    fn clear(&mut self) {
        self.clear_executor_info();
        self.clear_allocated();
        self.clear_statistics();
        self.clear_container_id();
        self.clear_tasks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceUsage_Executor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceUsage_Executor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceUsage_Executor_Task {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularPtrField<TaskID>,
    resources: ::protobuf::RepeatedField<Resource>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceUsage_Executor_Task {}

impl ResourceUsage_Executor_Task {
    pub fn new() -> ResourceUsage_Executor_Task {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceUsage_Executor_Task {
        static mut instance: ::protobuf::lazy::Lazy<ResourceUsage_Executor_Task> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceUsage_Executor_Task,
        };
        unsafe {
            instance.get(ResourceUsage_Executor_Task::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required .mesos.v1.TaskID id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: TaskID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut TaskID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> TaskID {
        self.id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_id(&self) -> &TaskID {
        self.id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<TaskID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TaskID> {
        &mut self.id
    }

    // repeated .mesos.v1.Resource resources = 3;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // optional .mesos.v1.Labels labels = 4;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }
}

impl ::protobuf::Message for ResourceUsage_Executor_Task {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resources {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceUsage_Executor_Task {
    fn new() -> ResourceUsage_Executor_Task {
        ResourceUsage_Executor_Task::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceUsage_Executor_Task>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ResourceUsage_Executor_Task::get_name_for_reflect,
                    ResourceUsage_Executor_Task::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskID>>(
                    "id",
                    ResourceUsage_Executor_Task::get_id_for_reflect,
                    ResourceUsage_Executor_Task::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    ResourceUsage_Executor_Task::get_resources_for_reflect,
                    ResourceUsage_Executor_Task::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    ResourceUsage_Executor_Task::get_labels_for_reflect,
                    ResourceUsage_Executor_Task::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceUsage_Executor_Task>(
                    "ResourceUsage_Executor_Task",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceUsage_Executor_Task {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_id();
        self.clear_resources();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceUsage_Executor_Task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceUsage_Executor_Task {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PerfStatistics {
    // message fields
    timestamp: ::std::option::Option<f64>,
    duration: ::std::option::Option<f64>,
    cycles: ::std::option::Option<u64>,
    stalled_cycles_frontend: ::std::option::Option<u64>,
    stalled_cycles_backend: ::std::option::Option<u64>,
    instructions: ::std::option::Option<u64>,
    cache_references: ::std::option::Option<u64>,
    cache_misses: ::std::option::Option<u64>,
    branches: ::std::option::Option<u64>,
    branch_misses: ::std::option::Option<u64>,
    bus_cycles: ::std::option::Option<u64>,
    ref_cycles: ::std::option::Option<u64>,
    cpu_clock: ::std::option::Option<f64>,
    task_clock: ::std::option::Option<f64>,
    page_faults: ::std::option::Option<u64>,
    minor_faults: ::std::option::Option<u64>,
    major_faults: ::std::option::Option<u64>,
    context_switches: ::std::option::Option<u64>,
    cpu_migrations: ::std::option::Option<u64>,
    alignment_faults: ::std::option::Option<u64>,
    emulation_faults: ::std::option::Option<u64>,
    l1_dcache_loads: ::std::option::Option<u64>,
    l1_dcache_load_misses: ::std::option::Option<u64>,
    l1_dcache_stores: ::std::option::Option<u64>,
    l1_dcache_store_misses: ::std::option::Option<u64>,
    l1_dcache_prefetches: ::std::option::Option<u64>,
    l1_dcache_prefetch_misses: ::std::option::Option<u64>,
    l1_icache_loads: ::std::option::Option<u64>,
    l1_icache_load_misses: ::std::option::Option<u64>,
    l1_icache_prefetches: ::std::option::Option<u64>,
    l1_icache_prefetch_misses: ::std::option::Option<u64>,
    llc_loads: ::std::option::Option<u64>,
    llc_load_misses: ::std::option::Option<u64>,
    llc_stores: ::std::option::Option<u64>,
    llc_store_misses: ::std::option::Option<u64>,
    llc_prefetches: ::std::option::Option<u64>,
    llc_prefetch_misses: ::std::option::Option<u64>,
    dtlb_loads: ::std::option::Option<u64>,
    dtlb_load_misses: ::std::option::Option<u64>,
    dtlb_stores: ::std::option::Option<u64>,
    dtlb_store_misses: ::std::option::Option<u64>,
    dtlb_prefetches: ::std::option::Option<u64>,
    dtlb_prefetch_misses: ::std::option::Option<u64>,
    itlb_loads: ::std::option::Option<u64>,
    itlb_load_misses: ::std::option::Option<u64>,
    branch_loads: ::std::option::Option<u64>,
    branch_load_misses: ::std::option::Option<u64>,
    node_loads: ::std::option::Option<u64>,
    node_load_misses: ::std::option::Option<u64>,
    node_stores: ::std::option::Option<u64>,
    node_store_misses: ::std::option::Option<u64>,
    node_prefetches: ::std::option::Option<u64>,
    node_prefetch_misses: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PerfStatistics {}

impl PerfStatistics {
    pub fn new() -> PerfStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PerfStatistics {
        static mut instance: ::protobuf::lazy::Lazy<PerfStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PerfStatistics,
        };
        unsafe {
            instance.get(PerfStatistics::new)
        }
    }

    // required double timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.timestamp
    }

    // required double duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f64) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> f64 {
        self.duration.unwrap_or(0.)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.duration
    }

    // optional uint64 cycles = 3;

    pub fn clear_cycles(&mut self) {
        self.cycles = ::std::option::Option::None;
    }

    pub fn has_cycles(&self) -> bool {
        self.cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycles(&mut self, v: u64) {
        self.cycles = ::std::option::Option::Some(v);
    }

    pub fn get_cycles(&self) -> u64 {
        self.cycles.unwrap_or(0)
    }

    fn get_cycles_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cycles
    }

    fn mut_cycles_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cycles
    }

    // optional uint64 stalled_cycles_frontend = 4;

    pub fn clear_stalled_cycles_frontend(&mut self) {
        self.stalled_cycles_frontend = ::std::option::Option::None;
    }

    pub fn has_stalled_cycles_frontend(&self) -> bool {
        self.stalled_cycles_frontend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stalled_cycles_frontend(&mut self, v: u64) {
        self.stalled_cycles_frontend = ::std::option::Option::Some(v);
    }

    pub fn get_stalled_cycles_frontend(&self) -> u64 {
        self.stalled_cycles_frontend.unwrap_or(0)
    }

    fn get_stalled_cycles_frontend_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.stalled_cycles_frontend
    }

    fn mut_stalled_cycles_frontend_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.stalled_cycles_frontend
    }

    // optional uint64 stalled_cycles_backend = 5;

    pub fn clear_stalled_cycles_backend(&mut self) {
        self.stalled_cycles_backend = ::std::option::Option::None;
    }

    pub fn has_stalled_cycles_backend(&self) -> bool {
        self.stalled_cycles_backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stalled_cycles_backend(&mut self, v: u64) {
        self.stalled_cycles_backend = ::std::option::Option::Some(v);
    }

    pub fn get_stalled_cycles_backend(&self) -> u64 {
        self.stalled_cycles_backend.unwrap_or(0)
    }

    fn get_stalled_cycles_backend_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.stalled_cycles_backend
    }

    fn mut_stalled_cycles_backend_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.stalled_cycles_backend
    }

    // optional uint64 instructions = 6;

    pub fn clear_instructions(&mut self) {
        self.instructions = ::std::option::Option::None;
    }

    pub fn has_instructions(&self) -> bool {
        self.instructions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instructions(&mut self, v: u64) {
        self.instructions = ::std::option::Option::Some(v);
    }

    pub fn get_instructions(&self) -> u64 {
        self.instructions.unwrap_or(0)
    }

    fn get_instructions_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.instructions
    }

    fn mut_instructions_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.instructions
    }

    // optional uint64 cache_references = 7;

    pub fn clear_cache_references(&mut self) {
        self.cache_references = ::std::option::Option::None;
    }

    pub fn has_cache_references(&self) -> bool {
        self.cache_references.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_references(&mut self, v: u64) {
        self.cache_references = ::std::option::Option::Some(v);
    }

    pub fn get_cache_references(&self) -> u64 {
        self.cache_references.unwrap_or(0)
    }

    fn get_cache_references_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cache_references
    }

    fn mut_cache_references_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cache_references
    }

    // optional uint64 cache_misses = 8;

    pub fn clear_cache_misses(&mut self) {
        self.cache_misses = ::std::option::Option::None;
    }

    pub fn has_cache_misses(&self) -> bool {
        self.cache_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_misses(&mut self, v: u64) {
        self.cache_misses = ::std::option::Option::Some(v);
    }

    pub fn get_cache_misses(&self) -> u64 {
        self.cache_misses.unwrap_or(0)
    }

    fn get_cache_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cache_misses
    }

    fn mut_cache_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cache_misses
    }

    // optional uint64 branches = 9;

    pub fn clear_branches(&mut self) {
        self.branches = ::std::option::Option::None;
    }

    pub fn has_branches(&self) -> bool {
        self.branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branches(&mut self, v: u64) {
        self.branches = ::std::option::Option::Some(v);
    }

    pub fn get_branches(&self) -> u64 {
        self.branches.unwrap_or(0)
    }

    fn get_branches_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.branches
    }

    fn mut_branches_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.branches
    }

    // optional uint64 branch_misses = 10;

    pub fn clear_branch_misses(&mut self) {
        self.branch_misses = ::std::option::Option::None;
    }

    pub fn has_branch_misses(&self) -> bool {
        self.branch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_misses(&mut self, v: u64) {
        self.branch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_branch_misses(&self) -> u64 {
        self.branch_misses.unwrap_or(0)
    }

    fn get_branch_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.branch_misses
    }

    fn mut_branch_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.branch_misses
    }

    // optional uint64 bus_cycles = 11;

    pub fn clear_bus_cycles(&mut self) {
        self.bus_cycles = ::std::option::Option::None;
    }

    pub fn has_bus_cycles(&self) -> bool {
        self.bus_cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bus_cycles(&mut self, v: u64) {
        self.bus_cycles = ::std::option::Option::Some(v);
    }

    pub fn get_bus_cycles(&self) -> u64 {
        self.bus_cycles.unwrap_or(0)
    }

    fn get_bus_cycles_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.bus_cycles
    }

    fn mut_bus_cycles_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.bus_cycles
    }

    // optional uint64 ref_cycles = 12;

    pub fn clear_ref_cycles(&mut self) {
        self.ref_cycles = ::std::option::Option::None;
    }

    pub fn has_ref_cycles(&self) -> bool {
        self.ref_cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref_cycles(&mut self, v: u64) {
        self.ref_cycles = ::std::option::Option::Some(v);
    }

    pub fn get_ref_cycles(&self) -> u64 {
        self.ref_cycles.unwrap_or(0)
    }

    fn get_ref_cycles_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ref_cycles
    }

    fn mut_ref_cycles_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ref_cycles
    }

    // optional double cpu_clock = 13;

    pub fn clear_cpu_clock(&mut self) {
        self.cpu_clock = ::std::option::Option::None;
    }

    pub fn has_cpu_clock(&self) -> bool {
        self.cpu_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_clock(&mut self, v: f64) {
        self.cpu_clock = ::std::option::Option::Some(v);
    }

    pub fn get_cpu_clock(&self) -> f64 {
        self.cpu_clock.unwrap_or(0.)
    }

    fn get_cpu_clock_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.cpu_clock
    }

    fn mut_cpu_clock_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.cpu_clock
    }

    // optional double task_clock = 14;

    pub fn clear_task_clock(&mut self) {
        self.task_clock = ::std::option::Option::None;
    }

    pub fn has_task_clock(&self) -> bool {
        self.task_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_clock(&mut self, v: f64) {
        self.task_clock = ::std::option::Option::Some(v);
    }

    pub fn get_task_clock(&self) -> f64 {
        self.task_clock.unwrap_or(0.)
    }

    fn get_task_clock_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.task_clock
    }

    fn mut_task_clock_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.task_clock
    }

    // optional uint64 page_faults = 15;

    pub fn clear_page_faults(&mut self) {
        self.page_faults = ::std::option::Option::None;
    }

    pub fn has_page_faults(&self) -> bool {
        self.page_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_faults(&mut self, v: u64) {
        self.page_faults = ::std::option::Option::Some(v);
    }

    pub fn get_page_faults(&self) -> u64 {
        self.page_faults.unwrap_or(0)
    }

    fn get_page_faults_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.page_faults
    }

    fn mut_page_faults_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.page_faults
    }

    // optional uint64 minor_faults = 16;

    pub fn clear_minor_faults(&mut self) {
        self.minor_faults = ::std::option::Option::None;
    }

    pub fn has_minor_faults(&self) -> bool {
        self.minor_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_faults(&mut self, v: u64) {
        self.minor_faults = ::std::option::Option::Some(v);
    }

    pub fn get_minor_faults(&self) -> u64 {
        self.minor_faults.unwrap_or(0)
    }

    fn get_minor_faults_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.minor_faults
    }

    fn mut_minor_faults_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.minor_faults
    }

    // optional uint64 major_faults = 17;

    pub fn clear_major_faults(&mut self) {
        self.major_faults = ::std::option::Option::None;
    }

    pub fn has_major_faults(&self) -> bool {
        self.major_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_faults(&mut self, v: u64) {
        self.major_faults = ::std::option::Option::Some(v);
    }

    pub fn get_major_faults(&self) -> u64 {
        self.major_faults.unwrap_or(0)
    }

    fn get_major_faults_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.major_faults
    }

    fn mut_major_faults_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.major_faults
    }

    // optional uint64 context_switches = 18;

    pub fn clear_context_switches(&mut self) {
        self.context_switches = ::std::option::Option::None;
    }

    pub fn has_context_switches(&self) -> bool {
        self.context_switches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_switches(&mut self, v: u64) {
        self.context_switches = ::std::option::Option::Some(v);
    }

    pub fn get_context_switches(&self) -> u64 {
        self.context_switches.unwrap_or(0)
    }

    fn get_context_switches_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.context_switches
    }

    fn mut_context_switches_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.context_switches
    }

    // optional uint64 cpu_migrations = 19;

    pub fn clear_cpu_migrations(&mut self) {
        self.cpu_migrations = ::std::option::Option::None;
    }

    pub fn has_cpu_migrations(&self) -> bool {
        self.cpu_migrations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_migrations(&mut self, v: u64) {
        self.cpu_migrations = ::std::option::Option::Some(v);
    }

    pub fn get_cpu_migrations(&self) -> u64 {
        self.cpu_migrations.unwrap_or(0)
    }

    fn get_cpu_migrations_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cpu_migrations
    }

    fn mut_cpu_migrations_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cpu_migrations
    }

    // optional uint64 alignment_faults = 20;

    pub fn clear_alignment_faults(&mut self) {
        self.alignment_faults = ::std::option::Option::None;
    }

    pub fn has_alignment_faults(&self) -> bool {
        self.alignment_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alignment_faults(&mut self, v: u64) {
        self.alignment_faults = ::std::option::Option::Some(v);
    }

    pub fn get_alignment_faults(&self) -> u64 {
        self.alignment_faults.unwrap_or(0)
    }

    fn get_alignment_faults_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.alignment_faults
    }

    fn mut_alignment_faults_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.alignment_faults
    }

    // optional uint64 emulation_faults = 21;

    pub fn clear_emulation_faults(&mut self) {
        self.emulation_faults = ::std::option::Option::None;
    }

    pub fn has_emulation_faults(&self) -> bool {
        self.emulation_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emulation_faults(&mut self, v: u64) {
        self.emulation_faults = ::std::option::Option::Some(v);
    }

    pub fn get_emulation_faults(&self) -> u64 {
        self.emulation_faults.unwrap_or(0)
    }

    fn get_emulation_faults_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.emulation_faults
    }

    fn mut_emulation_faults_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.emulation_faults
    }

    // optional uint64 l1_dcache_loads = 22;

    pub fn clear_l1_dcache_loads(&mut self) {
        self.l1_dcache_loads = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_loads(&self) -> bool {
        self.l1_dcache_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_loads(&mut self, v: u64) {
        self.l1_dcache_loads = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_loads(&self) -> u64 {
        self.l1_dcache_loads.unwrap_or(0)
    }

    fn get_l1_dcache_loads_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_dcache_loads
    }

    fn mut_l1_dcache_loads_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_dcache_loads
    }

    // optional uint64 l1_dcache_load_misses = 23;

    pub fn clear_l1_dcache_load_misses(&mut self) {
        self.l1_dcache_load_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_load_misses(&self) -> bool {
        self.l1_dcache_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_load_misses(&mut self, v: u64) {
        self.l1_dcache_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_load_misses(&self) -> u64 {
        self.l1_dcache_load_misses.unwrap_or(0)
    }

    fn get_l1_dcache_load_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_dcache_load_misses
    }

    fn mut_l1_dcache_load_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_dcache_load_misses
    }

    // optional uint64 l1_dcache_stores = 24;

    pub fn clear_l1_dcache_stores(&mut self) {
        self.l1_dcache_stores = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_stores(&self) -> bool {
        self.l1_dcache_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_stores(&mut self, v: u64) {
        self.l1_dcache_stores = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_stores(&self) -> u64 {
        self.l1_dcache_stores.unwrap_or(0)
    }

    fn get_l1_dcache_stores_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_dcache_stores
    }

    fn mut_l1_dcache_stores_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_dcache_stores
    }

    // optional uint64 l1_dcache_store_misses = 25;

    pub fn clear_l1_dcache_store_misses(&mut self) {
        self.l1_dcache_store_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_store_misses(&self) -> bool {
        self.l1_dcache_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_store_misses(&mut self, v: u64) {
        self.l1_dcache_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_store_misses(&self) -> u64 {
        self.l1_dcache_store_misses.unwrap_or(0)
    }

    fn get_l1_dcache_store_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_dcache_store_misses
    }

    fn mut_l1_dcache_store_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_dcache_store_misses
    }

    // optional uint64 l1_dcache_prefetches = 26;

    pub fn clear_l1_dcache_prefetches(&mut self) {
        self.l1_dcache_prefetches = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_prefetches(&self) -> bool {
        self.l1_dcache_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_prefetches(&mut self, v: u64) {
        self.l1_dcache_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_prefetches(&self) -> u64 {
        self.l1_dcache_prefetches.unwrap_or(0)
    }

    fn get_l1_dcache_prefetches_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_dcache_prefetches
    }

    fn mut_l1_dcache_prefetches_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_dcache_prefetches
    }

    // optional uint64 l1_dcache_prefetch_misses = 27;

    pub fn clear_l1_dcache_prefetch_misses(&mut self) {
        self.l1_dcache_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_prefetch_misses(&self) -> bool {
        self.l1_dcache_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_prefetch_misses(&mut self, v: u64) {
        self.l1_dcache_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_prefetch_misses(&self) -> u64 {
        self.l1_dcache_prefetch_misses.unwrap_or(0)
    }

    fn get_l1_dcache_prefetch_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_dcache_prefetch_misses
    }

    fn mut_l1_dcache_prefetch_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_dcache_prefetch_misses
    }

    // optional uint64 l1_icache_loads = 28;

    pub fn clear_l1_icache_loads(&mut self) {
        self.l1_icache_loads = ::std::option::Option::None;
    }

    pub fn has_l1_icache_loads(&self) -> bool {
        self.l1_icache_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_loads(&mut self, v: u64) {
        self.l1_icache_loads = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_loads(&self) -> u64 {
        self.l1_icache_loads.unwrap_or(0)
    }

    fn get_l1_icache_loads_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_icache_loads
    }

    fn mut_l1_icache_loads_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_icache_loads
    }

    // optional uint64 l1_icache_load_misses = 29;

    pub fn clear_l1_icache_load_misses(&mut self) {
        self.l1_icache_load_misses = ::std::option::Option::None;
    }

    pub fn has_l1_icache_load_misses(&self) -> bool {
        self.l1_icache_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_load_misses(&mut self, v: u64) {
        self.l1_icache_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_load_misses(&self) -> u64 {
        self.l1_icache_load_misses.unwrap_or(0)
    }

    fn get_l1_icache_load_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_icache_load_misses
    }

    fn mut_l1_icache_load_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_icache_load_misses
    }

    // optional uint64 l1_icache_prefetches = 30;

    pub fn clear_l1_icache_prefetches(&mut self) {
        self.l1_icache_prefetches = ::std::option::Option::None;
    }

    pub fn has_l1_icache_prefetches(&self) -> bool {
        self.l1_icache_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_prefetches(&mut self, v: u64) {
        self.l1_icache_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_prefetches(&self) -> u64 {
        self.l1_icache_prefetches.unwrap_or(0)
    }

    fn get_l1_icache_prefetches_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_icache_prefetches
    }

    fn mut_l1_icache_prefetches_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_icache_prefetches
    }

    // optional uint64 l1_icache_prefetch_misses = 31;

    pub fn clear_l1_icache_prefetch_misses(&mut self) {
        self.l1_icache_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_l1_icache_prefetch_misses(&self) -> bool {
        self.l1_icache_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_prefetch_misses(&mut self, v: u64) {
        self.l1_icache_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_prefetch_misses(&self) -> u64 {
        self.l1_icache_prefetch_misses.unwrap_or(0)
    }

    fn get_l1_icache_prefetch_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.l1_icache_prefetch_misses
    }

    fn mut_l1_icache_prefetch_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.l1_icache_prefetch_misses
    }

    // optional uint64 llc_loads = 32;

    pub fn clear_llc_loads(&mut self) {
        self.llc_loads = ::std::option::Option::None;
    }

    pub fn has_llc_loads(&self) -> bool {
        self.llc_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_loads(&mut self, v: u64) {
        self.llc_loads = ::std::option::Option::Some(v);
    }

    pub fn get_llc_loads(&self) -> u64 {
        self.llc_loads.unwrap_or(0)
    }

    fn get_llc_loads_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.llc_loads
    }

    fn mut_llc_loads_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.llc_loads
    }

    // optional uint64 llc_load_misses = 33;

    pub fn clear_llc_load_misses(&mut self) {
        self.llc_load_misses = ::std::option::Option::None;
    }

    pub fn has_llc_load_misses(&self) -> bool {
        self.llc_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_load_misses(&mut self, v: u64) {
        self.llc_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_load_misses(&self) -> u64 {
        self.llc_load_misses.unwrap_or(0)
    }

    fn get_llc_load_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.llc_load_misses
    }

    fn mut_llc_load_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.llc_load_misses
    }

    // optional uint64 llc_stores = 34;

    pub fn clear_llc_stores(&mut self) {
        self.llc_stores = ::std::option::Option::None;
    }

    pub fn has_llc_stores(&self) -> bool {
        self.llc_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_stores(&mut self, v: u64) {
        self.llc_stores = ::std::option::Option::Some(v);
    }

    pub fn get_llc_stores(&self) -> u64 {
        self.llc_stores.unwrap_or(0)
    }

    fn get_llc_stores_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.llc_stores
    }

    fn mut_llc_stores_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.llc_stores
    }

    // optional uint64 llc_store_misses = 35;

    pub fn clear_llc_store_misses(&mut self) {
        self.llc_store_misses = ::std::option::Option::None;
    }

    pub fn has_llc_store_misses(&self) -> bool {
        self.llc_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_store_misses(&mut self, v: u64) {
        self.llc_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_store_misses(&self) -> u64 {
        self.llc_store_misses.unwrap_or(0)
    }

    fn get_llc_store_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.llc_store_misses
    }

    fn mut_llc_store_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.llc_store_misses
    }

    // optional uint64 llc_prefetches = 36;

    pub fn clear_llc_prefetches(&mut self) {
        self.llc_prefetches = ::std::option::Option::None;
    }

    pub fn has_llc_prefetches(&self) -> bool {
        self.llc_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_prefetches(&mut self, v: u64) {
        self.llc_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_llc_prefetches(&self) -> u64 {
        self.llc_prefetches.unwrap_or(0)
    }

    fn get_llc_prefetches_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.llc_prefetches
    }

    fn mut_llc_prefetches_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.llc_prefetches
    }

    // optional uint64 llc_prefetch_misses = 37;

    pub fn clear_llc_prefetch_misses(&mut self) {
        self.llc_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_llc_prefetch_misses(&self) -> bool {
        self.llc_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_prefetch_misses(&mut self, v: u64) {
        self.llc_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_prefetch_misses(&self) -> u64 {
        self.llc_prefetch_misses.unwrap_or(0)
    }

    fn get_llc_prefetch_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.llc_prefetch_misses
    }

    fn mut_llc_prefetch_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.llc_prefetch_misses
    }

    // optional uint64 dtlb_loads = 38;

    pub fn clear_dtlb_loads(&mut self) {
        self.dtlb_loads = ::std::option::Option::None;
    }

    pub fn has_dtlb_loads(&self) -> bool {
        self.dtlb_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_loads(&mut self, v: u64) {
        self.dtlb_loads = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_loads(&self) -> u64 {
        self.dtlb_loads.unwrap_or(0)
    }

    fn get_dtlb_loads_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dtlb_loads
    }

    fn mut_dtlb_loads_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dtlb_loads
    }

    // optional uint64 dtlb_load_misses = 39;

    pub fn clear_dtlb_load_misses(&mut self) {
        self.dtlb_load_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_load_misses(&self) -> bool {
        self.dtlb_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_load_misses(&mut self, v: u64) {
        self.dtlb_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_load_misses(&self) -> u64 {
        self.dtlb_load_misses.unwrap_or(0)
    }

    fn get_dtlb_load_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dtlb_load_misses
    }

    fn mut_dtlb_load_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dtlb_load_misses
    }

    // optional uint64 dtlb_stores = 40;

    pub fn clear_dtlb_stores(&mut self) {
        self.dtlb_stores = ::std::option::Option::None;
    }

    pub fn has_dtlb_stores(&self) -> bool {
        self.dtlb_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_stores(&mut self, v: u64) {
        self.dtlb_stores = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_stores(&self) -> u64 {
        self.dtlb_stores.unwrap_or(0)
    }

    fn get_dtlb_stores_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dtlb_stores
    }

    fn mut_dtlb_stores_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dtlb_stores
    }

    // optional uint64 dtlb_store_misses = 41;

    pub fn clear_dtlb_store_misses(&mut self) {
        self.dtlb_store_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_store_misses(&self) -> bool {
        self.dtlb_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_store_misses(&mut self, v: u64) {
        self.dtlb_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_store_misses(&self) -> u64 {
        self.dtlb_store_misses.unwrap_or(0)
    }

    fn get_dtlb_store_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dtlb_store_misses
    }

    fn mut_dtlb_store_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dtlb_store_misses
    }

    // optional uint64 dtlb_prefetches = 42;

    pub fn clear_dtlb_prefetches(&mut self) {
        self.dtlb_prefetches = ::std::option::Option::None;
    }

    pub fn has_dtlb_prefetches(&self) -> bool {
        self.dtlb_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_prefetches(&mut self, v: u64) {
        self.dtlb_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_prefetches(&self) -> u64 {
        self.dtlb_prefetches.unwrap_or(0)
    }

    fn get_dtlb_prefetches_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dtlb_prefetches
    }

    fn mut_dtlb_prefetches_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dtlb_prefetches
    }

    // optional uint64 dtlb_prefetch_misses = 43;

    pub fn clear_dtlb_prefetch_misses(&mut self) {
        self.dtlb_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_prefetch_misses(&self) -> bool {
        self.dtlb_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_prefetch_misses(&mut self, v: u64) {
        self.dtlb_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_prefetch_misses(&self) -> u64 {
        self.dtlb_prefetch_misses.unwrap_or(0)
    }

    fn get_dtlb_prefetch_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dtlb_prefetch_misses
    }

    fn mut_dtlb_prefetch_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dtlb_prefetch_misses
    }

    // optional uint64 itlb_loads = 44;

    pub fn clear_itlb_loads(&mut self) {
        self.itlb_loads = ::std::option::Option::None;
    }

    pub fn has_itlb_loads(&self) -> bool {
        self.itlb_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itlb_loads(&mut self, v: u64) {
        self.itlb_loads = ::std::option::Option::Some(v);
    }

    pub fn get_itlb_loads(&self) -> u64 {
        self.itlb_loads.unwrap_or(0)
    }

    fn get_itlb_loads_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.itlb_loads
    }

    fn mut_itlb_loads_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.itlb_loads
    }

    // optional uint64 itlb_load_misses = 45;

    pub fn clear_itlb_load_misses(&mut self) {
        self.itlb_load_misses = ::std::option::Option::None;
    }

    pub fn has_itlb_load_misses(&self) -> bool {
        self.itlb_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itlb_load_misses(&mut self, v: u64) {
        self.itlb_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_itlb_load_misses(&self) -> u64 {
        self.itlb_load_misses.unwrap_or(0)
    }

    fn get_itlb_load_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.itlb_load_misses
    }

    fn mut_itlb_load_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.itlb_load_misses
    }

    // optional uint64 branch_loads = 46;

    pub fn clear_branch_loads(&mut self) {
        self.branch_loads = ::std::option::Option::None;
    }

    pub fn has_branch_loads(&self) -> bool {
        self.branch_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_loads(&mut self, v: u64) {
        self.branch_loads = ::std::option::Option::Some(v);
    }

    pub fn get_branch_loads(&self) -> u64 {
        self.branch_loads.unwrap_or(0)
    }

    fn get_branch_loads_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.branch_loads
    }

    fn mut_branch_loads_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.branch_loads
    }

    // optional uint64 branch_load_misses = 47;

    pub fn clear_branch_load_misses(&mut self) {
        self.branch_load_misses = ::std::option::Option::None;
    }

    pub fn has_branch_load_misses(&self) -> bool {
        self.branch_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_load_misses(&mut self, v: u64) {
        self.branch_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_branch_load_misses(&self) -> u64 {
        self.branch_load_misses.unwrap_or(0)
    }

    fn get_branch_load_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.branch_load_misses
    }

    fn mut_branch_load_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.branch_load_misses
    }

    // optional uint64 node_loads = 48;

    pub fn clear_node_loads(&mut self) {
        self.node_loads = ::std::option::Option::None;
    }

    pub fn has_node_loads(&self) -> bool {
        self.node_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_loads(&mut self, v: u64) {
        self.node_loads = ::std::option::Option::Some(v);
    }

    pub fn get_node_loads(&self) -> u64 {
        self.node_loads.unwrap_or(0)
    }

    fn get_node_loads_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.node_loads
    }

    fn mut_node_loads_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.node_loads
    }

    // optional uint64 node_load_misses = 49;

    pub fn clear_node_load_misses(&mut self) {
        self.node_load_misses = ::std::option::Option::None;
    }

    pub fn has_node_load_misses(&self) -> bool {
        self.node_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_load_misses(&mut self, v: u64) {
        self.node_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_load_misses(&self) -> u64 {
        self.node_load_misses.unwrap_or(0)
    }

    fn get_node_load_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.node_load_misses
    }

    fn mut_node_load_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.node_load_misses
    }

    // optional uint64 node_stores = 50;

    pub fn clear_node_stores(&mut self) {
        self.node_stores = ::std::option::Option::None;
    }

    pub fn has_node_stores(&self) -> bool {
        self.node_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_stores(&mut self, v: u64) {
        self.node_stores = ::std::option::Option::Some(v);
    }

    pub fn get_node_stores(&self) -> u64 {
        self.node_stores.unwrap_or(0)
    }

    fn get_node_stores_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.node_stores
    }

    fn mut_node_stores_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.node_stores
    }

    // optional uint64 node_store_misses = 51;

    pub fn clear_node_store_misses(&mut self) {
        self.node_store_misses = ::std::option::Option::None;
    }

    pub fn has_node_store_misses(&self) -> bool {
        self.node_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_store_misses(&mut self, v: u64) {
        self.node_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_store_misses(&self) -> u64 {
        self.node_store_misses.unwrap_or(0)
    }

    fn get_node_store_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.node_store_misses
    }

    fn mut_node_store_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.node_store_misses
    }

    // optional uint64 node_prefetches = 52;

    pub fn clear_node_prefetches(&mut self) {
        self.node_prefetches = ::std::option::Option::None;
    }

    pub fn has_node_prefetches(&self) -> bool {
        self.node_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_prefetches(&mut self, v: u64) {
        self.node_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_node_prefetches(&self) -> u64 {
        self.node_prefetches.unwrap_or(0)
    }

    fn get_node_prefetches_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.node_prefetches
    }

    fn mut_node_prefetches_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.node_prefetches
    }

    // optional uint64 node_prefetch_misses = 53;

    pub fn clear_node_prefetch_misses(&mut self) {
        self.node_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_node_prefetch_misses(&self) -> bool {
        self.node_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_prefetch_misses(&mut self, v: u64) {
        self.node_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_prefetch_misses(&self) -> u64 {
        self.node_prefetch_misses.unwrap_or(0)
    }

    fn get_node_prefetch_misses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.node_prefetch_misses
    }

    fn mut_node_prefetch_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.node_prefetch_misses
    }
}

impl ::protobuf::Message for PerfStatistics {
    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        }
        if self.duration.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cycles = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stalled_cycles_frontend = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stalled_cycles_backend = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.instructions = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cache_references = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cache_misses = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.branches = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.branch_misses = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bus_cycles = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ref_cycles = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpu_clock = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.task_clock = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.page_faults = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minor_faults = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.major_faults = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.context_switches = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cpu_migrations = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.alignment_faults = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.emulation_faults = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_dcache_loads = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_dcache_load_misses = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_dcache_stores = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_dcache_store_misses = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_dcache_prefetches = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_dcache_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_icache_loads = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_icache_load_misses = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_icache_prefetches = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.l1_icache_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.llc_loads = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.llc_load_misses = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.llc_stores = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.llc_store_misses = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.llc_prefetches = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.llc_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dtlb_loads = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dtlb_load_misses = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dtlb_stores = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dtlb_store_misses = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dtlb_prefetches = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dtlb_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itlb_loads = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itlb_load_misses = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.branch_loads = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.branch_load_misses = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_loads = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_load_misses = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_stores = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_store_misses = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_prefetches = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += 9;
        }
        if let Some(v) = self.duration {
            my_size += 9;
        }
        if let Some(v) = self.cycles {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stalled_cycles_frontend {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stalled_cycles_backend {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.instructions {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cache_references {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cache_misses {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.branches {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.branch_misses {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bus_cycles {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ref_cycles {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cpu_clock {
            my_size += 9;
        }
        if let Some(v) = self.task_clock {
            my_size += 9;
        }
        if let Some(v) = self.page_faults {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minor_faults {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.major_faults {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.context_switches {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cpu_migrations {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.alignment_faults {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.emulation_faults {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_dcache_loads {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_dcache_load_misses {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_dcache_stores {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_dcache_store_misses {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_dcache_prefetches {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_dcache_prefetch_misses {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_icache_loads {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_icache_load_misses {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_icache_prefetches {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.l1_icache_prefetch_misses {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.llc_loads {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.llc_load_misses {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.llc_stores {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.llc_store_misses {
            my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.llc_prefetches {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.llc_prefetch_misses {
            my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dtlb_loads {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dtlb_load_misses {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dtlb_stores {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dtlb_store_misses {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dtlb_prefetches {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dtlb_prefetch_misses {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itlb_loads {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itlb_load_misses {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.branch_loads {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.branch_load_misses {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.node_loads {
            my_size += ::protobuf::rt::value_size(48, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.node_load_misses {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.node_stores {
            my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.node_store_misses {
            my_size += ::protobuf::rt::value_size(51, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.node_prefetches {
            my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.node_prefetch_misses {
            my_size += ::protobuf::rt::value_size(53, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.cycles {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.stalled_cycles_frontend {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.stalled_cycles_backend {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.instructions {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.cache_references {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.cache_misses {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.branches {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.branch_misses {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.bus_cycles {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.ref_cycles {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.cpu_clock {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.task_clock {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.page_faults {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.minor_faults {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.major_faults {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.context_switches {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.cpu_migrations {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.alignment_faults {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.emulation_faults {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.l1_dcache_loads {
            os.write_uint64(22, v)?;
        }
        if let Some(v) = self.l1_dcache_load_misses {
            os.write_uint64(23, v)?;
        }
        if let Some(v) = self.l1_dcache_stores {
            os.write_uint64(24, v)?;
        }
        if let Some(v) = self.l1_dcache_store_misses {
            os.write_uint64(25, v)?;
        }
        if let Some(v) = self.l1_dcache_prefetches {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.l1_dcache_prefetch_misses {
            os.write_uint64(27, v)?;
        }
        if let Some(v) = self.l1_icache_loads {
            os.write_uint64(28, v)?;
        }
        if let Some(v) = self.l1_icache_load_misses {
            os.write_uint64(29, v)?;
        }
        if let Some(v) = self.l1_icache_prefetches {
            os.write_uint64(30, v)?;
        }
        if let Some(v) = self.l1_icache_prefetch_misses {
            os.write_uint64(31, v)?;
        }
        if let Some(v) = self.llc_loads {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.llc_load_misses {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.llc_stores {
            os.write_uint64(34, v)?;
        }
        if let Some(v) = self.llc_store_misses {
            os.write_uint64(35, v)?;
        }
        if let Some(v) = self.llc_prefetches {
            os.write_uint64(36, v)?;
        }
        if let Some(v) = self.llc_prefetch_misses {
            os.write_uint64(37, v)?;
        }
        if let Some(v) = self.dtlb_loads {
            os.write_uint64(38, v)?;
        }
        if let Some(v) = self.dtlb_load_misses {
            os.write_uint64(39, v)?;
        }
        if let Some(v) = self.dtlb_stores {
            os.write_uint64(40, v)?;
        }
        if let Some(v) = self.dtlb_store_misses {
            os.write_uint64(41, v)?;
        }
        if let Some(v) = self.dtlb_prefetches {
            os.write_uint64(42, v)?;
        }
        if let Some(v) = self.dtlb_prefetch_misses {
            os.write_uint64(43, v)?;
        }
        if let Some(v) = self.itlb_loads {
            os.write_uint64(44, v)?;
        }
        if let Some(v) = self.itlb_load_misses {
            os.write_uint64(45, v)?;
        }
        if let Some(v) = self.branch_loads {
            os.write_uint64(46, v)?;
        }
        if let Some(v) = self.branch_load_misses {
            os.write_uint64(47, v)?;
        }
        if let Some(v) = self.node_loads {
            os.write_uint64(48, v)?;
        }
        if let Some(v) = self.node_load_misses {
            os.write_uint64(49, v)?;
        }
        if let Some(v) = self.node_stores {
            os.write_uint64(50, v)?;
        }
        if let Some(v) = self.node_store_misses {
            os.write_uint64(51, v)?;
        }
        if let Some(v) = self.node_prefetches {
            os.write_uint64(52, v)?;
        }
        if let Some(v) = self.node_prefetch_misses {
            os.write_uint64(53, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PerfStatistics {
    fn new() -> PerfStatistics {
        PerfStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<PerfStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "timestamp",
                    PerfStatistics::get_timestamp_for_reflect,
                    PerfStatistics::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "duration",
                    PerfStatistics::get_duration_for_reflect,
                    PerfStatistics::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cycles",
                    PerfStatistics::get_cycles_for_reflect,
                    PerfStatistics::mut_cycles_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "stalled_cycles_frontend",
                    PerfStatistics::get_stalled_cycles_frontend_for_reflect,
                    PerfStatistics::mut_stalled_cycles_frontend_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "stalled_cycles_backend",
                    PerfStatistics::get_stalled_cycles_backend_for_reflect,
                    PerfStatistics::mut_stalled_cycles_backend_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "instructions",
                    PerfStatistics::get_instructions_for_reflect,
                    PerfStatistics::mut_instructions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cache_references",
                    PerfStatistics::get_cache_references_for_reflect,
                    PerfStatistics::mut_cache_references_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cache_misses",
                    PerfStatistics::get_cache_misses_for_reflect,
                    PerfStatistics::mut_cache_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "branches",
                    PerfStatistics::get_branches_for_reflect,
                    PerfStatistics::mut_branches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "branch_misses",
                    PerfStatistics::get_branch_misses_for_reflect,
                    PerfStatistics::mut_branch_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bus_cycles",
                    PerfStatistics::get_bus_cycles_for_reflect,
                    PerfStatistics::mut_bus_cycles_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ref_cycles",
                    PerfStatistics::get_ref_cycles_for_reflect,
                    PerfStatistics::mut_ref_cycles_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpu_clock",
                    PerfStatistics::get_cpu_clock_for_reflect,
                    PerfStatistics::mut_cpu_clock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "task_clock",
                    PerfStatistics::get_task_clock_for_reflect,
                    PerfStatistics::mut_task_clock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "page_faults",
                    PerfStatistics::get_page_faults_for_reflect,
                    PerfStatistics::mut_page_faults_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minor_faults",
                    PerfStatistics::get_minor_faults_for_reflect,
                    PerfStatistics::mut_minor_faults_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "major_faults",
                    PerfStatistics::get_major_faults_for_reflect,
                    PerfStatistics::mut_major_faults_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "context_switches",
                    PerfStatistics::get_context_switches_for_reflect,
                    PerfStatistics::mut_context_switches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cpu_migrations",
                    PerfStatistics::get_cpu_migrations_for_reflect,
                    PerfStatistics::mut_cpu_migrations_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "alignment_faults",
                    PerfStatistics::get_alignment_faults_for_reflect,
                    PerfStatistics::mut_alignment_faults_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "emulation_faults",
                    PerfStatistics::get_emulation_faults_for_reflect,
                    PerfStatistics::mut_emulation_faults_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_dcache_loads",
                    PerfStatistics::get_l1_dcache_loads_for_reflect,
                    PerfStatistics::mut_l1_dcache_loads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_dcache_load_misses",
                    PerfStatistics::get_l1_dcache_load_misses_for_reflect,
                    PerfStatistics::mut_l1_dcache_load_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_dcache_stores",
                    PerfStatistics::get_l1_dcache_stores_for_reflect,
                    PerfStatistics::mut_l1_dcache_stores_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_dcache_store_misses",
                    PerfStatistics::get_l1_dcache_store_misses_for_reflect,
                    PerfStatistics::mut_l1_dcache_store_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_dcache_prefetches",
                    PerfStatistics::get_l1_dcache_prefetches_for_reflect,
                    PerfStatistics::mut_l1_dcache_prefetches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_dcache_prefetch_misses",
                    PerfStatistics::get_l1_dcache_prefetch_misses_for_reflect,
                    PerfStatistics::mut_l1_dcache_prefetch_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_icache_loads",
                    PerfStatistics::get_l1_icache_loads_for_reflect,
                    PerfStatistics::mut_l1_icache_loads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_icache_load_misses",
                    PerfStatistics::get_l1_icache_load_misses_for_reflect,
                    PerfStatistics::mut_l1_icache_load_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_icache_prefetches",
                    PerfStatistics::get_l1_icache_prefetches_for_reflect,
                    PerfStatistics::mut_l1_icache_prefetches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "l1_icache_prefetch_misses",
                    PerfStatistics::get_l1_icache_prefetch_misses_for_reflect,
                    PerfStatistics::mut_l1_icache_prefetch_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "llc_loads",
                    PerfStatistics::get_llc_loads_for_reflect,
                    PerfStatistics::mut_llc_loads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "llc_load_misses",
                    PerfStatistics::get_llc_load_misses_for_reflect,
                    PerfStatistics::mut_llc_load_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "llc_stores",
                    PerfStatistics::get_llc_stores_for_reflect,
                    PerfStatistics::mut_llc_stores_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "llc_store_misses",
                    PerfStatistics::get_llc_store_misses_for_reflect,
                    PerfStatistics::mut_llc_store_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "llc_prefetches",
                    PerfStatistics::get_llc_prefetches_for_reflect,
                    PerfStatistics::mut_llc_prefetches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "llc_prefetch_misses",
                    PerfStatistics::get_llc_prefetch_misses_for_reflect,
                    PerfStatistics::mut_llc_prefetch_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dtlb_loads",
                    PerfStatistics::get_dtlb_loads_for_reflect,
                    PerfStatistics::mut_dtlb_loads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dtlb_load_misses",
                    PerfStatistics::get_dtlb_load_misses_for_reflect,
                    PerfStatistics::mut_dtlb_load_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dtlb_stores",
                    PerfStatistics::get_dtlb_stores_for_reflect,
                    PerfStatistics::mut_dtlb_stores_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dtlb_store_misses",
                    PerfStatistics::get_dtlb_store_misses_for_reflect,
                    PerfStatistics::mut_dtlb_store_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dtlb_prefetches",
                    PerfStatistics::get_dtlb_prefetches_for_reflect,
                    PerfStatistics::mut_dtlb_prefetches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dtlb_prefetch_misses",
                    PerfStatistics::get_dtlb_prefetch_misses_for_reflect,
                    PerfStatistics::mut_dtlb_prefetch_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itlb_loads",
                    PerfStatistics::get_itlb_loads_for_reflect,
                    PerfStatistics::mut_itlb_loads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itlb_load_misses",
                    PerfStatistics::get_itlb_load_misses_for_reflect,
                    PerfStatistics::mut_itlb_load_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "branch_loads",
                    PerfStatistics::get_branch_loads_for_reflect,
                    PerfStatistics::mut_branch_loads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "branch_load_misses",
                    PerfStatistics::get_branch_load_misses_for_reflect,
                    PerfStatistics::mut_branch_load_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "node_loads",
                    PerfStatistics::get_node_loads_for_reflect,
                    PerfStatistics::mut_node_loads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "node_load_misses",
                    PerfStatistics::get_node_load_misses_for_reflect,
                    PerfStatistics::mut_node_load_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "node_stores",
                    PerfStatistics::get_node_stores_for_reflect,
                    PerfStatistics::mut_node_stores_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "node_store_misses",
                    PerfStatistics::get_node_store_misses_for_reflect,
                    PerfStatistics::mut_node_store_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "node_prefetches",
                    PerfStatistics::get_node_prefetches_for_reflect,
                    PerfStatistics::mut_node_prefetches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "node_prefetch_misses",
                    PerfStatistics::get_node_prefetch_misses_for_reflect,
                    PerfStatistics::mut_node_prefetch_misses_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PerfStatistics>(
                    "PerfStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PerfStatistics {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_duration();
        self.clear_cycles();
        self.clear_stalled_cycles_frontend();
        self.clear_stalled_cycles_backend();
        self.clear_instructions();
        self.clear_cache_references();
        self.clear_cache_misses();
        self.clear_branches();
        self.clear_branch_misses();
        self.clear_bus_cycles();
        self.clear_ref_cycles();
        self.clear_cpu_clock();
        self.clear_task_clock();
        self.clear_page_faults();
        self.clear_minor_faults();
        self.clear_major_faults();
        self.clear_context_switches();
        self.clear_cpu_migrations();
        self.clear_alignment_faults();
        self.clear_emulation_faults();
        self.clear_l1_dcache_loads();
        self.clear_l1_dcache_load_misses();
        self.clear_l1_dcache_stores();
        self.clear_l1_dcache_store_misses();
        self.clear_l1_dcache_prefetches();
        self.clear_l1_dcache_prefetch_misses();
        self.clear_l1_icache_loads();
        self.clear_l1_icache_load_misses();
        self.clear_l1_icache_prefetches();
        self.clear_l1_icache_prefetch_misses();
        self.clear_llc_loads();
        self.clear_llc_load_misses();
        self.clear_llc_stores();
        self.clear_llc_store_misses();
        self.clear_llc_prefetches();
        self.clear_llc_prefetch_misses();
        self.clear_dtlb_loads();
        self.clear_dtlb_load_misses();
        self.clear_dtlb_stores();
        self.clear_dtlb_store_misses();
        self.clear_dtlb_prefetches();
        self.clear_dtlb_prefetch_misses();
        self.clear_itlb_loads();
        self.clear_itlb_load_misses();
        self.clear_branch_loads();
        self.clear_branch_load_misses();
        self.clear_node_loads();
        self.clear_node_load_misses();
        self.clear_node_stores();
        self.clear_node_store_misses();
        self.clear_node_prefetches();
        self.clear_node_prefetch_misses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerfStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerfStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message fields
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Request {}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Request,
        };
        unsafe {
            instance.get(Request::new)
        }
    }

    // optional .mesos.v1.AgentID agent_id = 1;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id(&mut self) -> &mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        }
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id(&self) -> &AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_agent_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.agent_id
    }

    fn mut_agent_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.agent_id
    }

    // repeated .mesos.v1.Resource resources = 2;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        for v in &self.agent_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.agent_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.agent_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resources {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Request {
    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static(_: ::std::option::Option<Request>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "agent_id",
                    Request::get_agent_id_for_reflect,
                    Request::mut_agent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    Request::get_resources_for_reflect,
                    Request::mut_resources_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.clear_agent_id();
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer {
    // message fields
    id: ::protobuf::SingularPtrField<OfferID>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularPtrField<URL>,
    domain: ::protobuf::SingularPtrField<DomainInfo>,
    resources: ::protobuf::RepeatedField<Resource>,
    attributes: ::protobuf::RepeatedField<Attribute>,
    executor_ids: ::protobuf::RepeatedField<ExecutorID>,
    unavailability: ::protobuf::SingularPtrField<Unavailability>,
    allocation_info: ::protobuf::SingularPtrField<Resource_AllocationInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer {}

impl Offer {
    pub fn new() -> Offer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer {
        static mut instance: ::protobuf::lazy::Lazy<Offer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer,
        };
        unsafe {
            instance.get(Offer::new)
        }
    }

    // required .mesos.v1.OfferID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: OfferID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut OfferID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> OfferID {
        self.id.take().unwrap_or_else(|| OfferID::new())
    }

    pub fn get_id(&self) -> &OfferID {
        self.id.as_ref().unwrap_or_else(|| OfferID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<OfferID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OfferID> {
        &mut self.id
    }

    // required .mesos.v1.FrameworkID framework_id = 2;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id(&mut self) -> &mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        }
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id(&self) -> &FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    fn get_framework_id_for_reflect(&self) -> &::protobuf::SingularPtrField<FrameworkID> {
        &self.framework_id
    }

    fn mut_framework_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FrameworkID> {
        &mut self.framework_id
    }

    // required .mesos.v1.AgentID agent_id = 3;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id(&mut self) -> &mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        }
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id(&self) -> &AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_agent_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.agent_id
    }

    fn mut_agent_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.agent_id
    }

    // required string hostname = 4;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional .mesos.v1.URL url = 8;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: URL) {
        self.url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut URL {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> URL {
        self.url.take().unwrap_or_else(|| URL::new())
    }

    pub fn get_url(&self) -> &URL {
        self.url.as_ref().unwrap_or_else(|| URL::default_instance())
    }

    fn get_url_for_reflect(&self) -> &::protobuf::SingularPtrField<URL> {
        &self.url
    }

    fn mut_url_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<URL> {
        &mut self.url
    }

    // optional .mesos.v1.DomainInfo domain = 11;

    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: DomainInfo) {
        self.domain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut DomainInfo {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> DomainInfo {
        self.domain.take().unwrap_or_else(|| DomainInfo::new())
    }

    pub fn get_domain(&self) -> &DomainInfo {
        self.domain.as_ref().unwrap_or_else(|| DomainInfo::default_instance())
    }

    fn get_domain_for_reflect(&self) -> &::protobuf::SingularPtrField<DomainInfo> {
        &self.domain
    }

    fn mut_domain_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DomainInfo> {
        &mut self.domain
    }

    // repeated .mesos.v1.Resource resources = 5;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // repeated .mesos.v1.Attribute attributes = 7;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Attribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Attribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes(&self) -> &[Attribute] {
        &self.attributes
    }

    fn get_attributes_for_reflect(&self) -> &::protobuf::RepeatedField<Attribute> {
        &self.attributes
    }

    fn mut_attributes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // repeated .mesos.v1.ExecutorID executor_ids = 6;

    pub fn clear_executor_ids(&mut self) {
        self.executor_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_executor_ids(&mut self, v: ::protobuf::RepeatedField<ExecutorID>) {
        self.executor_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_executor_ids(&mut self) -> &mut ::protobuf::RepeatedField<ExecutorID> {
        &mut self.executor_ids
    }

    // Take field
    pub fn take_executor_ids(&mut self) -> ::protobuf::RepeatedField<ExecutorID> {
        ::std::mem::replace(&mut self.executor_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_executor_ids(&self) -> &[ExecutorID] {
        &self.executor_ids
    }

    fn get_executor_ids_for_reflect(&self) -> &::protobuf::RepeatedField<ExecutorID> {
        &self.executor_ids
    }

    fn mut_executor_ids_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ExecutorID> {
        &mut self.executor_ids
    }

    // optional .mesos.v1.Unavailability unavailability = 9;

    pub fn clear_unavailability(&mut self) {
        self.unavailability.clear();
    }

    pub fn has_unavailability(&self) -> bool {
        self.unavailability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailability(&mut self, v: Unavailability) {
        self.unavailability = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unavailability(&mut self) -> &mut Unavailability {
        if self.unavailability.is_none() {
            self.unavailability.set_default();
        }
        self.unavailability.as_mut().unwrap()
    }

    // Take field
    pub fn take_unavailability(&mut self) -> Unavailability {
        self.unavailability.take().unwrap_or_else(|| Unavailability::new())
    }

    pub fn get_unavailability(&self) -> &Unavailability {
        self.unavailability.as_ref().unwrap_or_else(|| Unavailability::default_instance())
    }

    fn get_unavailability_for_reflect(&self) -> &::protobuf::SingularPtrField<Unavailability> {
        &self.unavailability
    }

    fn mut_unavailability_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Unavailability> {
        &mut self.unavailability
    }

    // optional .mesos.v1.Resource.AllocationInfo allocation_info = 10;

    pub fn clear_allocation_info(&mut self) {
        self.allocation_info.clear();
    }

    pub fn has_allocation_info(&self) -> bool {
        self.allocation_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocation_info(&mut self, v: Resource_AllocationInfo) {
        self.allocation_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocation_info(&mut self) -> &mut Resource_AllocationInfo {
        if self.allocation_info.is_none() {
            self.allocation_info.set_default();
        }
        self.allocation_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_allocation_info(&mut self) -> Resource_AllocationInfo {
        self.allocation_info.take().unwrap_or_else(|| Resource_AllocationInfo::new())
    }

    pub fn get_allocation_info(&self) -> &Resource_AllocationInfo {
        self.allocation_info.as_ref().unwrap_or_else(|| Resource_AllocationInfo::default_instance())
    }

    fn get_allocation_info_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource_AllocationInfo> {
        &self.allocation_info
    }

    fn mut_allocation_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource_AllocationInfo> {
        &mut self.allocation_info
    }
}

impl ::protobuf::Message for Offer {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.framework_id.is_none() {
            return false;
        }
        if self.agent_id.is_none() {
            return false;
        }
        if self.hostname.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.framework_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.agent_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.domain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.executor_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unavailability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allocation_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.url)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.domain)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.executor_ids)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unavailability)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allocation_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.domain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.executor_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.unavailability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.allocation_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resources {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.attributes {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.executor_ids {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.unavailability.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.allocation_info.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer {
    fn new() -> Offer {
        Offer::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferID>>(
                    "id",
                    Offer::get_id_for_reflect,
                    Offer::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkID>>(
                    "framework_id",
                    Offer::get_framework_id_for_reflect,
                    Offer::mut_framework_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "agent_id",
                    Offer::get_agent_id_for_reflect,
                    Offer::mut_agent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    Offer::get_hostname_for_reflect,
                    Offer::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<URL>>(
                    "url",
                    Offer::get_url_for_reflect,
                    Offer::mut_url_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DomainInfo>>(
                    "domain",
                    Offer::get_domain_for_reflect,
                    Offer::mut_domain_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    Offer::get_resources_for_reflect,
                    Offer::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribute>>(
                    "attributes",
                    Offer::get_attributes_for_reflect,
                    Offer::mut_attributes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorID>>(
                    "executor_ids",
                    Offer::get_executor_ids_for_reflect,
                    Offer::mut_executor_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unavailability>>(
                    "unavailability",
                    Offer::get_unavailability_for_reflect,
                    Offer::mut_unavailability_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource_AllocationInfo>>(
                    "allocation_info",
                    Offer::get_allocation_info_for_reflect,
                    Offer::mut_allocation_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer>(
                    "Offer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_framework_id();
        self.clear_agent_id();
        self.clear_hostname();
        self.clear_url();
        self.clear_domain();
        self.clear_resources();
        self.clear_attributes();
        self.clear_executor_ids();
        self.clear_unavailability();
        self.clear_allocation_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation {
    // message fields
    field_type: ::std::option::Option<Offer_Operation_Type>,
    id: ::protobuf::SingularPtrField<OperationID>,
    launch: ::protobuf::SingularPtrField<Offer_Operation_Launch>,
    launch_group: ::protobuf::SingularPtrField<Offer_Operation_LaunchGroup>,
    reserve: ::protobuf::SingularPtrField<Offer_Operation_Reserve>,
    unreserve: ::protobuf::SingularPtrField<Offer_Operation_Unreserve>,
    create: ::protobuf::SingularPtrField<Offer_Operation_Create>,
    destroy: ::protobuf::SingularPtrField<Offer_Operation_Destroy>,
    create_volume: ::protobuf::SingularPtrField<Offer_Operation_CreateVolume>,
    destroy_volume: ::protobuf::SingularPtrField<Offer_Operation_DestroyVolume>,
    create_block: ::protobuf::SingularPtrField<Offer_Operation_CreateBlock>,
    destroy_block: ::protobuf::SingularPtrField<Offer_Operation_DestroyBlock>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation {}

impl Offer_Operation {
    pub fn new() -> Offer_Operation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation,
        };
        unsafe {
            instance.get(Offer_Operation::new)
        }
    }

    // optional .mesos.v1.Offer.Operation.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Offer_Operation_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Offer_Operation_Type {
        self.field_type.unwrap_or(Offer_Operation_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Offer_Operation_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Offer_Operation_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.OperationID id = 12;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: OperationID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut OperationID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> OperationID {
        self.id.take().unwrap_or_else(|| OperationID::new())
    }

    pub fn get_id(&self) -> &OperationID {
        self.id.as_ref().unwrap_or_else(|| OperationID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<OperationID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OperationID> {
        &mut self.id
    }

    // optional .mesos.v1.Offer.Operation.Launch launch = 2;

    pub fn clear_launch(&mut self) {
        self.launch.clear();
    }

    pub fn has_launch(&self) -> bool {
        self.launch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch(&mut self, v: Offer_Operation_Launch) {
        self.launch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_launch(&mut self) -> &mut Offer_Operation_Launch {
        if self.launch.is_none() {
            self.launch.set_default();
        }
        self.launch.as_mut().unwrap()
    }

    // Take field
    pub fn take_launch(&mut self) -> Offer_Operation_Launch {
        self.launch.take().unwrap_or_else(|| Offer_Operation_Launch::new())
    }

    pub fn get_launch(&self) -> &Offer_Operation_Launch {
        self.launch.as_ref().unwrap_or_else(|| Offer_Operation_Launch::default_instance())
    }

    fn get_launch_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_Launch> {
        &self.launch
    }

    fn mut_launch_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_Launch> {
        &mut self.launch
    }

    // optional .mesos.v1.Offer.Operation.LaunchGroup launch_group = 7;

    pub fn clear_launch_group(&mut self) {
        self.launch_group.clear();
    }

    pub fn has_launch_group(&self) -> bool {
        self.launch_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_group(&mut self, v: Offer_Operation_LaunchGroup) {
        self.launch_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_launch_group(&mut self) -> &mut Offer_Operation_LaunchGroup {
        if self.launch_group.is_none() {
            self.launch_group.set_default();
        }
        self.launch_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_launch_group(&mut self) -> Offer_Operation_LaunchGroup {
        self.launch_group.take().unwrap_or_else(|| Offer_Operation_LaunchGroup::new())
    }

    pub fn get_launch_group(&self) -> &Offer_Operation_LaunchGroup {
        self.launch_group.as_ref().unwrap_or_else(|| Offer_Operation_LaunchGroup::default_instance())
    }

    fn get_launch_group_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_LaunchGroup> {
        &self.launch_group
    }

    fn mut_launch_group_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_LaunchGroup> {
        &mut self.launch_group
    }

    // optional .mesos.v1.Offer.Operation.Reserve reserve = 3;

    pub fn clear_reserve(&mut self) {
        self.reserve.clear();
    }

    pub fn has_reserve(&self) -> bool {
        self.reserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserve(&mut self, v: Offer_Operation_Reserve) {
        self.reserve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserve(&mut self) -> &mut Offer_Operation_Reserve {
        if self.reserve.is_none() {
            self.reserve.set_default();
        }
        self.reserve.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserve(&mut self) -> Offer_Operation_Reserve {
        self.reserve.take().unwrap_or_else(|| Offer_Operation_Reserve::new())
    }

    pub fn get_reserve(&self) -> &Offer_Operation_Reserve {
        self.reserve.as_ref().unwrap_or_else(|| Offer_Operation_Reserve::default_instance())
    }

    fn get_reserve_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_Reserve> {
        &self.reserve
    }

    fn mut_reserve_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_Reserve> {
        &mut self.reserve
    }

    // optional .mesos.v1.Offer.Operation.Unreserve unreserve = 4;

    pub fn clear_unreserve(&mut self) {
        self.unreserve.clear();
    }

    pub fn has_unreserve(&self) -> bool {
        self.unreserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreserve(&mut self, v: Offer_Operation_Unreserve) {
        self.unreserve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unreserve(&mut self) -> &mut Offer_Operation_Unreserve {
        if self.unreserve.is_none() {
            self.unreserve.set_default();
        }
        self.unreserve.as_mut().unwrap()
    }

    // Take field
    pub fn take_unreserve(&mut self) -> Offer_Operation_Unreserve {
        self.unreserve.take().unwrap_or_else(|| Offer_Operation_Unreserve::new())
    }

    pub fn get_unreserve(&self) -> &Offer_Operation_Unreserve {
        self.unreserve.as_ref().unwrap_or_else(|| Offer_Operation_Unreserve::default_instance())
    }

    fn get_unreserve_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_Unreserve> {
        &self.unreserve
    }

    fn mut_unreserve_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_Unreserve> {
        &mut self.unreserve
    }

    // optional .mesos.v1.Offer.Operation.Create create = 5;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: Offer_Operation_Create) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut Offer_Operation_Create {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> Offer_Operation_Create {
        self.create.take().unwrap_or_else(|| Offer_Operation_Create::new())
    }

    pub fn get_create(&self) -> &Offer_Operation_Create {
        self.create.as_ref().unwrap_or_else(|| Offer_Operation_Create::default_instance())
    }

    fn get_create_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_Create> {
        &self.create
    }

    fn mut_create_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_Create> {
        &mut self.create
    }

    // optional .mesos.v1.Offer.Operation.Destroy destroy = 6;

    pub fn clear_destroy(&mut self) {
        self.destroy.clear();
    }

    pub fn has_destroy(&self) -> bool {
        self.destroy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy(&mut self, v: Offer_Operation_Destroy) {
        self.destroy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy(&mut self) -> &mut Offer_Operation_Destroy {
        if self.destroy.is_none() {
            self.destroy.set_default();
        }
        self.destroy.as_mut().unwrap()
    }

    // Take field
    pub fn take_destroy(&mut self) -> Offer_Operation_Destroy {
        self.destroy.take().unwrap_or_else(|| Offer_Operation_Destroy::new())
    }

    pub fn get_destroy(&self) -> &Offer_Operation_Destroy {
        self.destroy.as_ref().unwrap_or_else(|| Offer_Operation_Destroy::default_instance())
    }

    fn get_destroy_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_Destroy> {
        &self.destroy
    }

    fn mut_destroy_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_Destroy> {
        &mut self.destroy
    }

    // optional .mesos.v1.Offer.Operation.CreateVolume create_volume = 8;

    pub fn clear_create_volume(&mut self) {
        self.create_volume.clear();
    }

    pub fn has_create_volume(&self) -> bool {
        self.create_volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_volume(&mut self, v: Offer_Operation_CreateVolume) {
        self.create_volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_volume(&mut self) -> &mut Offer_Operation_CreateVolume {
        if self.create_volume.is_none() {
            self.create_volume.set_default();
        }
        self.create_volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_volume(&mut self) -> Offer_Operation_CreateVolume {
        self.create_volume.take().unwrap_or_else(|| Offer_Operation_CreateVolume::new())
    }

    pub fn get_create_volume(&self) -> &Offer_Operation_CreateVolume {
        self.create_volume.as_ref().unwrap_or_else(|| Offer_Operation_CreateVolume::default_instance())
    }

    fn get_create_volume_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_CreateVolume> {
        &self.create_volume
    }

    fn mut_create_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_CreateVolume> {
        &mut self.create_volume
    }

    // optional .mesos.v1.Offer.Operation.DestroyVolume destroy_volume = 9;

    pub fn clear_destroy_volume(&mut self) {
        self.destroy_volume.clear();
    }

    pub fn has_destroy_volume(&self) -> bool {
        self.destroy_volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_volume(&mut self, v: Offer_Operation_DestroyVolume) {
        self.destroy_volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_volume(&mut self) -> &mut Offer_Operation_DestroyVolume {
        if self.destroy_volume.is_none() {
            self.destroy_volume.set_default();
        }
        self.destroy_volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_destroy_volume(&mut self) -> Offer_Operation_DestroyVolume {
        self.destroy_volume.take().unwrap_or_else(|| Offer_Operation_DestroyVolume::new())
    }

    pub fn get_destroy_volume(&self) -> &Offer_Operation_DestroyVolume {
        self.destroy_volume.as_ref().unwrap_or_else(|| Offer_Operation_DestroyVolume::default_instance())
    }

    fn get_destroy_volume_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_DestroyVolume> {
        &self.destroy_volume
    }

    fn mut_destroy_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_DestroyVolume> {
        &mut self.destroy_volume
    }

    // optional .mesos.v1.Offer.Operation.CreateBlock create_block = 10;

    pub fn clear_create_block(&mut self) {
        self.create_block.clear();
    }

    pub fn has_create_block(&self) -> bool {
        self.create_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_block(&mut self, v: Offer_Operation_CreateBlock) {
        self.create_block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_block(&mut self) -> &mut Offer_Operation_CreateBlock {
        if self.create_block.is_none() {
            self.create_block.set_default();
        }
        self.create_block.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_block(&mut self) -> Offer_Operation_CreateBlock {
        self.create_block.take().unwrap_or_else(|| Offer_Operation_CreateBlock::new())
    }

    pub fn get_create_block(&self) -> &Offer_Operation_CreateBlock {
        self.create_block.as_ref().unwrap_or_else(|| Offer_Operation_CreateBlock::default_instance())
    }

    fn get_create_block_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_CreateBlock> {
        &self.create_block
    }

    fn mut_create_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_CreateBlock> {
        &mut self.create_block
    }

    // optional .mesos.v1.Offer.Operation.DestroyBlock destroy_block = 11;

    pub fn clear_destroy_block(&mut self) {
        self.destroy_block.clear();
    }

    pub fn has_destroy_block(&self) -> bool {
        self.destroy_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_block(&mut self, v: Offer_Operation_DestroyBlock) {
        self.destroy_block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_block(&mut self) -> &mut Offer_Operation_DestroyBlock {
        if self.destroy_block.is_none() {
            self.destroy_block.set_default();
        }
        self.destroy_block.as_mut().unwrap()
    }

    // Take field
    pub fn take_destroy_block(&mut self) -> Offer_Operation_DestroyBlock {
        self.destroy_block.take().unwrap_or_else(|| Offer_Operation_DestroyBlock::new())
    }

    pub fn get_destroy_block(&self) -> &Offer_Operation_DestroyBlock {
        self.destroy_block.as_ref().unwrap_or_else(|| Offer_Operation_DestroyBlock::default_instance())
    }

    fn get_destroy_block_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation_DestroyBlock> {
        &self.destroy_block
    }

    fn mut_destroy_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation_DestroyBlock> {
        &mut self.destroy_block
    }
}

impl ::protobuf::Message for Offer_Operation {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.launch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.launch_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserve {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unreserve {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_volume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_volume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.launch)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.launch_group)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reserve)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unreserve)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destroy)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_volume)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destroy_volume)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_block)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destroy_block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.launch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.launch_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reserve.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unreserve.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destroy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create_volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destroy_volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create_block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destroy_block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.launch.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.launch_group.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reserve.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unreserve.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destroy.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create_volume.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destroy_volume.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create_block.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destroy_block.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation {
    fn new() -> Offer_Operation {
        Offer_Operation::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Offer_Operation_Type>>(
                    "type",
                    Offer_Operation::get_field_type_for_reflect,
                    Offer_Operation::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationID>>(
                    "id",
                    Offer_Operation::get_id_for_reflect,
                    Offer_Operation::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_Launch>>(
                    "launch",
                    Offer_Operation::get_launch_for_reflect,
                    Offer_Operation::mut_launch_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_LaunchGroup>>(
                    "launch_group",
                    Offer_Operation::get_launch_group_for_reflect,
                    Offer_Operation::mut_launch_group_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_Reserve>>(
                    "reserve",
                    Offer_Operation::get_reserve_for_reflect,
                    Offer_Operation::mut_reserve_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_Unreserve>>(
                    "unreserve",
                    Offer_Operation::get_unreserve_for_reflect,
                    Offer_Operation::mut_unreserve_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_Create>>(
                    "create",
                    Offer_Operation::get_create_for_reflect,
                    Offer_Operation::mut_create_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_Destroy>>(
                    "destroy",
                    Offer_Operation::get_destroy_for_reflect,
                    Offer_Operation::mut_destroy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_CreateVolume>>(
                    "create_volume",
                    Offer_Operation::get_create_volume_for_reflect,
                    Offer_Operation::mut_create_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_DestroyVolume>>(
                    "destroy_volume",
                    Offer_Operation::get_destroy_volume_for_reflect,
                    Offer_Operation::mut_destroy_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_CreateBlock>>(
                    "create_block",
                    Offer_Operation::get_create_block_for_reflect,
                    Offer_Operation::mut_create_block_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation_DestroyBlock>>(
                    "destroy_block",
                    Offer_Operation::get_destroy_block_for_reflect,
                    Offer_Operation::mut_destroy_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation>(
                    "Offer_Operation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_id();
        self.clear_launch();
        self.clear_launch_group();
        self.clear_reserve();
        self.clear_unreserve();
        self.clear_create();
        self.clear_destroy();
        self.clear_create_volume();
        self.clear_destroy_volume();
        self.clear_create_block();
        self.clear_destroy_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_Launch {
    // message fields
    task_infos: ::protobuf::RepeatedField<TaskInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Launch {}

impl Offer_Operation_Launch {
    pub fn new() -> Offer_Operation_Launch {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Launch {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Launch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Launch,
        };
        unsafe {
            instance.get(Offer_Operation_Launch::new)
        }
    }

    // repeated .mesos.v1.TaskInfo task_infos = 1;

    pub fn clear_task_infos(&mut self) {
        self.task_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_infos(&mut self, v: ::protobuf::RepeatedField<TaskInfo>) {
        self.task_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_task_infos(&mut self) -> &mut ::protobuf::RepeatedField<TaskInfo> {
        &mut self.task_infos
    }

    // Take field
    pub fn take_task_infos(&mut self) -> ::protobuf::RepeatedField<TaskInfo> {
        ::std::mem::replace(&mut self.task_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_task_infos(&self) -> &[TaskInfo] {
        &self.task_infos
    }

    fn get_task_infos_for_reflect(&self) -> &::protobuf::RepeatedField<TaskInfo> {
        &self.task_infos
    }

    fn mut_task_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TaskInfo> {
        &mut self.task_infos
    }
}

impl ::protobuf::Message for Offer_Operation_Launch {
    fn is_initialized(&self) -> bool {
        for v in &self.task_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.task_infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.task_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.task_infos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Launch {
    fn new() -> Offer_Operation_Launch {
        Offer_Operation_Launch::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Launch>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskInfo>>(
                    "task_infos",
                    Offer_Operation_Launch::get_task_infos_for_reflect,
                    Offer_Operation_Launch::mut_task_infos_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Launch>(
                    "Offer_Operation_Launch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Launch {
    fn clear(&mut self) {
        self.clear_task_infos();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_Launch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_Launch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_LaunchGroup {
    // message fields
    executor: ::protobuf::SingularPtrField<ExecutorInfo>,
    task_group: ::protobuf::SingularPtrField<TaskGroupInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_LaunchGroup {}

impl Offer_Operation_LaunchGroup {
    pub fn new() -> Offer_Operation_LaunchGroup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_LaunchGroup {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_LaunchGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_LaunchGroup,
        };
        unsafe {
            instance.get(Offer_Operation_LaunchGroup::new)
        }
    }

    // required .mesos.v1.ExecutorInfo executor = 1;

    pub fn clear_executor(&mut self) {
        self.executor.clear();
    }

    pub fn has_executor(&self) -> bool {
        self.executor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor(&mut self, v: ExecutorInfo) {
        self.executor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor(&mut self) -> &mut ExecutorInfo {
        if self.executor.is_none() {
            self.executor.set_default();
        }
        self.executor.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor(&mut self) -> ExecutorInfo {
        self.executor.take().unwrap_or_else(|| ExecutorInfo::new())
    }

    pub fn get_executor(&self) -> &ExecutorInfo {
        self.executor.as_ref().unwrap_or_else(|| ExecutorInfo::default_instance())
    }

    fn get_executor_for_reflect(&self) -> &::protobuf::SingularPtrField<ExecutorInfo> {
        &self.executor
    }

    fn mut_executor_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ExecutorInfo> {
        &mut self.executor
    }

    // required .mesos.v1.TaskGroupInfo task_group = 2;

    pub fn clear_task_group(&mut self) {
        self.task_group.clear();
    }

    pub fn has_task_group(&self) -> bool {
        self.task_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_group(&mut self, v: TaskGroupInfo) {
        self.task_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_group(&mut self) -> &mut TaskGroupInfo {
        if self.task_group.is_none() {
            self.task_group.set_default();
        }
        self.task_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_group(&mut self) -> TaskGroupInfo {
        self.task_group.take().unwrap_or_else(|| TaskGroupInfo::new())
    }

    pub fn get_task_group(&self) -> &TaskGroupInfo {
        self.task_group.as_ref().unwrap_or_else(|| TaskGroupInfo::default_instance())
    }

    fn get_task_group_for_reflect(&self) -> &::protobuf::SingularPtrField<TaskGroupInfo> {
        &self.task_group
    }

    fn mut_task_group_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TaskGroupInfo> {
        &mut self.task_group
    }
}

impl ::protobuf::Message for Offer_Operation_LaunchGroup {
    fn is_initialized(&self) -> bool {
        if self.executor.is_none() {
            return false;
        }
        if self.task_group.is_none() {
            return false;
        }
        for v in &self.executor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.task_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.executor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.task_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.executor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.task_group.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_LaunchGroup {
    fn new() -> Offer_Operation_LaunchGroup {
        Offer_Operation_LaunchGroup::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_LaunchGroup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorInfo>>(
                    "executor",
                    Offer_Operation_LaunchGroup::get_executor_for_reflect,
                    Offer_Operation_LaunchGroup::mut_executor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskGroupInfo>>(
                    "task_group",
                    Offer_Operation_LaunchGroup::get_task_group_for_reflect,
                    Offer_Operation_LaunchGroup::mut_task_group_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_LaunchGroup>(
                    "Offer_Operation_LaunchGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_LaunchGroup {
    fn clear(&mut self) {
        self.clear_executor();
        self.clear_task_group();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_LaunchGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_LaunchGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_Reserve {
    // message fields
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Reserve {}

impl Offer_Operation_Reserve {
    pub fn new() -> Offer_Operation_Reserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Reserve {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Reserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Reserve,
        };
        unsafe {
            instance.get(Offer_Operation_Reserve::new)
        }
    }

    // repeated .mesos.v1.Resource resources = 1;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }
}

impl ::protobuf::Message for Offer_Operation_Reserve {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Reserve {
    fn new() -> Offer_Operation_Reserve {
        Offer_Operation_Reserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Reserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    Offer_Operation_Reserve::get_resources_for_reflect,
                    Offer_Operation_Reserve::mut_resources_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Reserve>(
                    "Offer_Operation_Reserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Reserve {
    fn clear(&mut self) {
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_Reserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_Reserve {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_Unreserve {
    // message fields
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Unreserve {}

impl Offer_Operation_Unreserve {
    pub fn new() -> Offer_Operation_Unreserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Unreserve {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Unreserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Unreserve,
        };
        unsafe {
            instance.get(Offer_Operation_Unreserve::new)
        }
    }

    // repeated .mesos.v1.Resource resources = 1;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }
}

impl ::protobuf::Message for Offer_Operation_Unreserve {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Unreserve {
    fn new() -> Offer_Operation_Unreserve {
        Offer_Operation_Unreserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Unreserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    Offer_Operation_Unreserve::get_resources_for_reflect,
                    Offer_Operation_Unreserve::mut_resources_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Unreserve>(
                    "Offer_Operation_Unreserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Unreserve {
    fn clear(&mut self) {
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_Unreserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_Unreserve {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_Create {
    // message fields
    volumes: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Create {}

impl Offer_Operation_Create {
    pub fn new() -> Offer_Operation_Create {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Create {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Create,
        };
        unsafe {
            instance.get(Offer_Operation_Create::new)
        }
    }

    // repeated .mesos.v1.Resource volumes = 1;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes(&self) -> &[Resource] {
        &self.volumes
    }

    fn get_volumes_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.volumes
    }

    fn mut_volumes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }
}

impl ::protobuf::Message for Offer_Operation_Create {
    fn is_initialized(&self) -> bool {
        for v in &self.volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.volumes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Create {
    fn new() -> Offer_Operation_Create {
        Offer_Operation_Create::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Create>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "volumes",
                    Offer_Operation_Create::get_volumes_for_reflect,
                    Offer_Operation_Create::mut_volumes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Create>(
                    "Offer_Operation_Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Create {
    fn clear(&mut self) {
        self.clear_volumes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_Destroy {
    // message fields
    volumes: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Destroy {}

impl Offer_Operation_Destroy {
    pub fn new() -> Offer_Operation_Destroy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Destroy {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Destroy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Destroy,
        };
        unsafe {
            instance.get(Offer_Operation_Destroy::new)
        }
    }

    // repeated .mesos.v1.Resource volumes = 1;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes(&self) -> &[Resource] {
        &self.volumes
    }

    fn get_volumes_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.volumes
    }

    fn mut_volumes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }
}

impl ::protobuf::Message for Offer_Operation_Destroy {
    fn is_initialized(&self) -> bool {
        for v in &self.volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.volumes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Destroy {
    fn new() -> Offer_Operation_Destroy {
        Offer_Operation_Destroy::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Destroy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "volumes",
                    Offer_Operation_Destroy::get_volumes_for_reflect,
                    Offer_Operation_Destroy::mut_volumes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Destroy>(
                    "Offer_Operation_Destroy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Destroy {
    fn clear(&mut self) {
        self.clear_volumes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_Destroy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_Destroy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_CreateVolume {
    // message fields
    source: ::protobuf::SingularPtrField<Resource>,
    target_type: ::std::option::Option<Resource_DiskInfo_Source_Type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_CreateVolume {}

impl Offer_Operation_CreateVolume {
    pub fn new() -> Offer_Operation_CreateVolume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_CreateVolume {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_CreateVolume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_CreateVolume,
        };
        unsafe {
            instance.get(Offer_Operation_CreateVolume::new)
        }
    }

    // required .mesos.v1.Resource source = 1;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Resource) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Resource {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Resource {
        self.source.take().unwrap_or_else(|| Resource::new())
    }

    pub fn get_source(&self) -> &Resource {
        self.source.as_ref().unwrap_or_else(|| Resource::default_instance())
    }

    fn get_source_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource> {
        &mut self.source
    }

    // required .mesos.v1.Resource.DiskInfo.Source.Type target_type = 2;

    pub fn clear_target_type(&mut self) {
        self.target_type = ::std::option::Option::None;
    }

    pub fn has_target_type(&self) -> bool {
        self.target_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_type(&mut self, v: Resource_DiskInfo_Source_Type) {
        self.target_type = ::std::option::Option::Some(v);
    }

    pub fn get_target_type(&self) -> Resource_DiskInfo_Source_Type {
        self.target_type.unwrap_or(Resource_DiskInfo_Source_Type::UNKNOWN)
    }

    fn get_target_type_for_reflect(&self) -> &::std::option::Option<Resource_DiskInfo_Source_Type> {
        &self.target_type
    }

    fn mut_target_type_for_reflect(&mut self) -> &mut ::std::option::Option<Resource_DiskInfo_Source_Type> {
        &mut self.target_type
    }
}

impl ::protobuf::Message for Offer_Operation_CreateVolume {
    fn is_initialized(&self) -> bool {
        if self.source.is_none() {
            return false;
        }
        if self.target_type.is_none() {
            return false;
        }
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.target_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.target_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.target_type {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_CreateVolume {
    fn new() -> Offer_Operation_CreateVolume {
        Offer_Operation_CreateVolume::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_CreateVolume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "source",
                    Offer_Operation_CreateVolume::get_source_for_reflect,
                    Offer_Operation_CreateVolume::mut_source_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Resource_DiskInfo_Source_Type>>(
                    "target_type",
                    Offer_Operation_CreateVolume::get_target_type_for_reflect,
                    Offer_Operation_CreateVolume::mut_target_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_CreateVolume>(
                    "Offer_Operation_CreateVolume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_CreateVolume {
    fn clear(&mut self) {
        self.clear_source();
        self.clear_target_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_CreateVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_CreateVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_DestroyVolume {
    // message fields
    volume: ::protobuf::SingularPtrField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_DestroyVolume {}

impl Offer_Operation_DestroyVolume {
    pub fn new() -> Offer_Operation_DestroyVolume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_DestroyVolume {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_DestroyVolume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_DestroyVolume,
        };
        unsafe {
            instance.get(Offer_Operation_DestroyVolume::new)
        }
    }

    // required .mesos.v1.Resource volume = 1;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: Resource) {
        self.volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut Resource {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> Resource {
        self.volume.take().unwrap_or_else(|| Resource::new())
    }

    pub fn get_volume(&self) -> &Resource {
        self.volume.as_ref().unwrap_or_else(|| Resource::default_instance())
    }

    fn get_volume_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource> {
        &self.volume
    }

    fn mut_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource> {
        &mut self.volume
    }
}

impl ::protobuf::Message for Offer_Operation_DestroyVolume {
    fn is_initialized(&self) -> bool {
        if self.volume.is_none() {
            return false;
        }
        for v in &self.volume {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volume.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_DestroyVolume {
    fn new() -> Offer_Operation_DestroyVolume {
        Offer_Operation_DestroyVolume::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_DestroyVolume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "volume",
                    Offer_Operation_DestroyVolume::get_volume_for_reflect,
                    Offer_Operation_DestroyVolume::mut_volume_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_DestroyVolume>(
                    "Offer_Operation_DestroyVolume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_DestroyVolume {
    fn clear(&mut self) {
        self.clear_volume();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_DestroyVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_DestroyVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_CreateBlock {
    // message fields
    source: ::protobuf::SingularPtrField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_CreateBlock {}

impl Offer_Operation_CreateBlock {
    pub fn new() -> Offer_Operation_CreateBlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_CreateBlock {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_CreateBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_CreateBlock,
        };
        unsafe {
            instance.get(Offer_Operation_CreateBlock::new)
        }
    }

    // required .mesos.v1.Resource source = 1;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Resource) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Resource {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Resource {
        self.source.take().unwrap_or_else(|| Resource::new())
    }

    pub fn get_source(&self) -> &Resource {
        self.source.as_ref().unwrap_or_else(|| Resource::default_instance())
    }

    fn get_source_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource> {
        &mut self.source
    }
}

impl ::protobuf::Message for Offer_Operation_CreateBlock {
    fn is_initialized(&self) -> bool {
        if self.source.is_none() {
            return false;
        }
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_CreateBlock {
    fn new() -> Offer_Operation_CreateBlock {
        Offer_Operation_CreateBlock::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_CreateBlock>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "source",
                    Offer_Operation_CreateBlock::get_source_for_reflect,
                    Offer_Operation_CreateBlock::mut_source_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_CreateBlock>(
                    "Offer_Operation_CreateBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_CreateBlock {
    fn clear(&mut self) {
        self.clear_source();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_CreateBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_CreateBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Offer_Operation_DestroyBlock {
    // message fields
    block: ::protobuf::SingularPtrField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_DestroyBlock {}

impl Offer_Operation_DestroyBlock {
    pub fn new() -> Offer_Operation_DestroyBlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_DestroyBlock {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_DestroyBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_DestroyBlock,
        };
        unsafe {
            instance.get(Offer_Operation_DestroyBlock::new)
        }
    }

    // required .mesos.v1.Resource block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Resource) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut Resource {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> Resource {
        self.block.take().unwrap_or_else(|| Resource::new())
    }

    pub fn get_block(&self) -> &Resource {
        self.block.as_ref().unwrap_or_else(|| Resource::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<Resource> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Resource> {
        &mut self.block
    }
}

impl ::protobuf::Message for Offer_Operation_DestroyBlock {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_DestroyBlock {
    fn new() -> Offer_Operation_DestroyBlock {
        Offer_Operation_DestroyBlock::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_DestroyBlock>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "block",
                    Offer_Operation_DestroyBlock::get_block_for_reflect,
                    Offer_Operation_DestroyBlock::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_DestroyBlock>(
                    "Offer_Operation_DestroyBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_DestroyBlock {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer_Operation_DestroyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_DestroyBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Offer_Operation_Type {
    UNKNOWN = 0,
    LAUNCH = 1,
    LAUNCH_GROUP = 6,
    RESERVE = 2,
    UNRESERVE = 3,
    CREATE = 4,
    DESTROY = 5,
    CREATE_VOLUME = 7,
    DESTROY_VOLUME = 8,
    CREATE_BLOCK = 9,
    DESTROY_BLOCK = 10,
}

impl ::protobuf::ProtobufEnum for Offer_Operation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Offer_Operation_Type> {
        match value {
            0 => ::std::option::Option::Some(Offer_Operation_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Offer_Operation_Type::LAUNCH),
            6 => ::std::option::Option::Some(Offer_Operation_Type::LAUNCH_GROUP),
            2 => ::std::option::Option::Some(Offer_Operation_Type::RESERVE),
            3 => ::std::option::Option::Some(Offer_Operation_Type::UNRESERVE),
            4 => ::std::option::Option::Some(Offer_Operation_Type::CREATE),
            5 => ::std::option::Option::Some(Offer_Operation_Type::DESTROY),
            7 => ::std::option::Option::Some(Offer_Operation_Type::CREATE_VOLUME),
            8 => ::std::option::Option::Some(Offer_Operation_Type::DESTROY_VOLUME),
            9 => ::std::option::Option::Some(Offer_Operation_Type::CREATE_BLOCK),
            10 => ::std::option::Option::Some(Offer_Operation_Type::DESTROY_BLOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Offer_Operation_Type] = &[
            Offer_Operation_Type::UNKNOWN,
            Offer_Operation_Type::LAUNCH,
            Offer_Operation_Type::LAUNCH_GROUP,
            Offer_Operation_Type::RESERVE,
            Offer_Operation_Type::UNRESERVE,
            Offer_Operation_Type::CREATE,
            Offer_Operation_Type::DESTROY,
            Offer_Operation_Type::CREATE_VOLUME,
            Offer_Operation_Type::DESTROY_VOLUME,
            Offer_Operation_Type::CREATE_BLOCK,
            Offer_Operation_Type::DESTROY_BLOCK,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Offer_Operation_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Offer_Operation_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Offer_Operation_Type {
}

impl ::protobuf::reflect::ProtobufValue for Offer_Operation_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InverseOffer {
    // message fields
    id: ::protobuf::SingularPtrField<OfferID>,
    url: ::protobuf::SingularPtrField<URL>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    unavailability: ::protobuf::SingularPtrField<Unavailability>,
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for InverseOffer {}

impl InverseOffer {
    pub fn new() -> InverseOffer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static InverseOffer {
        static mut instance: ::protobuf::lazy::Lazy<InverseOffer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InverseOffer,
        };
        unsafe {
            instance.get(InverseOffer::new)
        }
    }

    // required .mesos.v1.OfferID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: OfferID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut OfferID {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> OfferID {
        self.id.take().unwrap_or_else(|| OfferID::new())
    }

    pub fn get_id(&self) -> &OfferID {
        self.id.as_ref().unwrap_or_else(|| OfferID::default_instance())
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularPtrField<OfferID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OfferID> {
        &mut self.id
    }

    // optional .mesos.v1.URL url = 2;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: URL) {
        self.url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut URL {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> URL {
        self.url.take().unwrap_or_else(|| URL::new())
    }

    pub fn get_url(&self) -> &URL {
        self.url.as_ref().unwrap_or_else(|| URL::default_instance())
    }

    fn get_url_for_reflect(&self) -> &::protobuf::SingularPtrField<URL> {
        &self.url
    }

    fn mut_url_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<URL> {
        &mut self.url
    }

    // required .mesos.v1.FrameworkID framework_id = 3;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id(&mut self) -> &mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        }
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id(&self) -> &FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    fn get_framework_id_for_reflect(&self) -> &::protobuf::SingularPtrField<FrameworkID> {
        &self.framework_id
    }

    fn mut_framework_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FrameworkID> {
        &mut self.framework_id
    }

    // optional .mesos.v1.AgentID agent_id = 4;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id(&mut self) -> &mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        }
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id(&self) -> &AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_agent_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.agent_id
    }

    fn mut_agent_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.agent_id
    }

    // required .mesos.v1.Unavailability unavailability = 5;

    pub fn clear_unavailability(&mut self) {
        self.unavailability.clear();
    }

    pub fn has_unavailability(&self) -> bool {
        self.unavailability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailability(&mut self, v: Unavailability) {
        self.unavailability = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unavailability(&mut self) -> &mut Unavailability {
        if self.unavailability.is_none() {
            self.unavailability.set_default();
        }
        self.unavailability.as_mut().unwrap()
    }

    // Take field
    pub fn take_unavailability(&mut self) -> Unavailability {
        self.unavailability.take().unwrap_or_else(|| Unavailability::new())
    }

    pub fn get_unavailability(&self) -> &Unavailability {
        self.unavailability.as_ref().unwrap_or_else(|| Unavailability::default_instance())
    }

    fn get_unavailability_for_reflect(&self) -> &::protobuf::SingularPtrField<Unavailability> {
        &self.unavailability
    }

    fn mut_unavailability_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Unavailability> {
        &mut self.unavailability
    }

    // repeated .mesos.v1.Resource resources = 6;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }
}

impl ::protobuf::Message for InverseOffer {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.framework_id.is_none() {
            return false;
        }
        if self.unavailability.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.framework_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.agent_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unavailability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unavailability)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unavailability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unavailability.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resources {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for InverseOffer {
    fn new() -> InverseOffer {
        InverseOffer::new()
    }

    fn descriptor_static(_: ::std::option::Option<InverseOffer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferID>>(
                    "id",
                    InverseOffer::get_id_for_reflect,
                    InverseOffer::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<URL>>(
                    "url",
                    InverseOffer::get_url_for_reflect,
                    InverseOffer::mut_url_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkID>>(
                    "framework_id",
                    InverseOffer::get_framework_id_for_reflect,
                    InverseOffer::mut_framework_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "agent_id",
                    InverseOffer::get_agent_id_for_reflect,
                    InverseOffer::mut_agent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unavailability>>(
                    "unavailability",
                    InverseOffer::get_unavailability_for_reflect,
                    InverseOffer::mut_unavailability_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    InverseOffer::get_resources_for_reflect,
                    InverseOffer::mut_resources_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InverseOffer>(
                    "InverseOffer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for InverseOffer {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_url();
        self.clear_framework_id();
        self.clear_agent_id();
        self.clear_unavailability();
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InverseOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InverseOffer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskInfo {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    task_id: ::protobuf::SingularPtrField<TaskID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    resources: ::protobuf::RepeatedField<Resource>,
    executor: ::protobuf::SingularPtrField<ExecutorInfo>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    health_check: ::protobuf::SingularPtrField<HealthCheck>,
    check: ::protobuf::SingularPtrField<CheckInfo>,
    kill_policy: ::protobuf::SingularPtrField<KillPolicy>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    labels: ::protobuf::SingularPtrField<Labels>,
    discovery: ::protobuf::SingularPtrField<DiscoveryInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskInfo {}

impl TaskInfo {
    pub fn new() -> TaskInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskInfo {
        static mut instance: ::protobuf::lazy::Lazy<TaskInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskInfo,
        };
        unsafe {
            instance.get(TaskInfo::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required .mesos.v1.TaskID task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        }
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id(&self) -> &TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    fn get_task_id_for_reflect(&self) -> &::protobuf::SingularPtrField<TaskID> {
        &self.task_id
    }

    fn mut_task_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TaskID> {
        &mut self.task_id
    }

    // required .mesos.v1.AgentID agent_id = 3;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id(&mut self) -> &mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        }
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id(&self) -> &AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_agent_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.agent_id
    }

    fn mut_agent_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.agent_id
    }

    // repeated .mesos.v1.Resource resources = 4;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // optional .mesos.v1.ExecutorInfo executor = 5;

    pub fn clear_executor(&mut self) {
        self.executor.clear();
    }

    pub fn has_executor(&self) -> bool {
        self.executor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor(&mut self, v: ExecutorInfo) {
        self.executor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor(&mut self) -> &mut ExecutorInfo {
        if self.executor.is_none() {
            self.executor.set_default();
        }
        self.executor.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor(&mut self) -> ExecutorInfo {
        self.executor.take().unwrap_or_else(|| ExecutorInfo::new())
    }

    pub fn get_executor(&self) -> &ExecutorInfo {
        self.executor.as_ref().unwrap_or_else(|| ExecutorInfo::default_instance())
    }

    fn get_executor_for_reflect(&self) -> &::protobuf::SingularPtrField<ExecutorInfo> {
        &self.executor
    }

    fn mut_executor_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ExecutorInfo> {
        &mut self.executor
    }

    // optional .mesos.v1.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command(&self) -> &CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    fn get_command_for_reflect(&self) -> &::protobuf::SingularPtrField<CommandInfo> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CommandInfo> {
        &mut self.command
    }

    // optional .mesos.v1.ContainerInfo container = 9;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container(&self) -> &ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    fn get_container_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerInfo> {
        &self.container
    }

    fn mut_container_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerInfo> {
        &mut self.container
    }

    // optional .mesos.v1.HealthCheck health_check = 8;

    pub fn clear_health_check(&mut self) {
        self.health_check.clear();
    }

    pub fn has_health_check(&self) -> bool {
        self.health_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_check(&mut self, v: HealthCheck) {
        self.health_check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_health_check(&mut self) -> &mut HealthCheck {
        if self.health_check.is_none() {
            self.health_check.set_default();
        }
        self.health_check.as_mut().unwrap()
    }

    // Take field
    pub fn take_health_check(&mut self) -> HealthCheck {
        self.health_check.take().unwrap_or_else(|| HealthCheck::new())
    }

    pub fn get_health_check(&self) -> &HealthCheck {
        self.health_check.as_ref().unwrap_or_else(|| HealthCheck::default_instance())
    }

    fn get_health_check_for_reflect(&self) -> &::protobuf::SingularPtrField<HealthCheck> {
        &self.health_check
    }

    fn mut_health_check_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<HealthCheck> {
        &mut self.health_check
    }

    // optional .mesos.v1.CheckInfo check = 13;

    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    pub fn has_check(&self) -> bool {
        self.check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: CheckInfo) {
        self.check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut CheckInfo {
        if self.check.is_none() {
            self.check.set_default();
        }
        self.check.as_mut().unwrap()
    }

    // Take field
    pub fn take_check(&mut self) -> CheckInfo {
        self.check.take().unwrap_or_else(|| CheckInfo::new())
    }

    pub fn get_check(&self) -> &CheckInfo {
        self.check.as_ref().unwrap_or_else(|| CheckInfo::default_instance())
    }

    fn get_check_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckInfo> {
        &self.check
    }

    fn mut_check_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckInfo> {
        &mut self.check
    }

    // optional .mesos.v1.KillPolicy kill_policy = 12;

    pub fn clear_kill_policy(&mut self) {
        self.kill_policy.clear();
    }

    pub fn has_kill_policy(&self) -> bool {
        self.kill_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_policy(&mut self, v: KillPolicy) {
        self.kill_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kill_policy(&mut self) -> &mut KillPolicy {
        if self.kill_policy.is_none() {
            self.kill_policy.set_default();
        }
        self.kill_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_kill_policy(&mut self) -> KillPolicy {
        self.kill_policy.take().unwrap_or_else(|| KillPolicy::new())
    }

    pub fn get_kill_policy(&self) -> &KillPolicy {
        self.kill_policy.as_ref().unwrap_or_else(|| KillPolicy::default_instance())
    }

    fn get_kill_policy_for_reflect(&self) -> &::protobuf::SingularPtrField<KillPolicy> {
        &self.kill_policy
    }

    fn mut_kill_policy_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<KillPolicy> {
        &mut self.kill_policy
    }

    // optional bytes data = 6;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }

    // optional .mesos.v1.Labels labels = 10;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }

    // optional .mesos.v1.DiscoveryInfo discovery = 11;

    pub fn clear_discovery(&mut self) {
        self.discovery.clear();
    }

    pub fn has_discovery(&self) -> bool {
        self.discovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery(&mut self, v: DiscoveryInfo) {
        self.discovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery(&mut self) -> &mut DiscoveryInfo {
        if self.discovery.is_none() {
            self.discovery.set_default();
        }
        self.discovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery(&mut self) -> DiscoveryInfo {
        self.discovery.take().unwrap_or_else(|| DiscoveryInfo::new())
    }

    pub fn get_discovery(&self) -> &DiscoveryInfo {
        self.discovery.as_ref().unwrap_or_else(|| DiscoveryInfo::default_instance())
    }

    fn get_discovery_for_reflect(&self) -> &::protobuf::SingularPtrField<DiscoveryInfo> {
        &self.discovery
    }

    fn mut_discovery_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DiscoveryInfo> {
        &mut self.discovery
    }
}

impl ::protobuf::Message for TaskInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.task_id.is_none() {
            return false;
        }
        if self.agent_id.is_none() {
            return false;
        }
        for v in &self.task_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.agent_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.executor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.container {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.health_check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kill_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discovery {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.health_check)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kill_policy)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.discovery)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.task_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.executor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.container.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.health_check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kill_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.discovery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.task_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resources {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.executor.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.health_check.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.check.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kill_policy.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.discovery.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskInfo {
    fn new() -> TaskInfo {
        TaskInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    TaskInfo::get_name_for_reflect,
                    TaskInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskID>>(
                    "task_id",
                    TaskInfo::get_task_id_for_reflect,
                    TaskInfo::mut_task_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "agent_id",
                    TaskInfo::get_agent_id_for_reflect,
                    TaskInfo::mut_agent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    TaskInfo::get_resources_for_reflect,
                    TaskInfo::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorInfo>>(
                    "executor",
                    TaskInfo::get_executor_for_reflect,
                    TaskInfo::mut_executor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandInfo>>(
                    "command",
                    TaskInfo::get_command_for_reflect,
                    TaskInfo::mut_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerInfo>>(
                    "container",
                    TaskInfo::get_container_for_reflect,
                    TaskInfo::mut_container_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck>>(
                    "health_check",
                    TaskInfo::get_health_check_for_reflect,
                    TaskInfo::mut_health_check_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckInfo>>(
                    "check",
                    TaskInfo::get_check_for_reflect,
                    TaskInfo::mut_check_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KillPolicy>>(
                    "kill_policy",
                    TaskInfo::get_kill_policy_for_reflect,
                    TaskInfo::mut_kill_policy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    TaskInfo::get_data_for_reflect,
                    TaskInfo::mut_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    TaskInfo::get_labels_for_reflect,
                    TaskInfo::mut_labels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveryInfo>>(
                    "discovery",
                    TaskInfo::get_discovery_for_reflect,
                    TaskInfo::mut_discovery_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskInfo>(
                    "TaskInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskInfo {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_task_id();
        self.clear_agent_id();
        self.clear_resources();
        self.clear_executor();
        self.clear_command();
        self.clear_container();
        self.clear_health_check();
        self.clear_check();
        self.clear_kill_policy();
        self.clear_data();
        self.clear_labels();
        self.clear_discovery();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskGroupInfo {
    // message fields
    tasks: ::protobuf::RepeatedField<TaskInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskGroupInfo {}

impl TaskGroupInfo {
    pub fn new() -> TaskGroupInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskGroupInfo {
        static mut instance: ::protobuf::lazy::Lazy<TaskGroupInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskGroupInfo,
        };
        unsafe {
            instance.get(TaskGroupInfo::new)
        }
    }

    // repeated .mesos.v1.TaskInfo tasks = 1;

    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<TaskInfo>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<TaskInfo> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<TaskInfo> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }

    pub fn get_tasks(&self) -> &[TaskInfo] {
        &self.tasks
    }

    fn get_tasks_for_reflect(&self) -> &::protobuf::RepeatedField<TaskInfo> {
        &self.tasks
    }

    fn mut_tasks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TaskInfo> {
        &mut self.tasks
    }
}

impl ::protobuf::Message for TaskGroupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tasks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskGroupInfo {
    fn new() -> TaskGroupInfo {
        TaskGroupInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskGroupInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskInfo>>(
                    "tasks",
                    TaskGroupInfo::get_tasks_for_reflect,
                    TaskGroupInfo::mut_tasks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskGroupInfo>(
                    "TaskGroupInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskGroupInfo {
    fn clear(&mut self) {
        self.clear_tasks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskGroupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskGroupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Task {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    task_id: ::protobuf::SingularPtrField<TaskID>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    state: ::std::option::Option<TaskState>,
    resources: ::protobuf::RepeatedField<Resource>,
    statuses: ::protobuf::RepeatedField<TaskStatus>,
    status_update_state: ::std::option::Option<TaskState>,
    status_update_uuid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    labels: ::protobuf::SingularPtrField<Labels>,
    discovery: ::protobuf::SingularPtrField<DiscoveryInfo>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    user: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Task {}

impl Task {
    pub fn new() -> Task {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Task {
        static mut instance: ::protobuf::lazy::Lazy<Task> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Task,
        };
        unsafe {
            instance.get(Task::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required .mesos.v1.TaskID task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        }
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id(&self) -> &TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    fn get_task_id_for_reflect(&self) -> &::protobuf::SingularPtrField<TaskID> {
        &self.task_id
    }

    fn mut_task_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TaskID> {
        &mut self.task_id
    }

    // required .mesos.v1.FrameworkID framework_id = 3;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id(&mut self) -> &mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        }
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id(&self) -> &FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    fn get_framework_id_for_reflect(&self) -> &::protobuf::SingularPtrField<FrameworkID> {
        &self.framework_id
    }

    fn mut_framework_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FrameworkID> {
        &mut self.framework_id
    }

    // optional .mesos.v1.ExecutorID executor_id = 4;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id(&mut self) -> &mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        }
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id(&self) -> &ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    fn get_executor_id_for_reflect(&self) -> &::protobuf::SingularPtrField<ExecutorID> {
        &self.executor_id
    }

    fn mut_executor_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ExecutorID> {
        &mut self.executor_id
    }

    // required .mesos.v1.AgentID agent_id = 5;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id(&mut self) -> &mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        }
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id(&self) -> &AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_agent_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.agent_id
    }

    fn mut_agent_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.agent_id
    }

    // required .mesos.v1.TaskState state = 6;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: TaskState) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state(&self) -> TaskState {
        self.state.unwrap_or(TaskState::TASK_STAGING)
    }

    fn get_state_for_reflect(&self) -> &::std::option::Option<TaskState> {
        &self.state
    }

    fn mut_state_for_reflect(&mut self) -> &mut ::std::option::Option<TaskState> {
        &mut self.state
    }

    // repeated .mesos.v1.Resource resources = 7;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // repeated .mesos.v1.TaskStatus statuses = 8;

    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<TaskStatus>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<TaskStatus> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<TaskStatus> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }

    pub fn get_statuses(&self) -> &[TaskStatus] {
        &self.statuses
    }

    fn get_statuses_for_reflect(&self) -> &::protobuf::RepeatedField<TaskStatus> {
        &self.statuses
    }

    fn mut_statuses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TaskStatus> {
        &mut self.statuses
    }

    // optional .mesos.v1.TaskState status_update_state = 9;

    pub fn clear_status_update_state(&mut self) {
        self.status_update_state = ::std::option::Option::None;
    }

    pub fn has_status_update_state(&self) -> bool {
        self.status_update_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_update_state(&mut self, v: TaskState) {
        self.status_update_state = ::std::option::Option::Some(v);
    }

    pub fn get_status_update_state(&self) -> TaskState {
        self.status_update_state.unwrap_or(TaskState::TASK_STAGING)
    }

    fn get_status_update_state_for_reflect(&self) -> &::std::option::Option<TaskState> {
        &self.status_update_state
    }

    fn mut_status_update_state_for_reflect(&mut self) -> &mut ::std::option::Option<TaskState> {
        &mut self.status_update_state
    }

    // optional bytes status_update_uuid = 10;

    pub fn clear_status_update_uuid(&mut self) {
        self.status_update_uuid.clear();
    }

    pub fn has_status_update_uuid(&self) -> bool {
        self.status_update_uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_update_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.status_update_uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_update_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.status_update_uuid.is_none() {
            self.status_update_uuid.set_default();
        }
        self.status_update_uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_update_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.status_update_uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_status_update_uuid(&self) -> &[u8] {
        match self.status_update_uuid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_status_update_uuid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.status_update_uuid
    }

    fn mut_status_update_uuid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.status_update_uuid
    }

    // optional .mesos.v1.Labels labels = 11;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }

    // optional .mesos.v1.DiscoveryInfo discovery = 12;

    pub fn clear_discovery(&mut self) {
        self.discovery.clear();
    }

    pub fn has_discovery(&self) -> bool {
        self.discovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery(&mut self, v: DiscoveryInfo) {
        self.discovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery(&mut self) -> &mut DiscoveryInfo {
        if self.discovery.is_none() {
            self.discovery.set_default();
        }
        self.discovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery(&mut self) -> DiscoveryInfo {
        self.discovery.take().unwrap_or_else(|| DiscoveryInfo::new())
    }

    pub fn get_discovery(&self) -> &DiscoveryInfo {
        self.discovery.as_ref().unwrap_or_else(|| DiscoveryInfo::default_instance())
    }

    fn get_discovery_for_reflect(&self) -> &::protobuf::SingularPtrField<DiscoveryInfo> {
        &self.discovery
    }

    fn mut_discovery_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DiscoveryInfo> {
        &mut self.discovery
    }

    // optional .mesos.v1.ContainerInfo container = 13;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container(&self) -> &ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    fn get_container_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerInfo> {
        &self.container
    }

    fn mut_container_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerInfo> {
        &mut self.container
    }

    // optional string user = 14;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user
    }

    fn mut_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user
    }
}

impl ::protobuf::Message for Task {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.task_id.is_none() {
            return false;
        }
        if self.framework_id.is_none() {
            return false;
        }
        if self.agent_id.is_none() {
            return false;
        }
        if self.state.is_none() {
            return false;
        }
        for v in &self.task_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.framework_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.executor_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.agent_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discovery {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.container {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.status_update_state = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.status_update_uuid)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.discovery)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.task_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.executor_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.status_update_state {
            my_size += ::protobuf::rt::enum_size(9, v);
        }
        if let Some(ref v) = self.status_update_uuid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.discovery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.container.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.task_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.framework_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.executor_id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.state {
            os.write_enum(6, v.value())?;
        }
        for v in &self.resources {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.statuses {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.status_update_state {
            os.write_enum(9, v.value())?;
        }
        if let Some(ref v) = self.status_update_uuid.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.discovery.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(14, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Task {
    fn new() -> Task {
        Task::new()
    }

    fn descriptor_static(_: ::std::option::Option<Task>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Task::get_name_for_reflect,
                    Task::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskID>>(
                    "task_id",
                    Task::get_task_id_for_reflect,
                    Task::mut_task_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkID>>(
                    "framework_id",
                    Task::get_framework_id_for_reflect,
                    Task::mut_framework_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorID>>(
                    "executor_id",
                    Task::get_executor_id_for_reflect,
                    Task::mut_executor_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "agent_id",
                    Task::get_agent_id_for_reflect,
                    Task::mut_agent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskState>>(
                    "state",
                    Task::get_state_for_reflect,
                    Task::mut_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    Task::get_resources_for_reflect,
                    Task::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskStatus>>(
                    "statuses",
                    Task::get_statuses_for_reflect,
                    Task::mut_statuses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskState>>(
                    "status_update_state",
                    Task::get_status_update_state_for_reflect,
                    Task::mut_status_update_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "status_update_uuid",
                    Task::get_status_update_uuid_for_reflect,
                    Task::mut_status_update_uuid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    Task::get_labels_for_reflect,
                    Task::mut_labels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveryInfo>>(
                    "discovery",
                    Task::get_discovery_for_reflect,
                    Task::mut_discovery_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerInfo>>(
                    "container",
                    Task::get_container_for_reflect,
                    Task::mut_container_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    Task::get_user_for_reflect,
                    Task::mut_user_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Task>(
                    "Task",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Task {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_task_id();
        self.clear_framework_id();
        self.clear_executor_id();
        self.clear_agent_id();
        self.clear_state();
        self.clear_resources();
        self.clear_statuses();
        self.clear_status_update_state();
        self.clear_status_update_uuid();
        self.clear_labels();
        self.clear_discovery();
        self.clear_container();
        self.clear_user();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Task {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskResourceLimitation {
    // message fields
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskResourceLimitation {}

impl TaskResourceLimitation {
    pub fn new() -> TaskResourceLimitation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskResourceLimitation {
        static mut instance: ::protobuf::lazy::Lazy<TaskResourceLimitation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskResourceLimitation,
        };
        unsafe {
            instance.get(TaskResourceLimitation::new)
        }
    }

    // repeated .mesos.v1.Resource resources = 1;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }
}

impl ::protobuf::Message for TaskResourceLimitation {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskResourceLimitation {
    fn new() -> TaskResourceLimitation {
        TaskResourceLimitation::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskResourceLimitation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    TaskResourceLimitation::get_resources_for_reflect,
                    TaskResourceLimitation::mut_resources_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskResourceLimitation>(
                    "TaskResourceLimitation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskResourceLimitation {
    fn clear(&mut self) {
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskResourceLimitation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskResourceLimitation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UUID {
    // message fields
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UUID {}

impl UUID {
    pub fn new() -> UUID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UUID {
        static mut instance: ::protobuf::lazy::Lazy<UUID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UUID,
        };
        unsafe {
            instance.get(UUID::new)
        }
    }

    // required bytes value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.value
    }
}

impl ::protobuf::Message for UUID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UUID {
    fn new() -> UUID {
        UUID::new()
    }

    fn descriptor_static(_: ::std::option::Option<UUID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    UUID::get_value_for_reflect,
                    UUID::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UUID>(
                    "UUID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UUID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UUID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UUID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Operation {
    // message fields
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    info: ::protobuf::SingularPtrField<Offer_Operation>,
    latest_status: ::protobuf::SingularPtrField<OperationStatus>,
    statuses: ::protobuf::RepeatedField<OperationStatus>,
    uuid: ::protobuf::SingularPtrField<UUID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Operation {}

impl Operation {
    pub fn new() -> Operation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Operation {
        static mut instance: ::protobuf::lazy::Lazy<Operation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Operation,
        };
        unsafe {
            instance.get(Operation::new)
        }
    }

    // optional .mesos.v1.FrameworkID framework_id = 1;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id(&mut self) -> &mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        }
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id(&self) -> &FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    fn get_framework_id_for_reflect(&self) -> &::protobuf::SingularPtrField<FrameworkID> {
        &self.framework_id
    }

    fn mut_framework_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FrameworkID> {
        &mut self.framework_id
    }

    // optional .mesos.v1.AgentID agent_id = 2;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id(&mut self) -> &mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        }
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id(&self) -> &AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_agent_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.agent_id
    }

    fn mut_agent_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.agent_id
    }

    // required .mesos.v1.Offer.Operation info = 3;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: Offer_Operation) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut Offer_Operation {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> Offer_Operation {
        self.info.take().unwrap_or_else(|| Offer_Operation::new())
    }

    pub fn get_info(&self) -> &Offer_Operation {
        self.info.as_ref().unwrap_or_else(|| Offer_Operation::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<Offer_Operation> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Offer_Operation> {
        &mut self.info
    }

    // required .mesos.v1.OperationStatus latest_status = 4;

    pub fn clear_latest_status(&mut self) {
        self.latest_status.clear();
    }

    pub fn has_latest_status(&self) -> bool {
        self.latest_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_status(&mut self, v: OperationStatus) {
        self.latest_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latest_status(&mut self) -> &mut OperationStatus {
        if self.latest_status.is_none() {
            self.latest_status.set_default();
        }
        self.latest_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_latest_status(&mut self) -> OperationStatus {
        self.latest_status.take().unwrap_or_else(|| OperationStatus::new())
    }

    pub fn get_latest_status(&self) -> &OperationStatus {
        self.latest_status.as_ref().unwrap_or_else(|| OperationStatus::default_instance())
    }

    fn get_latest_status_for_reflect(&self) -> &::protobuf::SingularPtrField<OperationStatus> {
        &self.latest_status
    }

    fn mut_latest_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OperationStatus> {
        &mut self.latest_status
    }

    // repeated .mesos.v1.OperationStatus statuses = 5;

    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<OperationStatus>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<OperationStatus> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<OperationStatus> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }

    pub fn get_statuses(&self) -> &[OperationStatus] {
        &self.statuses
    }

    fn get_statuses_for_reflect(&self) -> &::protobuf::RepeatedField<OperationStatus> {
        &self.statuses
    }

    fn mut_statuses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<OperationStatus> {
        &mut self.statuses
    }

    // required .mesos.v1.UUID uuid = 6;

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: UUID) {
        self.uuid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut UUID {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> UUID {
        self.uuid.take().unwrap_or_else(|| UUID::new())
    }

    pub fn get_uuid(&self) -> &UUID {
        self.uuid.as_ref().unwrap_or_else(|| UUID::default_instance())
    }

    fn get_uuid_for_reflect(&self) -> &::protobuf::SingularPtrField<UUID> {
        &self.uuid
    }

    fn mut_uuid_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<UUID> {
        &mut self.uuid
    }
}

impl ::protobuf::Message for Operation {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.latest_status.is_none() {
            return false;
        }
        if self.uuid.is_none() {
            return false;
        }
        for v in &self.framework_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.agent_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.latest_status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uuid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.latest_status)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.framework_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.latest_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.framework_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.latest_status.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.statuses {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Operation {
    fn new() -> Operation {
        Operation::new()
    }

    fn descriptor_static(_: ::std::option::Option<Operation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkID>>(
                    "framework_id",
                    Operation::get_framework_id_for_reflect,
                    Operation::mut_framework_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "agent_id",
                    Operation::get_agent_id_for_reflect,
                    Operation::mut_agent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer_Operation>>(
                    "info",
                    Operation::get_info_for_reflect,
                    Operation::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationStatus>>(
                    "latest_status",
                    Operation::get_latest_status_for_reflect,
                    Operation::mut_latest_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationStatus>>(
                    "statuses",
                    Operation::get_statuses_for_reflect,
                    Operation::mut_statuses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UUID>>(
                    "uuid",
                    Operation::get_uuid_for_reflect,
                    Operation::mut_uuid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Operation>(
                    "Operation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Operation {
    fn clear(&mut self) {
        self.clear_framework_id();
        self.clear_agent_id();
        self.clear_info();
        self.clear_latest_status();
        self.clear_statuses();
        self.clear_uuid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationStatus {
    // message fields
    operation_id: ::protobuf::SingularPtrField<OperationID>,
    state: ::std::option::Option<OperationState>,
    message: ::protobuf::SingularField<::std::string::String>,
    converted_resources: ::protobuf::RepeatedField<Resource>,
    uuid: ::protobuf::SingularPtrField<UUID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OperationStatus {}

impl OperationStatus {
    pub fn new() -> OperationStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OperationStatus {
        static mut instance: ::protobuf::lazy::Lazy<OperationStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationStatus,
        };
        unsafe {
            instance.get(OperationStatus::new)
        }
    }

    // optional .mesos.v1.OperationID operation_id = 1;

    pub fn clear_operation_id(&mut self) {
        self.operation_id.clear();
    }

    pub fn has_operation_id(&self) -> bool {
        self.operation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_id(&mut self, v: OperationID) {
        self.operation_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_id(&mut self) -> &mut OperationID {
        if self.operation_id.is_none() {
            self.operation_id.set_default();
        }
        self.operation_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation_id(&mut self) -> OperationID {
        self.operation_id.take().unwrap_or_else(|| OperationID::new())
    }

    pub fn get_operation_id(&self) -> &OperationID {
        self.operation_id.as_ref().unwrap_or_else(|| OperationID::default_instance())
    }

    fn get_operation_id_for_reflect(&self) -> &::protobuf::SingularPtrField<OperationID> {
        &self.operation_id
    }

    fn mut_operation_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OperationID> {
        &mut self.operation_id
    }

    // required .mesos.v1.OperationState state = 2;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: OperationState) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state(&self) -> OperationState {
        self.state.unwrap_or(OperationState::OPERATION_UNSUPPORTED)
    }

    fn get_state_for_reflect(&self) -> &::std::option::Option<OperationState> {
        &self.state
    }

    fn mut_state_for_reflect(&mut self) -> &mut ::std::option::Option<OperationState> {
        &mut self.state
    }

    // optional string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // repeated .mesos.v1.Resource converted_resources = 4;

    pub fn clear_converted_resources(&mut self) {
        self.converted_resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_converted_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.converted_resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_converted_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.converted_resources
    }

    // Take field
    pub fn take_converted_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.converted_resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_converted_resources(&self) -> &[Resource] {
        &self.converted_resources
    }

    fn get_converted_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.converted_resources
    }

    fn mut_converted_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.converted_resources
    }

    // optional .mesos.v1.UUID uuid = 5;

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: UUID) {
        self.uuid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut UUID {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> UUID {
        self.uuid.take().unwrap_or_else(|| UUID::new())
    }

    pub fn get_uuid(&self) -> &UUID {
        self.uuid.as_ref().unwrap_or_else(|| UUID::default_instance())
    }

    fn get_uuid_for_reflect(&self) -> &::protobuf::SingularPtrField<UUID> {
        &self.uuid
    }

    fn mut_uuid_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<UUID> {
        &mut self.uuid
    }
}

impl ::protobuf::Message for OperationStatus {
    fn is_initialized(&self) -> bool {
        if self.state.is_none() {
            return false;
        }
        for v in &self.operation_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.converted_resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uuid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operation_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.converted_resources)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.operation_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.converted_resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.operation_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.state {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.converted_resources {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OperationStatus {
    fn new() -> OperationStatus {
        OperationStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<OperationStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationID>>(
                    "operation_id",
                    OperationStatus::get_operation_id_for_reflect,
                    OperationStatus::mut_operation_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationState>>(
                    "state",
                    OperationStatus::get_state_for_reflect,
                    OperationStatus::mut_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    OperationStatus::get_message_for_reflect,
                    OperationStatus::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "converted_resources",
                    OperationStatus::get_converted_resources_for_reflect,
                    OperationStatus::mut_converted_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UUID>>(
                    "uuid",
                    OperationStatus::get_uuid_for_reflect,
                    OperationStatus::mut_uuid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationStatus>(
                    "OperationStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OperationStatus {
    fn clear(&mut self) {
        self.clear_operation_id();
        self.clear_state();
        self.clear_message();
        self.clear_converted_resources();
        self.clear_uuid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckStatusInfo {
    // message fields
    field_type: ::std::option::Option<CheckInfo_Type>,
    command: ::protobuf::SingularPtrField<CheckStatusInfo_Command>,
    http: ::protobuf::SingularPtrField<CheckStatusInfo_Http>,
    tcp: ::protobuf::SingularPtrField<CheckStatusInfo_Tcp>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckStatusInfo {}

impl CheckStatusInfo {
    pub fn new() -> CheckStatusInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckStatusInfo {
        static mut instance: ::protobuf::lazy::Lazy<CheckStatusInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckStatusInfo,
        };
        unsafe {
            instance.get(CheckStatusInfo::new)
        }
    }

    // optional .mesos.v1.CheckInfo.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CheckInfo_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> CheckInfo_Type {
        self.field_type.unwrap_or(CheckInfo_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<CheckInfo_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<CheckInfo_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.CheckStatusInfo.Command command = 2;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CheckStatusInfo_Command) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut CheckStatusInfo_Command {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CheckStatusInfo_Command {
        self.command.take().unwrap_or_else(|| CheckStatusInfo_Command::new())
    }

    pub fn get_command(&self) -> &CheckStatusInfo_Command {
        self.command.as_ref().unwrap_or_else(|| CheckStatusInfo_Command::default_instance())
    }

    fn get_command_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckStatusInfo_Command> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckStatusInfo_Command> {
        &mut self.command
    }

    // optional .mesos.v1.CheckStatusInfo.Http http = 3;

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: CheckStatusInfo_Http) {
        self.http = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http(&mut self) -> &mut CheckStatusInfo_Http {
        if self.http.is_none() {
            self.http.set_default();
        }
        self.http.as_mut().unwrap()
    }

    // Take field
    pub fn take_http(&mut self) -> CheckStatusInfo_Http {
        self.http.take().unwrap_or_else(|| CheckStatusInfo_Http::new())
    }

    pub fn get_http(&self) -> &CheckStatusInfo_Http {
        self.http.as_ref().unwrap_or_else(|| CheckStatusInfo_Http::default_instance())
    }

    fn get_http_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckStatusInfo_Http> {
        &self.http
    }

    fn mut_http_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckStatusInfo_Http> {
        &mut self.http
    }

    // optional .mesos.v1.CheckStatusInfo.Tcp tcp = 4;

    pub fn clear_tcp(&mut self) {
        self.tcp.clear();
    }

    pub fn has_tcp(&self) -> bool {
        self.tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp(&mut self, v: CheckStatusInfo_Tcp) {
        self.tcp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcp(&mut self) -> &mut CheckStatusInfo_Tcp {
        if self.tcp.is_none() {
            self.tcp.set_default();
        }
        self.tcp.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcp(&mut self) -> CheckStatusInfo_Tcp {
        self.tcp.take().unwrap_or_else(|| CheckStatusInfo_Tcp::new())
    }

    pub fn get_tcp(&self) -> &CheckStatusInfo_Tcp {
        self.tcp.as_ref().unwrap_or_else(|| CheckStatusInfo_Tcp::default_instance())
    }

    fn get_tcp_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckStatusInfo_Tcp> {
        &self.tcp
    }

    fn mut_tcp_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckStatusInfo_Tcp> {
        &mut self.tcp
    }
}

impl ::protobuf::Message for CheckStatusInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.http {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.http.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tcp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.http.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tcp.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckStatusInfo {
    fn new() -> CheckStatusInfo {
        CheckStatusInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckStatusInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CheckInfo_Type>>(
                    "type",
                    CheckStatusInfo::get_field_type_for_reflect,
                    CheckStatusInfo::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckStatusInfo_Command>>(
                    "command",
                    CheckStatusInfo::get_command_for_reflect,
                    CheckStatusInfo::mut_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckStatusInfo_Http>>(
                    "http",
                    CheckStatusInfo::get_http_for_reflect,
                    CheckStatusInfo::mut_http_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckStatusInfo_Tcp>>(
                    "tcp",
                    CheckStatusInfo::get_tcp_for_reflect,
                    CheckStatusInfo::mut_tcp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckStatusInfo>(
                    "CheckStatusInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckStatusInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_command();
        self.clear_http();
        self.clear_tcp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckStatusInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckStatusInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckStatusInfo_Command {
    // message fields
    exit_code: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckStatusInfo_Command {}

impl CheckStatusInfo_Command {
    pub fn new() -> CheckStatusInfo_Command {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckStatusInfo_Command {
        static mut instance: ::protobuf::lazy::Lazy<CheckStatusInfo_Command> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckStatusInfo_Command,
        };
        unsafe {
            instance.get(CheckStatusInfo_Command::new)
        }
    }

    // optional int32 exit_code = 1;

    pub fn clear_exit_code(&mut self) {
        self.exit_code = ::std::option::Option::None;
    }

    pub fn has_exit_code(&self) -> bool {
        self.exit_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exit_code(&mut self, v: i32) {
        self.exit_code = ::std::option::Option::Some(v);
    }

    pub fn get_exit_code(&self) -> i32 {
        self.exit_code.unwrap_or(0)
    }

    fn get_exit_code_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.exit_code
    }

    fn mut_exit_code_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.exit_code
    }
}

impl ::protobuf::Message for CheckStatusInfo_Command {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.exit_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.exit_code {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.exit_code {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckStatusInfo_Command {
    fn new() -> CheckStatusInfo_Command {
        CheckStatusInfo_Command::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckStatusInfo_Command>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "exit_code",
                    CheckStatusInfo_Command::get_exit_code_for_reflect,
                    CheckStatusInfo_Command::mut_exit_code_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckStatusInfo_Command>(
                    "CheckStatusInfo_Command",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckStatusInfo_Command {
    fn clear(&mut self) {
        self.clear_exit_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckStatusInfo_Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckStatusInfo_Command {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckStatusInfo_Http {
    // message fields
    status_code: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckStatusInfo_Http {}

impl CheckStatusInfo_Http {
    pub fn new() -> CheckStatusInfo_Http {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckStatusInfo_Http {
        static mut instance: ::protobuf::lazy::Lazy<CheckStatusInfo_Http> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckStatusInfo_Http,
        };
        unsafe {
            instance.get(CheckStatusInfo_Http::new)
        }
    }

    // optional uint32 status_code = 1;

    pub fn clear_status_code(&mut self) {
        self.status_code = ::std::option::Option::None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: u32) {
        self.status_code = ::std::option::Option::Some(v);
    }

    pub fn get_status_code(&self) -> u32 {
        self.status_code.unwrap_or(0)
    }

    fn get_status_code_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.status_code
    }

    fn mut_status_code_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.status_code
    }
}

impl ::protobuf::Message for CheckStatusInfo_Http {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status_code {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status_code {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckStatusInfo_Http {
    fn new() -> CheckStatusInfo_Http {
        CheckStatusInfo_Http::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckStatusInfo_Http>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status_code",
                    CheckStatusInfo_Http::get_status_code_for_reflect,
                    CheckStatusInfo_Http::mut_status_code_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckStatusInfo_Http>(
                    "CheckStatusInfo_Http",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckStatusInfo_Http {
    fn clear(&mut self) {
        self.clear_status_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckStatusInfo_Http {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckStatusInfo_Http {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckStatusInfo_Tcp {
    // message fields
    succeeded: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckStatusInfo_Tcp {}

impl CheckStatusInfo_Tcp {
    pub fn new() -> CheckStatusInfo_Tcp {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckStatusInfo_Tcp {
        static mut instance: ::protobuf::lazy::Lazy<CheckStatusInfo_Tcp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckStatusInfo_Tcp,
        };
        unsafe {
            instance.get(CheckStatusInfo_Tcp::new)
        }
    }

    // optional bool succeeded = 1;

    pub fn clear_succeeded(&mut self) {
        self.succeeded = ::std::option::Option::None;
    }

    pub fn has_succeeded(&self) -> bool {
        self.succeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_succeeded(&mut self, v: bool) {
        self.succeeded = ::std::option::Option::Some(v);
    }

    pub fn get_succeeded(&self) -> bool {
        self.succeeded.unwrap_or(false)
    }

    fn get_succeeded_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.succeeded
    }

    fn mut_succeeded_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.succeeded
    }
}

impl ::protobuf::Message for CheckStatusInfo_Tcp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.succeeded = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.succeeded {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.succeeded {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckStatusInfo_Tcp {
    fn new() -> CheckStatusInfo_Tcp {
        CheckStatusInfo_Tcp::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckStatusInfo_Tcp>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "succeeded",
                    CheckStatusInfo_Tcp::get_succeeded_for_reflect,
                    CheckStatusInfo_Tcp::mut_succeeded_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckStatusInfo_Tcp>(
                    "CheckStatusInfo_Tcp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckStatusInfo_Tcp {
    fn clear(&mut self) {
        self.clear_succeeded();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckStatusInfo_Tcp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckStatusInfo_Tcp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskStatus {
    // message fields
    task_id: ::protobuf::SingularPtrField<TaskID>,
    state: ::std::option::Option<TaskState>,
    message: ::protobuf::SingularField<::std::string::String>,
    source: ::std::option::Option<TaskStatus_Source>,
    reason: ::std::option::Option<TaskStatus_Reason>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    timestamp: ::std::option::Option<f64>,
    uuid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    healthy: ::std::option::Option<bool>,
    check_status: ::protobuf::SingularPtrField<CheckStatusInfo>,
    labels: ::protobuf::SingularPtrField<Labels>,
    container_status: ::protobuf::SingularPtrField<ContainerStatus>,
    unreachable_time: ::protobuf::SingularPtrField<TimeInfo>,
    limitation: ::protobuf::SingularPtrField<TaskResourceLimitation>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskStatus {}

impl TaskStatus {
    pub fn new() -> TaskStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskStatus {
        static mut instance: ::protobuf::lazy::Lazy<TaskStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskStatus,
        };
        unsafe {
            instance.get(TaskStatus::new)
        }
    }

    // required .mesos.v1.TaskID task_id = 1;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        }
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id(&self) -> &TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    fn get_task_id_for_reflect(&self) -> &::protobuf::SingularPtrField<TaskID> {
        &self.task_id
    }

    fn mut_task_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TaskID> {
        &mut self.task_id
    }

    // required .mesos.v1.TaskState state = 2;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: TaskState) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state(&self) -> TaskState {
        self.state.unwrap_or(TaskState::TASK_STAGING)
    }

    fn get_state_for_reflect(&self) -> &::std::option::Option<TaskState> {
        &self.state
    }

    fn mut_state_for_reflect(&mut self) -> &mut ::std::option::Option<TaskState> {
        &mut self.state
    }

    // optional string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional .mesos.v1.TaskStatus.Source source = 9;

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: TaskStatus_Source) {
        self.source = ::std::option::Option::Some(v);
    }

    pub fn get_source(&self) -> TaskStatus_Source {
        self.source.unwrap_or(TaskStatus_Source::SOURCE_MASTER)
    }

    fn get_source_for_reflect(&self) -> &::std::option::Option<TaskStatus_Source> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::std::option::Option<TaskStatus_Source> {
        &mut self.source
    }

    // optional .mesos.v1.TaskStatus.Reason reason = 10;

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TaskStatus_Reason) {
        self.reason = ::std::option::Option::Some(v);
    }

    pub fn get_reason(&self) -> TaskStatus_Reason {
        self.reason.unwrap_or(TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED)
    }

    fn get_reason_for_reflect(&self) -> &::std::option::Option<TaskStatus_Reason> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::std::option::Option<TaskStatus_Reason> {
        &mut self.reason
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }

    // optional .mesos.v1.AgentID agent_id = 5;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id(&mut self) -> &mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        }
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id(&self) -> &AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    fn get_agent_id_for_reflect(&self) -> &::protobuf::SingularPtrField<AgentID> {
        &self.agent_id
    }

    fn mut_agent_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AgentID> {
        &mut self.agent_id
    }

    // optional .mesos.v1.ExecutorID executor_id = 7;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id(&mut self) -> &mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        }
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id(&self) -> &ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    fn get_executor_id_for_reflect(&self) -> &::protobuf::SingularPtrField<ExecutorID> {
        &self.executor_id
    }

    fn mut_executor_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ExecutorID> {
        &mut self.executor_id
    }

    // optional double timestamp = 6;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.timestamp
    }

    // optional bytes uuid = 11;

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_uuid(&self) -> &[u8] {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_uuid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.uuid
    }

    fn mut_uuid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.uuid
    }

    // optional bool healthy = 8;

    pub fn clear_healthy(&mut self) {
        self.healthy = ::std::option::Option::None;
    }

    pub fn has_healthy(&self) -> bool {
        self.healthy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthy(&mut self, v: bool) {
        self.healthy = ::std::option::Option::Some(v);
    }

    pub fn get_healthy(&self) -> bool {
        self.healthy.unwrap_or(false)
    }

    fn get_healthy_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.healthy
    }

    fn mut_healthy_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.healthy
    }

    // optional .mesos.v1.CheckStatusInfo check_status = 15;

    pub fn clear_check_status(&mut self) {
        self.check_status.clear();
    }

    pub fn has_check_status(&self) -> bool {
        self.check_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check_status(&mut self, v: CheckStatusInfo) {
        self.check_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check_status(&mut self) -> &mut CheckStatusInfo {
        if self.check_status.is_none() {
            self.check_status.set_default();
        }
        self.check_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_check_status(&mut self) -> CheckStatusInfo {
        self.check_status.take().unwrap_or_else(|| CheckStatusInfo::new())
    }

    pub fn get_check_status(&self) -> &CheckStatusInfo {
        self.check_status.as_ref().unwrap_or_else(|| CheckStatusInfo::default_instance())
    }

    fn get_check_status_for_reflect(&self) -> &::protobuf::SingularPtrField<CheckStatusInfo> {
        &self.check_status
    }

    fn mut_check_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CheckStatusInfo> {
        &mut self.check_status
    }

    // optional .mesos.v1.Labels labels = 12;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }

    // optional .mesos.v1.ContainerStatus container_status = 13;

    pub fn clear_container_status(&mut self) {
        self.container_status.clear();
    }

    pub fn has_container_status(&self) -> bool {
        self.container_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_status(&mut self, v: ContainerStatus) {
        self.container_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_status(&mut self) -> &mut ContainerStatus {
        if self.container_status.is_none() {
            self.container_status.set_default();
        }
        self.container_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_status(&mut self) -> ContainerStatus {
        self.container_status.take().unwrap_or_else(|| ContainerStatus::new())
    }

    pub fn get_container_status(&self) -> &ContainerStatus {
        self.container_status.as_ref().unwrap_or_else(|| ContainerStatus::default_instance())
    }

    fn get_container_status_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerStatus> {
        &self.container_status
    }

    fn mut_container_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerStatus> {
        &mut self.container_status
    }

    // optional .mesos.v1.TimeInfo unreachable_time = 14;

    pub fn clear_unreachable_time(&mut self) {
        self.unreachable_time.clear();
    }

    pub fn has_unreachable_time(&self) -> bool {
        self.unreachable_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreachable_time(&mut self, v: TimeInfo) {
        self.unreachable_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unreachable_time(&mut self) -> &mut TimeInfo {
        if self.unreachable_time.is_none() {
            self.unreachable_time.set_default();
        }
        self.unreachable_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_unreachable_time(&mut self) -> TimeInfo {
        self.unreachable_time.take().unwrap_or_else(|| TimeInfo::new())
    }

    pub fn get_unreachable_time(&self) -> &TimeInfo {
        self.unreachable_time.as_ref().unwrap_or_else(|| TimeInfo::default_instance())
    }

    fn get_unreachable_time_for_reflect(&self) -> &::protobuf::SingularPtrField<TimeInfo> {
        &self.unreachable_time
    }

    fn mut_unreachable_time_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TimeInfo> {
        &mut self.unreachable_time
    }

    // optional .mesos.v1.TaskResourceLimitation limitation = 16;

    pub fn clear_limitation(&mut self) {
        self.limitation.clear();
    }

    pub fn has_limitation(&self) -> bool {
        self.limitation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitation(&mut self, v: TaskResourceLimitation) {
        self.limitation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limitation(&mut self) -> &mut TaskResourceLimitation {
        if self.limitation.is_none() {
            self.limitation.set_default();
        }
        self.limitation.as_mut().unwrap()
    }

    // Take field
    pub fn take_limitation(&mut self) -> TaskResourceLimitation {
        self.limitation.take().unwrap_or_else(|| TaskResourceLimitation::new())
    }

    pub fn get_limitation(&self) -> &TaskResourceLimitation {
        self.limitation.as_ref().unwrap_or_else(|| TaskResourceLimitation::default_instance())
    }

    fn get_limitation_for_reflect(&self) -> &::protobuf::SingularPtrField<TaskResourceLimitation> {
        &self.limitation
    }

    fn mut_limitation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TaskResourceLimitation> {
        &mut self.limitation
    }
}

impl ::protobuf::Message for TaskStatus {
    fn is_initialized(&self) -> bool {
        if self.task_id.is_none() {
            return false;
        }
        if self.state.is_none() {
            return false;
        }
        for v in &self.task_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.agent_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.executor_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check_status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.container_status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unreachable_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limitation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.source = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor_id)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.uuid)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.healthy = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check_status)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container_status)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unreachable_time)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limitation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.task_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.source {
            my_size += ::protobuf::rt::enum_size(9, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.executor_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.timestamp {
            my_size += 9;
        }
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.healthy {
            my_size += 2;
        }
        if let Some(ref v) = self.check_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.container_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unreachable_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.limitation.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.task_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.state {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.source {
            os.write_enum(9, v.value())?;
        }
        if let Some(v) = self.reason {
            os.write_enum(10, v.value())?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.agent_id.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.executor_id.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.timestamp {
            os.write_double(6, v)?;
        }
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(v) = self.healthy {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.check_status.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.container_status.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unreachable_time.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.limitation.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskStatus {
    fn new() -> TaskStatus {
        TaskStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskID>>(
                    "task_id",
                    TaskStatus::get_task_id_for_reflect,
                    TaskStatus::mut_task_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskState>>(
                    "state",
                    TaskStatus::get_state_for_reflect,
                    TaskStatus::mut_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    TaskStatus::get_message_for_reflect,
                    TaskStatus::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskStatus_Source>>(
                    "source",
                    TaskStatus::get_source_for_reflect,
                    TaskStatus::mut_source_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskStatus_Reason>>(
                    "reason",
                    TaskStatus::get_reason_for_reflect,
                    TaskStatus::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    TaskStatus::get_data_for_reflect,
                    TaskStatus::mut_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentID>>(
                    "agent_id",
                    TaskStatus::get_agent_id_for_reflect,
                    TaskStatus::mut_agent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorID>>(
                    "executor_id",
                    TaskStatus::get_executor_id_for_reflect,
                    TaskStatus::mut_executor_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "timestamp",
                    TaskStatus::get_timestamp_for_reflect,
                    TaskStatus::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "uuid",
                    TaskStatus::get_uuid_for_reflect,
                    TaskStatus::mut_uuid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "healthy",
                    TaskStatus::get_healthy_for_reflect,
                    TaskStatus::mut_healthy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckStatusInfo>>(
                    "check_status",
                    TaskStatus::get_check_status_for_reflect,
                    TaskStatus::mut_check_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    TaskStatus::get_labels_for_reflect,
                    TaskStatus::mut_labels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                    "container_status",
                    TaskStatus::get_container_status_for_reflect,
                    TaskStatus::mut_container_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeInfo>>(
                    "unreachable_time",
                    TaskStatus::get_unreachable_time_for_reflect,
                    TaskStatus::mut_unreachable_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskResourceLimitation>>(
                    "limitation",
                    TaskStatus::get_limitation_for_reflect,
                    TaskStatus::mut_limitation_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskStatus>(
                    "TaskStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskStatus {
    fn clear(&mut self) {
        self.clear_task_id();
        self.clear_state();
        self.clear_message();
        self.clear_source();
        self.clear_reason();
        self.clear_data();
        self.clear_agent_id();
        self.clear_executor_id();
        self.clear_timestamp();
        self.clear_uuid();
        self.clear_healthy();
        self.clear_check_status();
        self.clear_labels();
        self.clear_container_status();
        self.clear_unreachable_time();
        self.clear_limitation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatus_Source {
    SOURCE_MASTER = 0,
    SOURCE_AGENT = 1,
    SOURCE_EXECUTOR = 2,
}

impl ::protobuf::ProtobufEnum for TaskStatus_Source {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatus_Source> {
        match value {
            0 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_MASTER),
            1 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_AGENT),
            2 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_EXECUTOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskStatus_Source] = &[
            TaskStatus_Source::SOURCE_MASTER,
            TaskStatus_Source::SOURCE_AGENT,
            TaskStatus_Source::SOURCE_EXECUTOR,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<TaskStatus_Source>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskStatus_Source", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskStatus_Source {
}

impl ::protobuf::reflect::ProtobufValue for TaskStatus_Source {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatus_Reason {
    REASON_COMMAND_EXECUTOR_FAILED = 0,
    REASON_CONTAINER_LAUNCH_FAILED = 21,
    REASON_CONTAINER_LIMITATION = 19,
    REASON_CONTAINER_LIMITATION_DISK = 20,
    REASON_CONTAINER_LIMITATION_MEMORY = 8,
    REASON_CONTAINER_PREEMPTED = 17,
    REASON_CONTAINER_UPDATE_FAILED = 22,
    REASON_EXECUTOR_REGISTRATION_TIMEOUT = 23,
    REASON_EXECUTOR_REREGISTRATION_TIMEOUT = 24,
    REASON_EXECUTOR_TERMINATED = 1,
    REASON_EXECUTOR_UNREGISTERED = 2,
    REASON_FRAMEWORK_REMOVED = 3,
    REASON_GC_ERROR = 4,
    REASON_INVALID_FRAMEWORKID = 5,
    REASON_INVALID_OFFERS = 6,
    REASON_IO_SWITCHBOARD_EXITED = 27,
    REASON_MASTER_DISCONNECTED = 7,
    REASON_RECONCILIATION = 9,
    REASON_RESOURCES_UNKNOWN = 18,
    REASON_AGENT_DISCONNECTED = 10,
    REASON_AGENT_REMOVED = 11,
    REASON_AGENT_REMOVED_BY_OPERATOR = 31,
    REASON_AGENT_REREGISTERED = 32,
    REASON_AGENT_RESTARTED = 12,
    REASON_AGENT_UNKNOWN = 13,
    REASON_TASK_KILLED_DURING_LAUNCH = 30,
    REASON_TASK_CHECK_STATUS_UPDATED = 28,
    REASON_TASK_HEALTH_CHECK_STATUS_UPDATED = 29,
    REASON_TASK_GROUP_INVALID = 25,
    REASON_TASK_GROUP_UNAUTHORIZED = 26,
    REASON_TASK_INVALID = 14,
    REASON_TASK_UNAUTHORIZED = 15,
    REASON_TASK_UNKNOWN = 16,
}

impl ::protobuf::ProtobufEnum for TaskStatus_Reason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatus_Reason> {
        match value {
            0 => ::std::option::Option::Some(TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED),
            21 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LAUNCH_FAILED),
            19 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LIMITATION),
            20 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LIMITATION_DISK),
            8 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LIMITATION_MEMORY),
            17 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_PREEMPTED),
            22 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_UPDATE_FAILED),
            23 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_REGISTRATION_TIMEOUT),
            24 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_REREGISTRATION_TIMEOUT),
            1 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_TERMINATED),
            2 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_UNREGISTERED),
            3 => ::std::option::Option::Some(TaskStatus_Reason::REASON_FRAMEWORK_REMOVED),
            4 => ::std::option::Option::Some(TaskStatus_Reason::REASON_GC_ERROR),
            5 => ::std::option::Option::Some(TaskStatus_Reason::REASON_INVALID_FRAMEWORKID),
            6 => ::std::option::Option::Some(TaskStatus_Reason::REASON_INVALID_OFFERS),
            27 => ::std::option::Option::Some(TaskStatus_Reason::REASON_IO_SWITCHBOARD_EXITED),
            7 => ::std::option::Option::Some(TaskStatus_Reason::REASON_MASTER_DISCONNECTED),
            9 => ::std::option::Option::Some(TaskStatus_Reason::REASON_RECONCILIATION),
            18 => ::std::option::Option::Some(TaskStatus_Reason::REASON_RESOURCES_UNKNOWN),
            10 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_DISCONNECTED),
            11 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_REMOVED),
            31 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_REMOVED_BY_OPERATOR),
            32 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_REREGISTERED),
            12 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_RESTARTED),
            13 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_UNKNOWN),
            30 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_KILLED_DURING_LAUNCH),
            28 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_CHECK_STATUS_UPDATED),
            29 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_HEALTH_CHECK_STATUS_UPDATED),
            25 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_GROUP_INVALID),
            26 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_GROUP_UNAUTHORIZED),
            14 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_INVALID),
            15 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_UNAUTHORIZED),
            16 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskStatus_Reason] = &[
            TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED,
            TaskStatus_Reason::REASON_CONTAINER_LAUNCH_FAILED,
            TaskStatus_Reason::REASON_CONTAINER_LIMITATION,
            TaskStatus_Reason::REASON_CONTAINER_LIMITATION_DISK,
            TaskStatus_Reason::REASON_CONTAINER_LIMITATION_MEMORY,
            TaskStatus_Reason::REASON_CONTAINER_PREEMPTED,
            TaskStatus_Reason::REASON_CONTAINER_UPDATE_FAILED,
            TaskStatus_Reason::REASON_EXECUTOR_REGISTRATION_TIMEOUT,
            TaskStatus_Reason::REASON_EXECUTOR_REREGISTRATION_TIMEOUT,
            TaskStatus_Reason::REASON_EXECUTOR_TERMINATED,
            TaskStatus_Reason::REASON_EXECUTOR_UNREGISTERED,
            TaskStatus_Reason::REASON_FRAMEWORK_REMOVED,
            TaskStatus_Reason::REASON_GC_ERROR,
            TaskStatus_Reason::REASON_INVALID_FRAMEWORKID,
            TaskStatus_Reason::REASON_INVALID_OFFERS,
            TaskStatus_Reason::REASON_IO_SWITCHBOARD_EXITED,
            TaskStatus_Reason::REASON_MASTER_DISCONNECTED,
            TaskStatus_Reason::REASON_RECONCILIATION,
            TaskStatus_Reason::REASON_RESOURCES_UNKNOWN,
            TaskStatus_Reason::REASON_AGENT_DISCONNECTED,
            TaskStatus_Reason::REASON_AGENT_REMOVED,
            TaskStatus_Reason::REASON_AGENT_REMOVED_BY_OPERATOR,
            TaskStatus_Reason::REASON_AGENT_REREGISTERED,
            TaskStatus_Reason::REASON_AGENT_RESTARTED,
            TaskStatus_Reason::REASON_AGENT_UNKNOWN,
            TaskStatus_Reason::REASON_TASK_KILLED_DURING_LAUNCH,
            TaskStatus_Reason::REASON_TASK_CHECK_STATUS_UPDATED,
            TaskStatus_Reason::REASON_TASK_HEALTH_CHECK_STATUS_UPDATED,
            TaskStatus_Reason::REASON_TASK_GROUP_INVALID,
            TaskStatus_Reason::REASON_TASK_GROUP_UNAUTHORIZED,
            TaskStatus_Reason::REASON_TASK_INVALID,
            TaskStatus_Reason::REASON_TASK_UNAUTHORIZED,
            TaskStatus_Reason::REASON_TASK_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<TaskStatus_Reason>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskStatus_Reason", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskStatus_Reason {
}

impl ::protobuf::reflect::ProtobufValue for TaskStatus_Reason {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Filters {
    // message fields
    refuse_seconds: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Filters {}

impl Filters {
    pub fn new() -> Filters {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Filters {
        static mut instance: ::protobuf::lazy::Lazy<Filters> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Filters,
        };
        unsafe {
            instance.get(Filters::new)
        }
    }

    // optional double refuse_seconds = 1;

    pub fn clear_refuse_seconds(&mut self) {
        self.refuse_seconds = ::std::option::Option::None;
    }

    pub fn has_refuse_seconds(&self) -> bool {
        self.refuse_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refuse_seconds(&mut self, v: f64) {
        self.refuse_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_refuse_seconds(&self) -> f64 {
        self.refuse_seconds.unwrap_or(5f64)
    }

    fn get_refuse_seconds_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.refuse_seconds
    }

    fn mut_refuse_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.refuse_seconds
    }
}

impl ::protobuf::Message for Filters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.refuse_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.refuse_seconds {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.refuse_seconds {
            os.write_double(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Filters {
    fn new() -> Filters {
        Filters::new()
    }

    fn descriptor_static(_: ::std::option::Option<Filters>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "refuse_seconds",
                    Filters::get_refuse_seconds_for_reflect,
                    Filters::mut_refuse_seconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Filters>(
                    "Filters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Filters {
    fn clear(&mut self) {
        self.clear_refuse_seconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Filters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Filters {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Environment {
    // message fields
    variables: ::protobuf::RepeatedField<Environment_Variable>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Environment {}

impl Environment {
    pub fn new() -> Environment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Environment {
        static mut instance: ::protobuf::lazy::Lazy<Environment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Environment,
        };
        unsafe {
            instance.get(Environment::new)
        }
    }

    // repeated .mesos.v1.Environment.Variable variables = 1;

    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::protobuf::RepeatedField<Environment_Variable>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::protobuf::RepeatedField<Environment_Variable> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::protobuf::RepeatedField<Environment_Variable> {
        ::std::mem::replace(&mut self.variables, ::protobuf::RepeatedField::new())
    }

    pub fn get_variables(&self) -> &[Environment_Variable] {
        &self.variables
    }

    fn get_variables_for_reflect(&self) -> &::protobuf::RepeatedField<Environment_Variable> {
        &self.variables
    }

    fn mut_variables_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Environment_Variable> {
        &mut self.variables
    }
}

impl ::protobuf::Message for Environment {
    fn is_initialized(&self) -> bool {
        for v in &self.variables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variables)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.variables {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Environment {
    fn new() -> Environment {
        Environment::new()
    }

    fn descriptor_static(_: ::std::option::Option<Environment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Environment_Variable>>(
                    "variables",
                    Environment::get_variables_for_reflect,
                    Environment::mut_variables_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Environment>(
                    "Environment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Environment {
    fn clear(&mut self) {
        self.clear_variables();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Environment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Environment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Environment_Variable {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<Environment_Variable_Type>,
    value: ::protobuf::SingularField<::std::string::String>,
    secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Environment_Variable {}

impl Environment_Variable {
    pub fn new() -> Environment_Variable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Environment_Variable {
        static mut instance: ::protobuf::lazy::Lazy<Environment_Variable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Environment_Variable,
        };
        unsafe {
            instance.get(Environment_Variable::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional .mesos.v1.Environment.Variable.Type type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Environment_Variable_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Environment_Variable_Type {
        self.field_type.unwrap_or(Environment_Variable_Type::VALUE)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Environment_Variable_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Environment_Variable_Type> {
        &mut self.field_type
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }

    // optional .mesos.v1.Secret secret = 4;

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }

    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| Secret::default_instance())
    }

    fn get_secret_for_reflect(&self) -> &::protobuf::SingularPtrField<Secret> {
        &self.secret
    }

    fn mut_secret_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Secret> {
        &mut self.secret
    }
}

impl ::protobuf::Message for Environment_Variable {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, v.value())?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Environment_Variable {
    fn new() -> Environment_Variable {
        Environment_Variable::new()
    }

    fn descriptor_static(_: ::std::option::Option<Environment_Variable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Environment_Variable::get_name_for_reflect,
                    Environment_Variable::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Environment_Variable_Type>>(
                    "type",
                    Environment_Variable::get_field_type_for_reflect,
                    Environment_Variable::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Environment_Variable::get_value_for_reflect,
                    Environment_Variable::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "secret",
                    Environment_Variable::get_secret_for_reflect,
                    Environment_Variable::mut_secret_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Environment_Variable>(
                    "Environment_Variable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Environment_Variable {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_value();
        self.clear_secret();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Environment_Variable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Environment_Variable {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Environment_Variable_Type {
    UNKNOWN = 0,
    VALUE = 1,
    SECRET = 2,
}

impl ::protobuf::ProtobufEnum for Environment_Variable_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Environment_Variable_Type> {
        match value {
            0 => ::std::option::Option::Some(Environment_Variable_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Environment_Variable_Type::VALUE),
            2 => ::std::option::Option::Some(Environment_Variable_Type::SECRET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Environment_Variable_Type] = &[
            Environment_Variable_Type::UNKNOWN,
            Environment_Variable_Type::VALUE,
            Environment_Variable_Type::SECRET,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Environment_Variable_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Environment_Variable_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Environment_Variable_Type {
}

impl ::protobuf::reflect::ProtobufValue for Environment_Variable_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Parameter {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Parameter {}

impl Parameter {
    pub fn new() -> Parameter {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Parameter {
        static mut instance: ::protobuf::lazy::Lazy<Parameter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameter,
        };
        unsafe {
            instance.get(Parameter::new)
        }
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // required string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for Parameter {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Parameter {
    fn new() -> Parameter {
        Parameter::new()
    }

    fn descriptor_static(_: ::std::option::Option<Parameter>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    Parameter::get_key_for_reflect,
                    Parameter::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Parameter::get_value_for_reflect,
                    Parameter::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameter>(
                    "Parameter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Parameter {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Parameter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Parameters {
    // message fields
    parameter: ::protobuf::RepeatedField<Parameter>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Parameters {}

impl Parameters {
    pub fn new() -> Parameters {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Parameters {
        static mut instance: ::protobuf::lazy::Lazy<Parameters> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameters,
        };
        unsafe {
            instance.get(Parameters::new)
        }
    }

    // repeated .mesos.v1.Parameter parameter = 1;

    pub fn clear_parameter(&mut self) {
        self.parameter.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.parameter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameter(&mut self) -> &mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameter
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.parameter, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameter(&self) -> &[Parameter] {
        &self.parameter
    }

    fn get_parameter_for_reflect(&self) -> &::protobuf::RepeatedField<Parameter> {
        &self.parameter
    }

    fn mut_parameter_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameter
    }
}

impl ::protobuf::Message for Parameters {
    fn is_initialized(&self) -> bool {
        for v in &self.parameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.parameter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.parameter {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Parameters {
    fn new() -> Parameters {
        Parameters::new()
    }

    fn descriptor_static(_: ::std::option::Option<Parameters>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Parameter>>(
                    "parameter",
                    Parameters::get_parameter_for_reflect,
                    Parameters::mut_parameter_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameters>(
                    "Parameters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Parameters {
    fn clear(&mut self) {
        self.clear_parameter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Parameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Parameters {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Credential {
    // message fields
    principal: ::protobuf::SingularField<::std::string::String>,
    secret: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Credential {}

impl Credential {
    pub fn new() -> Credential {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Credential {
        static mut instance: ::protobuf::lazy::Lazy<Credential> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Credential,
        };
        unsafe {
            instance.get(Credential::new)
        }
    }

    // required string principal = 1;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal(&mut self) -> &mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        }
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal(&self) -> &str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_principal_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.principal
    }

    fn mut_principal_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.principal
    }

    // optional string secret = 2;

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::string::String) {
        self.secret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::std::string::String {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::string::String {
        self.secret.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_secret(&self) -> &str {
        match self.secret.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_secret_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.secret
    }

    fn mut_secret_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.secret
    }
}

impl ::protobuf::Message for Credential {
    fn is_initialized(&self) -> bool {
        if self.principal.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.principal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.secret.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.principal.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.secret.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Credential {
    fn new() -> Credential {
        Credential::new()
    }

    fn descriptor_static(_: ::std::option::Option<Credential>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "principal",
                    Credential::get_principal_for_reflect,
                    Credential::mut_principal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "secret",
                    Credential::get_secret_for_reflect,
                    Credential::mut_secret_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Credential>(
                    "Credential",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Credential {
    fn clear(&mut self) {
        self.clear_principal();
        self.clear_secret();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Credential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Credential {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Credentials {
    // message fields
    credentials: ::protobuf::RepeatedField<Credential>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Credentials {}

impl Credentials {
    pub fn new() -> Credentials {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Credentials {
        static mut instance: ::protobuf::lazy::Lazy<Credentials> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Credentials,
        };
        unsafe {
            instance.get(Credentials::new)
        }
    }

    // repeated .mesos.v1.Credential credentials = 1;

    pub fn clear_credentials(&mut self) {
        self.credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials(&mut self, v: ::protobuf::RepeatedField<Credential>) {
        self.credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_credentials(&mut self) -> &mut ::protobuf::RepeatedField<Credential> {
        &mut self.credentials
    }

    // Take field
    pub fn take_credentials(&mut self) -> ::protobuf::RepeatedField<Credential> {
        ::std::mem::replace(&mut self.credentials, ::protobuf::RepeatedField::new())
    }

    pub fn get_credentials(&self) -> &[Credential] {
        &self.credentials
    }

    fn get_credentials_for_reflect(&self) -> &::protobuf::RepeatedField<Credential> {
        &self.credentials
    }

    fn mut_credentials_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Credential> {
        &mut self.credentials
    }
}

impl ::protobuf::Message for Credentials {
    fn is_initialized(&self) -> bool {
        for v in &self.credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.credentials)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.credentials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.credentials {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Credentials {
    fn new() -> Credentials {
        Credentials::new()
    }

    fn descriptor_static(_: ::std::option::Option<Credentials>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Credential>>(
                    "credentials",
                    Credentials::get_credentials_for_reflect,
                    Credentials::mut_credentials_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Credentials>(
                    "Credentials",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Credentials {
    fn clear(&mut self) {
        self.clear_credentials();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Credentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Credentials {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Secret {
    // message fields
    field_type: ::std::option::Option<Secret_Type>,
    reference: ::protobuf::SingularPtrField<Secret_Reference>,
    value: ::protobuf::SingularPtrField<Secret_Value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Secret {}

impl Secret {
    pub fn new() -> Secret {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Secret {
        static mut instance: ::protobuf::lazy::Lazy<Secret> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Secret,
        };
        unsafe {
            instance.get(Secret::new)
        }
    }

    // optional .mesos.v1.Secret.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Secret_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Secret_Type {
        self.field_type.unwrap_or(Secret_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Secret_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Secret_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.Secret.Reference reference = 2;

    pub fn clear_reference(&mut self) {
        self.reference.clear();
    }

    pub fn has_reference(&self) -> bool {
        self.reference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: Secret_Reference) {
        self.reference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference(&mut self) -> &mut Secret_Reference {
        if self.reference.is_none() {
            self.reference.set_default();
        }
        self.reference.as_mut().unwrap()
    }

    // Take field
    pub fn take_reference(&mut self) -> Secret_Reference {
        self.reference.take().unwrap_or_else(|| Secret_Reference::new())
    }

    pub fn get_reference(&self) -> &Secret_Reference {
        self.reference.as_ref().unwrap_or_else(|| Secret_Reference::default_instance())
    }

    fn get_reference_for_reflect(&self) -> &::protobuf::SingularPtrField<Secret_Reference> {
        &self.reference
    }

    fn mut_reference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Secret_Reference> {
        &mut self.reference
    }

    // optional .mesos.v1.Secret.Value value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Secret_Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Secret_Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Secret_Value {
        self.value.take().unwrap_or_else(|| Secret_Value::new())
    }

    pub fn get_value(&self) -> &Secret_Value {
        self.value.as_ref().unwrap_or_else(|| Secret_Value::default_instance())
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularPtrField<Secret_Value> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Secret_Value> {
        &mut self.value
    }
}

impl ::protobuf::Message for Secret {
    fn is_initialized(&self) -> bool {
        for v in &self.reference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reference)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.reference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.reference.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Secret {
    fn new() -> Secret {
        Secret::new()
    }

    fn descriptor_static(_: ::std::option::Option<Secret>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Secret_Type>>(
                    "type",
                    Secret::get_field_type_for_reflect,
                    Secret::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret_Reference>>(
                    "reference",
                    Secret::get_reference_for_reflect,
                    Secret::mut_reference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret_Value>>(
                    "value",
                    Secret::get_value_for_reflect,
                    Secret::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Secret>(
                    "Secret",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Secret {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_reference();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Secret_Reference {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Secret_Reference {}

impl Secret_Reference {
    pub fn new() -> Secret_Reference {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Secret_Reference {
        static mut instance: ::protobuf::lazy::Lazy<Secret_Reference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Secret_Reference,
        };
        unsafe {
            instance.get(Secret_Reference::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }
}

impl ::protobuf::Message for Secret_Reference {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Secret_Reference {
    fn new() -> Secret_Reference {
        Secret_Reference::new()
    }

    fn descriptor_static(_: ::std::option::Option<Secret_Reference>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Secret_Reference::get_name_for_reflect,
                    Secret_Reference::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    Secret_Reference::get_key_for_reflect,
                    Secret_Reference::mut_key_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Secret_Reference>(
                    "Secret_Reference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Secret_Reference {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Secret_Reference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret_Reference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Secret_Value {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Secret_Value {}

impl Secret_Value {
    pub fn new() -> Secret_Value {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Secret_Value {
        static mut instance: ::protobuf::lazy::Lazy<Secret_Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Secret_Value,
        };
        unsafe {
            instance.get(Secret_Value::new)
        }
    }

    // required bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for Secret_Value {
    fn is_initialized(&self) -> bool {
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Secret_Value {
    fn new() -> Secret_Value {
        Secret_Value::new()
    }

    fn descriptor_static(_: ::std::option::Option<Secret_Value>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    Secret_Value::get_data_for_reflect,
                    Secret_Value::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Secret_Value>(
                    "Secret_Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Secret_Value {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Secret_Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Secret_Type {
    UNKNOWN = 0,
    REFERENCE = 1,
    VALUE = 2,
}

impl ::protobuf::ProtobufEnum for Secret_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Secret_Type> {
        match value {
            0 => ::std::option::Option::Some(Secret_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Secret_Type::REFERENCE),
            2 => ::std::option::Option::Some(Secret_Type::VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Secret_Type] = &[
            Secret_Type::UNKNOWN,
            Secret_Type::REFERENCE,
            Secret_Type::VALUE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Secret_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Secret_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Secret_Type {
}

impl ::protobuf::reflect::ProtobufValue for Secret_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit {
    // message fields
    qps: ::std::option::Option<f64>,
    principal: ::protobuf::SingularField<::std::string::String>,
    capacity: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RateLimit {}

impl RateLimit {
    pub fn new() -> RateLimit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RateLimit {
        static mut instance: ::protobuf::lazy::Lazy<RateLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RateLimit,
        };
        unsafe {
            instance.get(RateLimit::new)
        }
    }

    // optional double qps = 1;

    pub fn clear_qps(&mut self) {
        self.qps = ::std::option::Option::None;
    }

    pub fn has_qps(&self) -> bool {
        self.qps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qps(&mut self, v: f64) {
        self.qps = ::std::option::Option::Some(v);
    }

    pub fn get_qps(&self) -> f64 {
        self.qps.unwrap_or(0.)
    }

    fn get_qps_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.qps
    }

    fn mut_qps_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.qps
    }

    // required string principal = 2;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal(&mut self) -> &mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        }
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal(&self) -> &str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_principal_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.principal
    }

    fn mut_principal_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.principal
    }

    // optional uint64 capacity = 3;

    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }

    fn get_capacity_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.capacity
    }

    fn mut_capacity_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.capacity
    }
}

impl ::protobuf::Message for RateLimit {
    fn is_initialized(&self) -> bool {
        if self.principal.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.qps = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.qps {
            my_size += 9;
        }
        if let Some(ref v) = self.principal.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.qps {
            os.write_double(1, v)?;
        }
        if let Some(ref v) = self.principal.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.capacity {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RateLimit {
    fn new() -> RateLimit {
        RateLimit::new()
    }

    fn descriptor_static(_: ::std::option::Option<RateLimit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "qps",
                    RateLimit::get_qps_for_reflect,
                    RateLimit::mut_qps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "principal",
                    RateLimit::get_principal_for_reflect,
                    RateLimit::mut_principal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "capacity",
                    RateLimit::get_capacity_for_reflect,
                    RateLimit::mut_capacity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RateLimit>(
                    "RateLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RateLimit {
    fn clear(&mut self) {
        self.clear_qps();
        self.clear_principal();
        self.clear_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimits {
    // message fields
    limits: ::protobuf::RepeatedField<RateLimit>,
    aggregate_default_qps: ::std::option::Option<f64>,
    aggregate_default_capacity: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RateLimits {}

impl RateLimits {
    pub fn new() -> RateLimits {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RateLimits {
        static mut instance: ::protobuf::lazy::Lazy<RateLimits> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RateLimits,
        };
        unsafe {
            instance.get(RateLimits::new)
        }
    }

    // repeated .mesos.v1.RateLimit limits = 1;

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<RateLimit>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<RateLimit> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }

    pub fn get_limits(&self) -> &[RateLimit] {
        &self.limits
    }

    fn get_limits_for_reflect(&self) -> &::protobuf::RepeatedField<RateLimit> {
        &self.limits
    }

    fn mut_limits_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.limits
    }

    // optional double aggregate_default_qps = 2;

    pub fn clear_aggregate_default_qps(&mut self) {
        self.aggregate_default_qps = ::std::option::Option::None;
    }

    pub fn has_aggregate_default_qps(&self) -> bool {
        self.aggregate_default_qps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_default_qps(&mut self, v: f64) {
        self.aggregate_default_qps = ::std::option::Option::Some(v);
    }

    pub fn get_aggregate_default_qps(&self) -> f64 {
        self.aggregate_default_qps.unwrap_or(0.)
    }

    fn get_aggregate_default_qps_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.aggregate_default_qps
    }

    fn mut_aggregate_default_qps_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.aggregate_default_qps
    }

    // optional uint64 aggregate_default_capacity = 3;

    pub fn clear_aggregate_default_capacity(&mut self) {
        self.aggregate_default_capacity = ::std::option::Option::None;
    }

    pub fn has_aggregate_default_capacity(&self) -> bool {
        self.aggregate_default_capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_default_capacity(&mut self, v: u64) {
        self.aggregate_default_capacity = ::std::option::Option::Some(v);
    }

    pub fn get_aggregate_default_capacity(&self) -> u64 {
        self.aggregate_default_capacity.unwrap_or(0)
    }

    fn get_aggregate_default_capacity_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.aggregate_default_capacity
    }

    fn mut_aggregate_default_capacity_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.aggregate_default_capacity
    }
}

impl ::protobuf::Message for RateLimits {
    fn is_initialized(&self) -> bool {
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.aggregate_default_qps = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.aggregate_default_capacity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.aggregate_default_qps {
            my_size += 9;
        }
        if let Some(v) = self.aggregate_default_capacity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.limits {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.aggregate_default_qps {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.aggregate_default_capacity {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RateLimits {
    fn new() -> RateLimits {
        RateLimits::new()
    }

    fn descriptor_static(_: ::std::option::Option<RateLimits>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit>>(
                    "limits",
                    RateLimits::get_limits_for_reflect,
                    RateLimits::mut_limits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "aggregate_default_qps",
                    RateLimits::get_aggregate_default_qps_for_reflect,
                    RateLimits::mut_aggregate_default_qps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "aggregate_default_capacity",
                    RateLimits::get_aggregate_default_capacity_for_reflect,
                    RateLimits::mut_aggregate_default_capacity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RateLimits>(
                    "RateLimits",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RateLimits {
    fn clear(&mut self) {
        self.clear_limits();
        self.clear_aggregate_default_qps();
        self.clear_aggregate_default_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimits {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image {
    // message fields
    field_type: ::std::option::Option<Image_Type>,
    appc: ::protobuf::SingularPtrField<Image_Appc>,
    docker: ::protobuf::SingularPtrField<Image_Docker>,
    cached: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Image {}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image {
        static mut instance: ::protobuf::lazy::Lazy<Image> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image,
        };
        unsafe {
            instance.get(Image::new)
        }
    }

    // required .mesos.v1.Image.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Image_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Image_Type {
        self.field_type.unwrap_or(Image_Type::APPC)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Image_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Image_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.Image.Appc appc = 2;

    pub fn clear_appc(&mut self) {
        self.appc.clear();
    }

    pub fn has_appc(&self) -> bool {
        self.appc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appc(&mut self, v: Image_Appc) {
        self.appc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appc(&mut self) -> &mut Image_Appc {
        if self.appc.is_none() {
            self.appc.set_default();
        }
        self.appc.as_mut().unwrap()
    }

    // Take field
    pub fn take_appc(&mut self) -> Image_Appc {
        self.appc.take().unwrap_or_else(|| Image_Appc::new())
    }

    pub fn get_appc(&self) -> &Image_Appc {
        self.appc.as_ref().unwrap_or_else(|| Image_Appc::default_instance())
    }

    fn get_appc_for_reflect(&self) -> &::protobuf::SingularPtrField<Image_Appc> {
        &self.appc
    }

    fn mut_appc_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Image_Appc> {
        &mut self.appc
    }

    // optional .mesos.v1.Image.Docker docker = 3;

    pub fn clear_docker(&mut self) {
        self.docker.clear();
    }

    pub fn has_docker(&self) -> bool {
        self.docker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_docker(&mut self, v: Image_Docker) {
        self.docker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker(&mut self) -> &mut Image_Docker {
        if self.docker.is_none() {
            self.docker.set_default();
        }
        self.docker.as_mut().unwrap()
    }

    // Take field
    pub fn take_docker(&mut self) -> Image_Docker {
        self.docker.take().unwrap_or_else(|| Image_Docker::new())
    }

    pub fn get_docker(&self) -> &Image_Docker {
        self.docker.as_ref().unwrap_or_else(|| Image_Docker::default_instance())
    }

    fn get_docker_for_reflect(&self) -> &::protobuf::SingularPtrField<Image_Docker> {
        &self.docker
    }

    fn mut_docker_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Image_Docker> {
        &mut self.docker
    }

    // optional bool cached = 4;

    pub fn clear_cached(&mut self) {
        self.cached = ::std::option::Option::None;
    }

    pub fn has_cached(&self) -> bool {
        self.cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cached(&mut self, v: bool) {
        self.cached = ::std::option::Option::Some(v);
    }

    pub fn get_cached(&self) -> bool {
        self.cached.unwrap_or(true)
    }

    fn get_cached_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.cached
    }

    fn mut_cached_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.cached
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.appc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docker {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appc)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docker)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.appc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.docker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cached {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.appc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.docker.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cached {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image {
    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Image_Type>>(
                    "type",
                    Image::get_field_type_for_reflect,
                    Image::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image_Appc>>(
                    "appc",
                    Image::get_appc_for_reflect,
                    Image::mut_appc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image_Docker>>(
                    "docker",
                    Image::get_docker_for_reflect,
                    Image::mut_docker_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cached",
                    Image::get_cached_for_reflect,
                    Image::mut_cached_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image>(
                    "Image",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_appc();
        self.clear_docker();
        self.clear_cached();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image_Appc {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularField<::std::string::String>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Image_Appc {}

impl Image_Appc {
    pub fn new() -> Image_Appc {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image_Appc {
        static mut instance: ::protobuf::lazy::Lazy<Image_Appc> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image_Appc,
        };
        unsafe {
            instance.get(Image_Appc::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.id
    }

    // optional .mesos.v1.Labels labels = 3;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }
}

impl ::protobuf::Message for Image_Appc {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image_Appc {
    fn new() -> Image_Appc {
        Image_Appc::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image_Appc>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Image_Appc::get_name_for_reflect,
                    Image_Appc::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    Image_Appc::get_id_for_reflect,
                    Image_Appc::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    Image_Appc::get_labels_for_reflect,
                    Image_Appc::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image_Appc>(
                    "Image_Appc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image_Appc {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_id();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Appc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Appc {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image_Docker {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    credential: ::protobuf::SingularPtrField<Credential>,
    config: ::protobuf::SingularPtrField<Secret>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Image_Docker {}

impl Image_Docker {
    pub fn new() -> Image_Docker {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image_Docker {
        static mut instance: ::protobuf::lazy::Lazy<Image_Docker> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image_Docker,
        };
        unsafe {
            instance.get(Image_Docker::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional .mesos.v1.Credential credential = 2;

    pub fn clear_credential(&mut self) {
        self.credential.clear();
    }

    pub fn has_credential(&self) -> bool {
        self.credential.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential(&mut self, v: Credential) {
        self.credential = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential(&mut self) -> &mut Credential {
        if self.credential.is_none() {
            self.credential.set_default();
        }
        self.credential.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential(&mut self) -> Credential {
        self.credential.take().unwrap_or_else(|| Credential::new())
    }

    pub fn get_credential(&self) -> &Credential {
        self.credential.as_ref().unwrap_or_else(|| Credential::default_instance())
    }

    fn get_credential_for_reflect(&self) -> &::protobuf::SingularPtrField<Credential> {
        &self.credential
    }

    fn mut_credential_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Credential> {
        &mut self.credential
    }

    // optional .mesos.v1.Secret config = 3;

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: Secret) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut Secret {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> Secret {
        self.config.take().unwrap_or_else(|| Secret::new())
    }

    pub fn get_config(&self) -> &Secret {
        self.config.as_ref().unwrap_or_else(|| Secret::default_instance())
    }

    fn get_config_for_reflect(&self) -> &::protobuf::SingularPtrField<Secret> {
        &self.config
    }

    fn mut_config_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Secret> {
        &mut self.config
    }
}

impl ::protobuf::Message for Image_Docker {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.credential {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.credential)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.credential.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.credential.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image_Docker {
    fn new() -> Image_Docker {
        Image_Docker::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image_Docker>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Image_Docker::get_name_for_reflect,
                    Image_Docker::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Credential>>(
                    "credential",
                    Image_Docker::get_credential_for_reflect,
                    Image_Docker::mut_credential_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "config",
                    Image_Docker::get_config_for_reflect,
                    Image_Docker::mut_config_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image_Docker>(
                    "Image_Docker",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image_Docker {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_credential();
        self.clear_config();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Docker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Docker {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Image_Type {
    APPC = 1,
    DOCKER = 2,
}

impl ::protobuf::ProtobufEnum for Image_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Image_Type> {
        match value {
            1 => ::std::option::Option::Some(Image_Type::APPC),
            2 => ::std::option::Option::Some(Image_Type::DOCKER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Image_Type] = &[
            Image_Type::APPC,
            Image_Type::DOCKER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Image_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Image_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Image_Type {
}

impl ::protobuf::reflect::ProtobufValue for Image_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MountPropagation {
    // message fields
    mode: ::std::option::Option<MountPropagation_Mode>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MountPropagation {}

impl MountPropagation {
    pub fn new() -> MountPropagation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MountPropagation {
        static mut instance: ::protobuf::lazy::Lazy<MountPropagation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MountPropagation,
        };
        unsafe {
            instance.get(MountPropagation::new)
        }
    }

    // optional .mesos.v1.MountPropagation.Mode mode = 1;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: MountPropagation_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> MountPropagation_Mode {
        self.mode.unwrap_or(MountPropagation_Mode::UNKNOWN)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<MountPropagation_Mode> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<MountPropagation_Mode> {
        &mut self.mode
    }
}

impl ::protobuf::Message for MountPropagation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MountPropagation {
    fn new() -> MountPropagation {
        MountPropagation::new()
    }

    fn descriptor_static(_: ::std::option::Option<MountPropagation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MountPropagation_Mode>>(
                    "mode",
                    MountPropagation::get_mode_for_reflect,
                    MountPropagation::mut_mode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MountPropagation>(
                    "MountPropagation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MountPropagation {
    fn clear(&mut self) {
        self.clear_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MountPropagation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MountPropagation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MountPropagation_Mode {
    UNKNOWN = 0,
    HOST_TO_CONTAINER = 1,
    BIDIRECTIONAL = 2,
}

impl ::protobuf::ProtobufEnum for MountPropagation_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MountPropagation_Mode> {
        match value {
            0 => ::std::option::Option::Some(MountPropagation_Mode::UNKNOWN),
            1 => ::std::option::Option::Some(MountPropagation_Mode::HOST_TO_CONTAINER),
            2 => ::std::option::Option::Some(MountPropagation_Mode::BIDIRECTIONAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MountPropagation_Mode] = &[
            MountPropagation_Mode::UNKNOWN,
            MountPropagation_Mode::HOST_TO_CONTAINER,
            MountPropagation_Mode::BIDIRECTIONAL,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<MountPropagation_Mode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MountPropagation_Mode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MountPropagation_Mode {
}

impl ::protobuf::reflect::ProtobufValue for MountPropagation_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Volume {
    // message fields
    mode: ::std::option::Option<Volume_Mode>,
    container_path: ::protobuf::SingularField<::std::string::String>,
    host_path: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularPtrField<Image>,
    source: ::protobuf::SingularPtrField<Volume_Source>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Volume {}

impl Volume {
    pub fn new() -> Volume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume {
        static mut instance: ::protobuf::lazy::Lazy<Volume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume,
        };
        unsafe {
            instance.get(Volume::new)
        }
    }

    // required .mesos.v1.Volume.Mode mode = 3;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: Volume_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> Volume_Mode {
        self.mode.unwrap_or(Volume_Mode::RW)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<Volume_Mode> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<Volume_Mode> {
        &mut self.mode
    }

    // required string container_path = 1;

    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    pub fn has_container_path(&self) -> bool {
        self.container_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path(&mut self) -> &mut ::std::string::String {
        if self.container_path.is_none() {
            self.container_path.set_default();
        }
        self.container_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        self.container_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_container_path(&self) -> &str {
        match self.container_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_container_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.container_path
    }

    fn mut_container_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.container_path
    }

    // optional string host_path = 2;

    pub fn clear_host_path(&mut self) {
        self.host_path.clear();
    }

    pub fn has_host_path(&self) -> bool {
        self.host_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_path(&mut self, v: ::std::string::String) {
        self.host_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_path(&mut self) -> &mut ::std::string::String {
        if self.host_path.is_none() {
            self.host_path.set_default();
        }
        self.host_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_path(&mut self) -> ::std::string::String {
        self.host_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_host_path(&self) -> &str {
        match self.host_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_host_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.host_path
    }

    fn mut_host_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.host_path
    }

    // optional .mesos.v1.Image image = 4;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Image {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| Image::default_instance())
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularPtrField<Image> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Image> {
        &mut self.image
    }

    // optional .mesos.v1.Volume.Source source = 5;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Volume_Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Volume_Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Volume_Source {
        self.source.take().unwrap_or_else(|| Volume_Source::new())
    }

    pub fn get_source(&self) -> &Volume_Source {
        self.source.as_ref().unwrap_or_else(|| Volume_Source::default_instance())
    }

    fn get_source_for_reflect(&self) -> &::protobuf::SingularPtrField<Volume_Source> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Volume_Source> {
        &mut self.source
    }
}

impl ::protobuf::Message for Volume {
    fn is_initialized(&self) -> bool {
        if self.mode.is_none() {
            return false;
        }
        if self.container_path.is_none() {
            return false;
        }
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.container_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.host_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            os.write_enum(3, v.value())?;
        }
        if let Some(ref v) = self.container_path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.host_path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume {
    fn new() -> Volume {
        Volume::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Volume_Mode>>(
                    "mode",
                    Volume::get_mode_for_reflect,
                    Volume::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_path",
                    Volume::get_container_path_for_reflect,
                    Volume::mut_container_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host_path",
                    Volume::get_host_path_for_reflect,
                    Volume::mut_host_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                    "image",
                    Volume::get_image_for_reflect,
                    Volume::mut_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume_Source>>(
                    "source",
                    Volume::get_source_for_reflect,
                    Volume::mut_source_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume>(
                    "Volume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume {
    fn clear(&mut self) {
        self.clear_mode();
        self.clear_container_path();
        self.clear_host_path();
        self.clear_image();
        self.clear_source();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Volume_Source {
    // message fields
    field_type: ::std::option::Option<Volume_Source_Type>,
    docker_volume: ::protobuf::SingularPtrField<Volume_Source_DockerVolume>,
    host_path: ::protobuf::SingularPtrField<Volume_Source_HostPath>,
    sandbox_path: ::protobuf::SingularPtrField<Volume_Source_SandboxPath>,
    secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Volume_Source {}

impl Volume_Source {
    pub fn new() -> Volume_Source {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume_Source {
        static mut instance: ::protobuf::lazy::Lazy<Volume_Source> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume_Source,
        };
        unsafe {
            instance.get(Volume_Source::new)
        }
    }

    // optional .mesos.v1.Volume.Source.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Volume_Source_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Volume_Source_Type {
        self.field_type.unwrap_or(Volume_Source_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Volume_Source_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Volume_Source_Type> {
        &mut self.field_type
    }

    // optional .mesos.v1.Volume.Source.DockerVolume docker_volume = 2;

    pub fn clear_docker_volume(&mut self) {
        self.docker_volume.clear();
    }

    pub fn has_docker_volume(&self) -> bool {
        self.docker_volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_docker_volume(&mut self, v: Volume_Source_DockerVolume) {
        self.docker_volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker_volume(&mut self) -> &mut Volume_Source_DockerVolume {
        if self.docker_volume.is_none() {
            self.docker_volume.set_default();
        }
        self.docker_volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_docker_volume(&mut self) -> Volume_Source_DockerVolume {
        self.docker_volume.take().unwrap_or_else(|| Volume_Source_DockerVolume::new())
    }

    pub fn get_docker_volume(&self) -> &Volume_Source_DockerVolume {
        self.docker_volume.as_ref().unwrap_or_else(|| Volume_Source_DockerVolume::default_instance())
    }

    fn get_docker_volume_for_reflect(&self) -> &::protobuf::SingularPtrField<Volume_Source_DockerVolume> {
        &self.docker_volume
    }

    fn mut_docker_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Volume_Source_DockerVolume> {
        &mut self.docker_volume
    }

    // optional .mesos.v1.Volume.Source.HostPath host_path = 5;

    pub fn clear_host_path(&mut self) {
        self.host_path.clear();
    }

    pub fn has_host_path(&self) -> bool {
        self.host_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_path(&mut self, v: Volume_Source_HostPath) {
        self.host_path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_path(&mut self) -> &mut Volume_Source_HostPath {
        if self.host_path.is_none() {
            self.host_path.set_default();
        }
        self.host_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_path(&mut self) -> Volume_Source_HostPath {
        self.host_path.take().unwrap_or_else(|| Volume_Source_HostPath::new())
    }

    pub fn get_host_path(&self) -> &Volume_Source_HostPath {
        self.host_path.as_ref().unwrap_or_else(|| Volume_Source_HostPath::default_instance())
    }

    fn get_host_path_for_reflect(&self) -> &::protobuf::SingularPtrField<Volume_Source_HostPath> {
        &self.host_path
    }

    fn mut_host_path_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Volume_Source_HostPath> {
        &mut self.host_path
    }

    // optional .mesos.v1.Volume.Source.SandboxPath sandbox_path = 3;

    pub fn clear_sandbox_path(&mut self) {
        self.sandbox_path.clear();
    }

    pub fn has_sandbox_path(&self) -> bool {
        self.sandbox_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sandbox_path(&mut self, v: Volume_Source_SandboxPath) {
        self.sandbox_path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sandbox_path(&mut self) -> &mut Volume_Source_SandboxPath {
        if self.sandbox_path.is_none() {
            self.sandbox_path.set_default();
        }
        self.sandbox_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_sandbox_path(&mut self) -> Volume_Source_SandboxPath {
        self.sandbox_path.take().unwrap_or_else(|| Volume_Source_SandboxPath::new())
    }

    pub fn get_sandbox_path(&self) -> &Volume_Source_SandboxPath {
        self.sandbox_path.as_ref().unwrap_or_else(|| Volume_Source_SandboxPath::default_instance())
    }

    fn get_sandbox_path_for_reflect(&self) -> &::protobuf::SingularPtrField<Volume_Source_SandboxPath> {
        &self.sandbox_path
    }

    fn mut_sandbox_path_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Volume_Source_SandboxPath> {
        &mut self.sandbox_path
    }

    // optional .mesos.v1.Secret secret = 4;

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }

    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| Secret::default_instance())
    }

    fn get_secret_for_reflect(&self) -> &::protobuf::SingularPtrField<Secret> {
        &self.secret
    }

    fn mut_secret_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Secret> {
        &mut self.secret
    }
}

impl ::protobuf::Message for Volume_Source {
    fn is_initialized(&self) -> bool {
        for v in &self.docker_volume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.host_path {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sandbox_path {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docker_volume)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.host_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sandbox_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.docker_volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.host_path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sandbox_path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.docker_volume.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.host_path.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sandbox_path.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume_Source {
    fn new() -> Volume_Source {
        Volume_Source::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume_Source>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Volume_Source_Type>>(
                    "type",
                    Volume_Source::get_field_type_for_reflect,
                    Volume_Source::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume_Source_DockerVolume>>(
                    "docker_volume",
                    Volume_Source::get_docker_volume_for_reflect,
                    Volume_Source::mut_docker_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume_Source_HostPath>>(
                    "host_path",
                    Volume_Source::get_host_path_for_reflect,
                    Volume_Source::mut_host_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume_Source_SandboxPath>>(
                    "sandbox_path",
                    Volume_Source::get_sandbox_path_for_reflect,
                    Volume_Source::mut_sandbox_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "secret",
                    Volume_Source::get_secret_for_reflect,
                    Volume_Source::mut_secret_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume_Source>(
                    "Volume_Source",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume_Source {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_docker_volume();
        self.clear_host_path();
        self.clear_sandbox_path();
        self.clear_secret();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Volume_Source {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume_Source {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Volume_Source_DockerVolume {
    // message fields
    driver: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    driver_options: ::protobuf::SingularPtrField<Parameters>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Volume_Source_DockerVolume {}

impl Volume_Source_DockerVolume {
    pub fn new() -> Volume_Source_DockerVolume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume_Source_DockerVolume {
        static mut instance: ::protobuf::lazy::Lazy<Volume_Source_DockerVolume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume_Source_DockerVolume,
        };
        unsafe {
            instance.get(Volume_Source_DockerVolume::new)
        }
    }

    // optional string driver = 1;

    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver.set_default();
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_driver_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.driver
    }

    fn mut_driver_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.driver
    }

    // required string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional .mesos.v1.Parameters driver_options = 3;

    pub fn clear_driver_options(&mut self) {
        self.driver_options.clear();
    }

    pub fn has_driver_options(&self) -> bool {
        self.driver_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver_options(&mut self, v: Parameters) {
        self.driver_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver_options(&mut self) -> &mut Parameters {
        if self.driver_options.is_none() {
            self.driver_options.set_default();
        }
        self.driver_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver_options(&mut self) -> Parameters {
        self.driver_options.take().unwrap_or_else(|| Parameters::new())
    }

    pub fn get_driver_options(&self) -> &Parameters {
        self.driver_options.as_ref().unwrap_or_else(|| Parameters::default_instance())
    }

    fn get_driver_options_for_reflect(&self) -> &::protobuf::SingularPtrField<Parameters> {
        &self.driver_options
    }

    fn mut_driver_options_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Parameters> {
        &mut self.driver_options
    }
}

impl ::protobuf::Message for Volume_Source_DockerVolume {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.driver_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.driver_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.driver_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.driver.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.driver_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume_Source_DockerVolume {
    fn new() -> Volume_Source_DockerVolume {
        Volume_Source_DockerVolume::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume_Source_DockerVolume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "driver",
                    Volume_Source_DockerVolume::get_driver_for_reflect,
                    Volume_Source_DockerVolume::mut_driver_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Volume_Source_DockerVolume::get_name_for_reflect,
                    Volume_Source_DockerVolume::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Parameters>>(
                    "driver_options",
                    Volume_Source_DockerVolume::get_driver_options_for_reflect,
                    Volume_Source_DockerVolume::mut_driver_options_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume_Source_DockerVolume>(
                    "Volume_Source_DockerVolume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume_Source_DockerVolume {
    fn clear(&mut self) {
        self.clear_driver();
        self.clear_name();
        self.clear_driver_options();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Volume_Source_DockerVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume_Source_DockerVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Volume_Source_HostPath {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    mount_propagation: ::protobuf::SingularPtrField<MountPropagation>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Volume_Source_HostPath {}

impl Volume_Source_HostPath {
    pub fn new() -> Volume_Source_HostPath {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume_Source_HostPath {
        static mut instance: ::protobuf::lazy::Lazy<Volume_Source_HostPath> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume_Source_HostPath,
        };
        unsafe {
            instance.get(Volume_Source_HostPath::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional .mesos.v1.MountPropagation mount_propagation = 2;

    pub fn clear_mount_propagation(&mut self) {
        self.mount_propagation.clear();
    }

    pub fn has_mount_propagation(&self) -> bool {
        self.mount_propagation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mount_propagation(&mut self, v: MountPropagation) {
        self.mount_propagation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mount_propagation(&mut self) -> &mut MountPropagation {
        if self.mount_propagation.is_none() {
            self.mount_propagation.set_default();
        }
        self.mount_propagation.as_mut().unwrap()
    }

    // Take field
    pub fn take_mount_propagation(&mut self) -> MountPropagation {
        self.mount_propagation.take().unwrap_or_else(|| MountPropagation::new())
    }

    pub fn get_mount_propagation(&self) -> &MountPropagation {
        self.mount_propagation.as_ref().unwrap_or_else(|| MountPropagation::default_instance())
    }

    fn get_mount_propagation_for_reflect(&self) -> &::protobuf::SingularPtrField<MountPropagation> {
        &self.mount_propagation
    }

    fn mut_mount_propagation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<MountPropagation> {
        &mut self.mount_propagation
    }
}

impl ::protobuf::Message for Volume_Source_HostPath {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        for v in &self.mount_propagation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mount_propagation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.mount_propagation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.mount_propagation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume_Source_HostPath {
    fn new() -> Volume_Source_HostPath {
        Volume_Source_HostPath::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume_Source_HostPath>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    Volume_Source_HostPath::get_path_for_reflect,
                    Volume_Source_HostPath::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MountPropagation>>(
                    "mount_propagation",
                    Volume_Source_HostPath::get_mount_propagation_for_reflect,
                    Volume_Source_HostPath::mut_mount_propagation_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume_Source_HostPath>(
                    "Volume_Source_HostPath",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume_Source_HostPath {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_mount_propagation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Volume_Source_HostPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume_Source_HostPath {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Volume_Source_SandboxPath {
    // message fields
    field_type: ::std::option::Option<Volume_Source_SandboxPath_Type>,
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Volume_Source_SandboxPath {}

impl Volume_Source_SandboxPath {
    pub fn new() -> Volume_Source_SandboxPath {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume_Source_SandboxPath {
        static mut instance: ::protobuf::lazy::Lazy<Volume_Source_SandboxPath> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume_Source_SandboxPath,
        };
        unsafe {
            instance.get(Volume_Source_SandboxPath::new)
        }
    }

    // optional .mesos.v1.Volume.Source.SandboxPath.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Volume_Source_SandboxPath_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Volume_Source_SandboxPath_Type {
        self.field_type.unwrap_or(Volume_Source_SandboxPath_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Volume_Source_SandboxPath_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Volume_Source_SandboxPath_Type> {
        &mut self.field_type
    }

    // required string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for Volume_Source_SandboxPath {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume_Source_SandboxPath {
    fn new() -> Volume_Source_SandboxPath {
        Volume_Source_SandboxPath::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume_Source_SandboxPath>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Volume_Source_SandboxPath_Type>>(
                    "type",
                    Volume_Source_SandboxPath::get_field_type_for_reflect,
                    Volume_Source_SandboxPath::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    Volume_Source_SandboxPath::get_path_for_reflect,
                    Volume_Source_SandboxPath::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume_Source_SandboxPath>(
                    "Volume_Source_SandboxPath",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume_Source_SandboxPath {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Volume_Source_SandboxPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume_Source_SandboxPath {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Volume_Source_SandboxPath_Type {
    UNKNOWN = 0,
    SELF = 1,
    PARENT = 2,
}

impl ::protobuf::ProtobufEnum for Volume_Source_SandboxPath_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Volume_Source_SandboxPath_Type> {
        match value {
            0 => ::std::option::Option::Some(Volume_Source_SandboxPath_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Volume_Source_SandboxPath_Type::SELF),
            2 => ::std::option::Option::Some(Volume_Source_SandboxPath_Type::PARENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Volume_Source_SandboxPath_Type] = &[
            Volume_Source_SandboxPath_Type::UNKNOWN,
            Volume_Source_SandboxPath_Type::SELF,
            Volume_Source_SandboxPath_Type::PARENT,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Volume_Source_SandboxPath_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Volume_Source_SandboxPath_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Volume_Source_SandboxPath_Type {
}

impl ::protobuf::reflect::ProtobufValue for Volume_Source_SandboxPath_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Volume_Source_Type {
    UNKNOWN = 0,
    DOCKER_VOLUME = 1,
    HOST_PATH = 4,
    SANDBOX_PATH = 2,
    SECRET = 3,
}

impl ::protobuf::ProtobufEnum for Volume_Source_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Volume_Source_Type> {
        match value {
            0 => ::std::option::Option::Some(Volume_Source_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Volume_Source_Type::DOCKER_VOLUME),
            4 => ::std::option::Option::Some(Volume_Source_Type::HOST_PATH),
            2 => ::std::option::Option::Some(Volume_Source_Type::SANDBOX_PATH),
            3 => ::std::option::Option::Some(Volume_Source_Type::SECRET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Volume_Source_Type] = &[
            Volume_Source_Type::UNKNOWN,
            Volume_Source_Type::DOCKER_VOLUME,
            Volume_Source_Type::HOST_PATH,
            Volume_Source_Type::SANDBOX_PATH,
            Volume_Source_Type::SECRET,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Volume_Source_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Volume_Source_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Volume_Source_Type {
}

impl ::protobuf::reflect::ProtobufValue for Volume_Source_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Volume_Mode {
    RW = 1,
    RO = 2,
}

impl ::protobuf::ProtobufEnum for Volume_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Volume_Mode> {
        match value {
            1 => ::std::option::Option::Some(Volume_Mode::RW),
            2 => ::std::option::Option::Some(Volume_Mode::RO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Volume_Mode] = &[
            Volume_Mode::RW,
            Volume_Mode::RO,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Volume_Mode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Volume_Mode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Volume_Mode {
}

impl ::protobuf::reflect::ProtobufValue for Volume_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkInfo {
    // message fields
    ip_addresses: ::protobuf::RepeatedField<NetworkInfo_IPAddress>,
    name: ::protobuf::SingularField<::std::string::String>,
    groups: ::protobuf::RepeatedField<::std::string::String>,
    labels: ::protobuf::SingularPtrField<Labels>,
    port_mappings: ::protobuf::RepeatedField<NetworkInfo_PortMapping>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NetworkInfo {}

impl NetworkInfo {
    pub fn new() -> NetworkInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NetworkInfo {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfo,
        };
        unsafe {
            instance.get(NetworkInfo::new)
        }
    }

    // repeated .mesos.v1.NetworkInfo.IPAddress ip_addresses = 5;

    pub fn clear_ip_addresses(&mut self) {
        self.ip_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_addresses(&mut self, v: ::protobuf::RepeatedField<NetworkInfo_IPAddress>) {
        self.ip_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ip_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo_IPAddress> {
        &mut self.ip_addresses
    }

    // Take field
    pub fn take_ip_addresses(&mut self) -> ::protobuf::RepeatedField<NetworkInfo_IPAddress> {
        ::std::mem::replace(&mut self.ip_addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_ip_addresses(&self) -> &[NetworkInfo_IPAddress] {
        &self.ip_addresses
    }

    fn get_ip_addresses_for_reflect(&self) -> &::protobuf::RepeatedField<NetworkInfo_IPAddress> {
        &self.ip_addresses
    }

    fn mut_ip_addresses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo_IPAddress> {
        &mut self.ip_addresses
    }

    // optional string name = 6;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // repeated string groups = 3;

    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    pub fn get_groups(&self) -> &[::std::string::String] {
        &self.groups
    }

    fn get_groups_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.groups
    }

    fn mut_groups_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.groups
    }

    // optional .mesos.v1.Labels labels = 4;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }

    // repeated .mesos.v1.NetworkInfo.PortMapping port_mappings = 7;

    pub fn clear_port_mappings(&mut self) {
        self.port_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_mappings(&mut self, v: ::protobuf::RepeatedField<NetworkInfo_PortMapping>) {
        self.port_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port_mappings(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo_PortMapping> {
        &mut self.port_mappings
    }

    // Take field
    pub fn take_port_mappings(&mut self) -> ::protobuf::RepeatedField<NetworkInfo_PortMapping> {
        ::std::mem::replace(&mut self.port_mappings, ::protobuf::RepeatedField::new())
    }

    pub fn get_port_mappings(&self) -> &[NetworkInfo_PortMapping] {
        &self.port_mappings
    }

    fn get_port_mappings_for_reflect(&self) -> &::protobuf::RepeatedField<NetworkInfo_PortMapping> {
        &self.port_mappings
    }

    fn mut_port_mappings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo_PortMapping> {
        &mut self.port_mappings
    }
}

impl ::protobuf::Message for NetworkInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.ip_addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.port_mappings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ip_addresses)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.groups)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.port_mappings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ip_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.groups {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.port_mappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ip_addresses {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.groups {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.port_mappings {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NetworkInfo {
    fn new() -> NetworkInfo {
        NetworkInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<NetworkInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkInfo_IPAddress>>(
                    "ip_addresses",
                    NetworkInfo::get_ip_addresses_for_reflect,
                    NetworkInfo::mut_ip_addresses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    NetworkInfo::get_name_for_reflect,
                    NetworkInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "groups",
                    NetworkInfo::get_groups_for_reflect,
                    NetworkInfo::mut_groups_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    NetworkInfo::get_labels_for_reflect,
                    NetworkInfo::mut_labels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkInfo_PortMapping>>(
                    "port_mappings",
                    NetworkInfo::get_port_mappings_for_reflect,
                    NetworkInfo::mut_port_mappings_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfo>(
                    "NetworkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NetworkInfo {
    fn clear(&mut self) {
        self.clear_ip_addresses();
        self.clear_name();
        self.clear_groups();
        self.clear_labels();
        self.clear_port_mappings();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkInfo_IPAddress {
    // message fields
    protocol: ::std::option::Option<NetworkInfo_Protocol>,
    ip_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NetworkInfo_IPAddress {}

impl NetworkInfo_IPAddress {
    pub fn new() -> NetworkInfo_IPAddress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NetworkInfo_IPAddress {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfo_IPAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfo_IPAddress,
        };
        unsafe {
            instance.get(NetworkInfo_IPAddress::new)
        }
    }

    // optional .mesos.v1.NetworkInfo.Protocol protocol = 1;

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: NetworkInfo_Protocol) {
        self.protocol = ::std::option::Option::Some(v);
    }

    pub fn get_protocol(&self) -> NetworkInfo_Protocol {
        self.protocol.unwrap_or(NetworkInfo_Protocol::IPv4)
    }

    fn get_protocol_for_reflect(&self) -> &::std::option::Option<NetworkInfo_Protocol> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::std::option::Option<NetworkInfo_Protocol> {
        &mut self.protocol
    }

    // optional string ip_address = 2;

    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    pub fn has_ip_address(&self) -> bool {
        self.ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        if self.ip_address.is_none() {
            self.ip_address.set_default();
        }
        self.ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        self.ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip_address(&self) -> &str {
        match self.ip_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ip_address_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ip_address
    }

    fn mut_ip_address_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ip_address
    }
}

impl ::protobuf::Message for NetworkInfo_IPAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.protocol = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.ip_address.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NetworkInfo_IPAddress {
    fn new() -> NetworkInfo_IPAddress {
        NetworkInfo_IPAddress::new()
    }

    fn descriptor_static(_: ::std::option::Option<NetworkInfo_IPAddress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NetworkInfo_Protocol>>(
                    "protocol",
                    NetworkInfo_IPAddress::get_protocol_for_reflect,
                    NetworkInfo_IPAddress::mut_protocol_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_address",
                    NetworkInfo_IPAddress::get_ip_address_for_reflect,
                    NetworkInfo_IPAddress::mut_ip_address_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfo_IPAddress>(
                    "NetworkInfo_IPAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NetworkInfo_IPAddress {
    fn clear(&mut self) {
        self.clear_protocol();
        self.clear_ip_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfo_IPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfo_IPAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkInfo_PortMapping {
    // message fields
    host_port: ::std::option::Option<u32>,
    container_port: ::std::option::Option<u32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NetworkInfo_PortMapping {}

impl NetworkInfo_PortMapping {
    pub fn new() -> NetworkInfo_PortMapping {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NetworkInfo_PortMapping {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfo_PortMapping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfo_PortMapping,
        };
        unsafe {
            instance.get(NetworkInfo_PortMapping::new)
        }
    }

    // required uint32 host_port = 1;

    pub fn clear_host_port(&mut self) {
        self.host_port = ::std::option::Option::None;
    }

    pub fn has_host_port(&self) -> bool {
        self.host_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_port(&mut self, v: u32) {
        self.host_port = ::std::option::Option::Some(v);
    }

    pub fn get_host_port(&self) -> u32 {
        self.host_port.unwrap_or(0)
    }

    fn get_host_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.host_port
    }

    fn mut_host_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.host_port
    }

    // required uint32 container_port = 2;

    pub fn clear_container_port(&mut self) {
        self.container_port = ::std::option::Option::None;
    }

    pub fn has_container_port(&self) -> bool {
        self.container_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_port(&mut self, v: u32) {
        self.container_port = ::std::option::Option::Some(v);
    }

    pub fn get_container_port(&self) -> u32 {
        self.container_port.unwrap_or(0)
    }

    fn get_container_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.container_port
    }

    fn mut_container_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.container_port
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_protocol_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.protocol
    }
}

impl ::protobuf::Message for NetworkInfo_PortMapping {
    fn is_initialized(&self) -> bool {
        if self.host_port.is_none() {
            return false;
        }
        if self.container_port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.host_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.container_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.host_port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.container_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.host_port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.container_port {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NetworkInfo_PortMapping {
    fn new() -> NetworkInfo_PortMapping {
        NetworkInfo_PortMapping::new()
    }

    fn descriptor_static(_: ::std::option::Option<NetworkInfo_PortMapping>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "host_port",
                    NetworkInfo_PortMapping::get_host_port_for_reflect,
                    NetworkInfo_PortMapping::mut_host_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "container_port",
                    NetworkInfo_PortMapping::get_container_port_for_reflect,
                    NetworkInfo_PortMapping::mut_container_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocol",
                    NetworkInfo_PortMapping::get_protocol_for_reflect,
                    NetworkInfo_PortMapping::mut_protocol_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfo_PortMapping>(
                    "NetworkInfo_PortMapping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NetworkInfo_PortMapping {
    fn clear(&mut self) {
        self.clear_host_port();
        self.clear_container_port();
        self.clear_protocol();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfo_PortMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfo_PortMapping {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NetworkInfo_Protocol {
    IPv4 = 1,
    IPv6 = 2,
}

impl ::protobuf::ProtobufEnum for NetworkInfo_Protocol {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NetworkInfo_Protocol> {
        match value {
            1 => ::std::option::Option::Some(NetworkInfo_Protocol::IPv4),
            2 => ::std::option::Option::Some(NetworkInfo_Protocol::IPv6),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NetworkInfo_Protocol] = &[
            NetworkInfo_Protocol::IPv4,
            NetworkInfo_Protocol::IPv6,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<NetworkInfo_Protocol>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NetworkInfo_Protocol", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NetworkInfo_Protocol {
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfo_Protocol {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CapabilityInfo {
    // message fields
    capabilities: ::std::vec::Vec<CapabilityInfo_Capability>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CapabilityInfo {}

impl CapabilityInfo {
    pub fn new() -> CapabilityInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CapabilityInfo {
        static mut instance: ::protobuf::lazy::Lazy<CapabilityInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CapabilityInfo,
        };
        unsafe {
            instance.get(CapabilityInfo::new)
        }
    }

    // repeated .mesos.v1.CapabilityInfo.Capability capabilities = 1;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::std::vec::Vec<CapabilityInfo_Capability>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities(&mut self) -> &mut ::std::vec::Vec<CapabilityInfo_Capability> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::std::vec::Vec<CapabilityInfo_Capability> {
        ::std::mem::replace(&mut self.capabilities, ::std::vec::Vec::new())
    }

    pub fn get_capabilities(&self) -> &[CapabilityInfo_Capability] {
        &self.capabilities
    }

    fn get_capabilities_for_reflect(&self) -> &::std::vec::Vec<CapabilityInfo_Capability> {
        &self.capabilities
    }

    fn mut_capabilities_for_reflect(&mut self) -> &mut ::std::vec::Vec<CapabilityInfo_Capability> {
        &mut self.capabilities
    }
}

impl ::protobuf::Message for CapabilityInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.capabilities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.capabilities {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.capabilities {
            os.write_enum(1, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CapabilityInfo {
    fn new() -> CapabilityInfo {
        CapabilityInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CapabilityInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CapabilityInfo_Capability>>(
                    "capabilities",
                    CapabilityInfo::get_capabilities_for_reflect,
                    CapabilityInfo::mut_capabilities_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CapabilityInfo>(
                    "CapabilityInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CapabilityInfo {
    fn clear(&mut self) {
        self.clear_capabilities();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CapabilityInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilityInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CapabilityInfo_Capability {
    UNKNOWN = 0,
    CHOWN = 1000,
    DAC_OVERRIDE = 1001,
    DAC_READ_SEARCH = 1002,
    FOWNER = 1003,
    FSETID = 1004,
    KILL = 1005,
    SETGID = 1006,
    SETUID = 1007,
    SETPCAP = 1008,
    LINUX_IMMUTABLE = 1009,
    NET_BIND_SERVICE = 1010,
    NET_BROADCAST = 1011,
    NET_ADMIN = 1012,
    NET_RAW = 1013,
    IPC_LOCK = 1014,
    IPC_OWNER = 1015,
    SYS_MODULE = 1016,
    SYS_RAWIO = 1017,
    SYS_CHROOT = 1018,
    SYS_PTRACE = 1019,
    SYS_PACCT = 1020,
    SYS_ADMIN = 1021,
    SYS_BOOT = 1022,
    SYS_NICE = 1023,
    SYS_RESOURCE = 1024,
    SYS_TIME = 1025,
    SYS_TTY_CONFIG = 1026,
    MKNOD = 1027,
    LEASE = 1028,
    AUDIT_WRITE = 1029,
    AUDIT_CONTROL = 1030,
    SETFCAP = 1031,
    MAC_OVERRIDE = 1032,
    MAC_ADMIN = 1033,
    SYSLOG = 1034,
    WAKE_ALARM = 1035,
    BLOCK_SUSPEND = 1036,
    AUDIT_READ = 1037,
}

impl ::protobuf::ProtobufEnum for CapabilityInfo_Capability {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CapabilityInfo_Capability> {
        match value {
            0 => ::std::option::Option::Some(CapabilityInfo_Capability::UNKNOWN),
            1000 => ::std::option::Option::Some(CapabilityInfo_Capability::CHOWN),
            1001 => ::std::option::Option::Some(CapabilityInfo_Capability::DAC_OVERRIDE),
            1002 => ::std::option::Option::Some(CapabilityInfo_Capability::DAC_READ_SEARCH),
            1003 => ::std::option::Option::Some(CapabilityInfo_Capability::FOWNER),
            1004 => ::std::option::Option::Some(CapabilityInfo_Capability::FSETID),
            1005 => ::std::option::Option::Some(CapabilityInfo_Capability::KILL),
            1006 => ::std::option::Option::Some(CapabilityInfo_Capability::SETGID),
            1007 => ::std::option::Option::Some(CapabilityInfo_Capability::SETUID),
            1008 => ::std::option::Option::Some(CapabilityInfo_Capability::SETPCAP),
            1009 => ::std::option::Option::Some(CapabilityInfo_Capability::LINUX_IMMUTABLE),
            1010 => ::std::option::Option::Some(CapabilityInfo_Capability::NET_BIND_SERVICE),
            1011 => ::std::option::Option::Some(CapabilityInfo_Capability::NET_BROADCAST),
            1012 => ::std::option::Option::Some(CapabilityInfo_Capability::NET_ADMIN),
            1013 => ::std::option::Option::Some(CapabilityInfo_Capability::NET_RAW),
            1014 => ::std::option::Option::Some(CapabilityInfo_Capability::IPC_LOCK),
            1015 => ::std::option::Option::Some(CapabilityInfo_Capability::IPC_OWNER),
            1016 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_MODULE),
            1017 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_RAWIO),
            1018 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_CHROOT),
            1019 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_PTRACE),
            1020 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_PACCT),
            1021 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_ADMIN),
            1022 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_BOOT),
            1023 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_NICE),
            1024 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_RESOURCE),
            1025 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_TIME),
            1026 => ::std::option::Option::Some(CapabilityInfo_Capability::SYS_TTY_CONFIG),
            1027 => ::std::option::Option::Some(CapabilityInfo_Capability::MKNOD),
            1028 => ::std::option::Option::Some(CapabilityInfo_Capability::LEASE),
            1029 => ::std::option::Option::Some(CapabilityInfo_Capability::AUDIT_WRITE),
            1030 => ::std::option::Option::Some(CapabilityInfo_Capability::AUDIT_CONTROL),
            1031 => ::std::option::Option::Some(CapabilityInfo_Capability::SETFCAP),
            1032 => ::std::option::Option::Some(CapabilityInfo_Capability::MAC_OVERRIDE),
            1033 => ::std::option::Option::Some(CapabilityInfo_Capability::MAC_ADMIN),
            1034 => ::std::option::Option::Some(CapabilityInfo_Capability::SYSLOG),
            1035 => ::std::option::Option::Some(CapabilityInfo_Capability::WAKE_ALARM),
            1036 => ::std::option::Option::Some(CapabilityInfo_Capability::BLOCK_SUSPEND),
            1037 => ::std::option::Option::Some(CapabilityInfo_Capability::AUDIT_READ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CapabilityInfo_Capability] = &[
            CapabilityInfo_Capability::UNKNOWN,
            CapabilityInfo_Capability::CHOWN,
            CapabilityInfo_Capability::DAC_OVERRIDE,
            CapabilityInfo_Capability::DAC_READ_SEARCH,
            CapabilityInfo_Capability::FOWNER,
            CapabilityInfo_Capability::FSETID,
            CapabilityInfo_Capability::KILL,
            CapabilityInfo_Capability::SETGID,
            CapabilityInfo_Capability::SETUID,
            CapabilityInfo_Capability::SETPCAP,
            CapabilityInfo_Capability::LINUX_IMMUTABLE,
            CapabilityInfo_Capability::NET_BIND_SERVICE,
            CapabilityInfo_Capability::NET_BROADCAST,
            CapabilityInfo_Capability::NET_ADMIN,
            CapabilityInfo_Capability::NET_RAW,
            CapabilityInfo_Capability::IPC_LOCK,
            CapabilityInfo_Capability::IPC_OWNER,
            CapabilityInfo_Capability::SYS_MODULE,
            CapabilityInfo_Capability::SYS_RAWIO,
            CapabilityInfo_Capability::SYS_CHROOT,
            CapabilityInfo_Capability::SYS_PTRACE,
            CapabilityInfo_Capability::SYS_PACCT,
            CapabilityInfo_Capability::SYS_ADMIN,
            CapabilityInfo_Capability::SYS_BOOT,
            CapabilityInfo_Capability::SYS_NICE,
            CapabilityInfo_Capability::SYS_RESOURCE,
            CapabilityInfo_Capability::SYS_TIME,
            CapabilityInfo_Capability::SYS_TTY_CONFIG,
            CapabilityInfo_Capability::MKNOD,
            CapabilityInfo_Capability::LEASE,
            CapabilityInfo_Capability::AUDIT_WRITE,
            CapabilityInfo_Capability::AUDIT_CONTROL,
            CapabilityInfo_Capability::SETFCAP,
            CapabilityInfo_Capability::MAC_OVERRIDE,
            CapabilityInfo_Capability::MAC_ADMIN,
            CapabilityInfo_Capability::SYSLOG,
            CapabilityInfo_Capability::WAKE_ALARM,
            CapabilityInfo_Capability::BLOCK_SUSPEND,
            CapabilityInfo_Capability::AUDIT_READ,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CapabilityInfo_Capability>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CapabilityInfo_Capability", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CapabilityInfo_Capability {
}

impl ::protobuf::reflect::ProtobufValue for CapabilityInfo_Capability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxInfo {
    // message fields
    capability_info: ::protobuf::SingularPtrField<CapabilityInfo>,
    bounding_capabilities: ::protobuf::SingularPtrField<CapabilityInfo>,
    effective_capabilities: ::protobuf::SingularPtrField<CapabilityInfo>,
    share_pid_namespace: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LinuxInfo {}

impl LinuxInfo {
    pub fn new() -> LinuxInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LinuxInfo {
        static mut instance: ::protobuf::lazy::Lazy<LinuxInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LinuxInfo,
        };
        unsafe {
            instance.get(LinuxInfo::new)
        }
    }

    // optional .mesos.v1.CapabilityInfo capability_info = 1;

    pub fn clear_capability_info(&mut self) {
        self.capability_info.clear();
    }

    pub fn has_capability_info(&self) -> bool {
        self.capability_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capability_info(&mut self, v: CapabilityInfo) {
        self.capability_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capability_info(&mut self) -> &mut CapabilityInfo {
        if self.capability_info.is_none() {
            self.capability_info.set_default();
        }
        self.capability_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_capability_info(&mut self) -> CapabilityInfo {
        self.capability_info.take().unwrap_or_else(|| CapabilityInfo::new())
    }

    pub fn get_capability_info(&self) -> &CapabilityInfo {
        self.capability_info.as_ref().unwrap_or_else(|| CapabilityInfo::default_instance())
    }

    fn get_capability_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CapabilityInfo> {
        &self.capability_info
    }

    fn mut_capability_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CapabilityInfo> {
        &mut self.capability_info
    }

    // optional .mesos.v1.CapabilityInfo bounding_capabilities = 2;

    pub fn clear_bounding_capabilities(&mut self) {
        self.bounding_capabilities.clear();
    }

    pub fn has_bounding_capabilities(&self) -> bool {
        self.bounding_capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounding_capabilities(&mut self, v: CapabilityInfo) {
        self.bounding_capabilities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bounding_capabilities(&mut self) -> &mut CapabilityInfo {
        if self.bounding_capabilities.is_none() {
            self.bounding_capabilities.set_default();
        }
        self.bounding_capabilities.as_mut().unwrap()
    }

    // Take field
    pub fn take_bounding_capabilities(&mut self) -> CapabilityInfo {
        self.bounding_capabilities.take().unwrap_or_else(|| CapabilityInfo::new())
    }

    pub fn get_bounding_capabilities(&self) -> &CapabilityInfo {
        self.bounding_capabilities.as_ref().unwrap_or_else(|| CapabilityInfo::default_instance())
    }

    fn get_bounding_capabilities_for_reflect(&self) -> &::protobuf::SingularPtrField<CapabilityInfo> {
        &self.bounding_capabilities
    }

    fn mut_bounding_capabilities_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CapabilityInfo> {
        &mut self.bounding_capabilities
    }

    // optional .mesos.v1.CapabilityInfo effective_capabilities = 3;

    pub fn clear_effective_capabilities(&mut self) {
        self.effective_capabilities.clear();
    }

    pub fn has_effective_capabilities(&self) -> bool {
        self.effective_capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effective_capabilities(&mut self, v: CapabilityInfo) {
        self.effective_capabilities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effective_capabilities(&mut self) -> &mut CapabilityInfo {
        if self.effective_capabilities.is_none() {
            self.effective_capabilities.set_default();
        }
        self.effective_capabilities.as_mut().unwrap()
    }

    // Take field
    pub fn take_effective_capabilities(&mut self) -> CapabilityInfo {
        self.effective_capabilities.take().unwrap_or_else(|| CapabilityInfo::new())
    }

    pub fn get_effective_capabilities(&self) -> &CapabilityInfo {
        self.effective_capabilities.as_ref().unwrap_or_else(|| CapabilityInfo::default_instance())
    }

    fn get_effective_capabilities_for_reflect(&self) -> &::protobuf::SingularPtrField<CapabilityInfo> {
        &self.effective_capabilities
    }

    fn mut_effective_capabilities_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CapabilityInfo> {
        &mut self.effective_capabilities
    }

    // optional bool share_pid_namespace = 4;

    pub fn clear_share_pid_namespace(&mut self) {
        self.share_pid_namespace = ::std::option::Option::None;
    }

    pub fn has_share_pid_namespace(&self) -> bool {
        self.share_pid_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_share_pid_namespace(&mut self, v: bool) {
        self.share_pid_namespace = ::std::option::Option::Some(v);
    }

    pub fn get_share_pid_namespace(&self) -> bool {
        self.share_pid_namespace.unwrap_or(false)
    }

    fn get_share_pid_namespace_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.share_pid_namespace
    }

    fn mut_share_pid_namespace_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.share_pid_namespace
    }
}

impl ::protobuf::Message for LinuxInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.capability_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bounding_capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.effective_capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capability_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bounding_capabilities)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.effective_capabilities)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.share_pid_namespace = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capability_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bounding_capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.effective_capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.share_pid_namespace {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capability_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bounding_capabilities.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.effective_capabilities.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.share_pid_namespace {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LinuxInfo {
    fn new() -> LinuxInfo {
        LinuxInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<LinuxInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CapabilityInfo>>(
                    "capability_info",
                    LinuxInfo::get_capability_info_for_reflect,
                    LinuxInfo::mut_capability_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CapabilityInfo>>(
                    "bounding_capabilities",
                    LinuxInfo::get_bounding_capabilities_for_reflect,
                    LinuxInfo::mut_bounding_capabilities_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CapabilityInfo>>(
                    "effective_capabilities",
                    LinuxInfo::get_effective_capabilities_for_reflect,
                    LinuxInfo::mut_effective_capabilities_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "share_pid_namespace",
                    LinuxInfo::get_share_pid_namespace_for_reflect,
                    LinuxInfo::mut_share_pid_namespace_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LinuxInfo>(
                    "LinuxInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LinuxInfo {
    fn clear(&mut self) {
        self.clear_capability_info();
        self.clear_bounding_capabilities();
        self.clear_effective_capabilities();
        self.clear_share_pid_namespace();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RLimitInfo {
    // message fields
    rlimits: ::protobuf::RepeatedField<RLimitInfo_RLimit>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RLimitInfo {}

impl RLimitInfo {
    pub fn new() -> RLimitInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RLimitInfo {
        static mut instance: ::protobuf::lazy::Lazy<RLimitInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RLimitInfo,
        };
        unsafe {
            instance.get(RLimitInfo::new)
        }
    }

    // repeated .mesos.v1.RLimitInfo.RLimit rlimits = 1;

    pub fn clear_rlimits(&mut self) {
        self.rlimits.clear();
    }

    // Param is passed by value, moved
    pub fn set_rlimits(&mut self, v: ::protobuf::RepeatedField<RLimitInfo_RLimit>) {
        self.rlimits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rlimits(&mut self) -> &mut ::protobuf::RepeatedField<RLimitInfo_RLimit> {
        &mut self.rlimits
    }

    // Take field
    pub fn take_rlimits(&mut self) -> ::protobuf::RepeatedField<RLimitInfo_RLimit> {
        ::std::mem::replace(&mut self.rlimits, ::protobuf::RepeatedField::new())
    }

    pub fn get_rlimits(&self) -> &[RLimitInfo_RLimit] {
        &self.rlimits
    }

    fn get_rlimits_for_reflect(&self) -> &::protobuf::RepeatedField<RLimitInfo_RLimit> {
        &self.rlimits
    }

    fn mut_rlimits_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<RLimitInfo_RLimit> {
        &mut self.rlimits
    }
}

impl ::protobuf::Message for RLimitInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.rlimits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rlimits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rlimits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rlimits {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RLimitInfo {
    fn new() -> RLimitInfo {
        RLimitInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<RLimitInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RLimitInfo_RLimit>>(
                    "rlimits",
                    RLimitInfo::get_rlimits_for_reflect,
                    RLimitInfo::mut_rlimits_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RLimitInfo>(
                    "RLimitInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RLimitInfo {
    fn clear(&mut self) {
        self.clear_rlimits();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RLimitInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RLimitInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RLimitInfo_RLimit {
    // message fields
    field_type: ::std::option::Option<RLimitInfo_RLimit_Type>,
    hard: ::std::option::Option<u64>,
    soft: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RLimitInfo_RLimit {}

impl RLimitInfo_RLimit {
    pub fn new() -> RLimitInfo_RLimit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RLimitInfo_RLimit {
        static mut instance: ::protobuf::lazy::Lazy<RLimitInfo_RLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RLimitInfo_RLimit,
        };
        unsafe {
            instance.get(RLimitInfo_RLimit::new)
        }
    }

    // optional .mesos.v1.RLimitInfo.RLimit.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: RLimitInfo_RLimit_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> RLimitInfo_RLimit_Type {
        self.field_type.unwrap_or(RLimitInfo_RLimit_Type::UNKNOWN)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<RLimitInfo_RLimit_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<RLimitInfo_RLimit_Type> {
        &mut self.field_type
    }

    // optional uint64 hard = 2;

    pub fn clear_hard(&mut self) {
        self.hard = ::std::option::Option::None;
    }

    pub fn has_hard(&self) -> bool {
        self.hard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hard(&mut self, v: u64) {
        self.hard = ::std::option::Option::Some(v);
    }

    pub fn get_hard(&self) -> u64 {
        self.hard.unwrap_or(0)
    }

    fn get_hard_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.hard
    }

    fn mut_hard_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.hard
    }

    // optional uint64 soft = 3;

    pub fn clear_soft(&mut self) {
        self.soft = ::std::option::Option::None;
    }

    pub fn has_soft(&self) -> bool {
        self.soft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soft(&mut self, v: u64) {
        self.soft = ::std::option::Option::Some(v);
    }

    pub fn get_soft(&self) -> u64 {
        self.soft.unwrap_or(0)
    }

    fn get_soft_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.soft
    }

    fn mut_soft_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.soft
    }
}

impl ::protobuf::Message for RLimitInfo_RLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hard = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.soft = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.hard {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.soft {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.hard {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.soft {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RLimitInfo_RLimit {
    fn new() -> RLimitInfo_RLimit {
        RLimitInfo_RLimit::new()
    }

    fn descriptor_static(_: ::std::option::Option<RLimitInfo_RLimit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RLimitInfo_RLimit_Type>>(
                    "type",
                    RLimitInfo_RLimit::get_field_type_for_reflect,
                    RLimitInfo_RLimit::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "hard",
                    RLimitInfo_RLimit::get_hard_for_reflect,
                    RLimitInfo_RLimit::mut_hard_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "soft",
                    RLimitInfo_RLimit::get_soft_for_reflect,
                    RLimitInfo_RLimit::mut_soft_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RLimitInfo_RLimit>(
                    "RLimitInfo_RLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RLimitInfo_RLimit {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_hard();
        self.clear_soft();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RLimitInfo_RLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RLimitInfo_RLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RLimitInfo_RLimit_Type {
    UNKNOWN = 0,
    RLMT_AS = 1,
    RLMT_CORE = 2,
    RLMT_CPU = 3,
    RLMT_DATA = 4,
    RLMT_FSIZE = 5,
    RLMT_LOCKS = 6,
    RLMT_MEMLOCK = 7,
    RLMT_MSGQUEUE = 8,
    RLMT_NICE = 9,
    RLMT_NOFILE = 10,
    RLMT_NPROC = 11,
    RLMT_RSS = 12,
    RLMT_RTPRIO = 13,
    RLMT_RTTIME = 14,
    RLMT_SIGPENDING = 15,
    RLMT_STACK = 16,
}

impl ::protobuf::ProtobufEnum for RLimitInfo_RLimit_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RLimitInfo_RLimit_Type> {
        match value {
            0 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::UNKNOWN),
            1 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_AS),
            2 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_CORE),
            3 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_CPU),
            4 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_DATA),
            5 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_FSIZE),
            6 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_LOCKS),
            7 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_MEMLOCK),
            8 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_MSGQUEUE),
            9 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_NICE),
            10 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_NOFILE),
            11 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_NPROC),
            12 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_RSS),
            13 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_RTPRIO),
            14 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_RTTIME),
            15 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_SIGPENDING),
            16 => ::std::option::Option::Some(RLimitInfo_RLimit_Type::RLMT_STACK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RLimitInfo_RLimit_Type] = &[
            RLimitInfo_RLimit_Type::UNKNOWN,
            RLimitInfo_RLimit_Type::RLMT_AS,
            RLimitInfo_RLimit_Type::RLMT_CORE,
            RLimitInfo_RLimit_Type::RLMT_CPU,
            RLimitInfo_RLimit_Type::RLMT_DATA,
            RLimitInfo_RLimit_Type::RLMT_FSIZE,
            RLimitInfo_RLimit_Type::RLMT_LOCKS,
            RLimitInfo_RLimit_Type::RLMT_MEMLOCK,
            RLimitInfo_RLimit_Type::RLMT_MSGQUEUE,
            RLimitInfo_RLimit_Type::RLMT_NICE,
            RLimitInfo_RLimit_Type::RLMT_NOFILE,
            RLimitInfo_RLimit_Type::RLMT_NPROC,
            RLimitInfo_RLimit_Type::RLMT_RSS,
            RLimitInfo_RLimit_Type::RLMT_RTPRIO,
            RLimitInfo_RLimit_Type::RLMT_RTTIME,
            RLimitInfo_RLimit_Type::RLMT_SIGPENDING,
            RLimitInfo_RLimit_Type::RLMT_STACK,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<RLimitInfo_RLimit_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RLimitInfo_RLimit_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RLimitInfo_RLimit_Type {
}

impl ::protobuf::reflect::ProtobufValue for RLimitInfo_RLimit_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TTYInfo {
    // message fields
    window_size: ::protobuf::SingularPtrField<TTYInfo_WindowSize>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TTYInfo {}

impl TTYInfo {
    pub fn new() -> TTYInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TTYInfo {
        static mut instance: ::protobuf::lazy::Lazy<TTYInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TTYInfo,
        };
        unsafe {
            instance.get(TTYInfo::new)
        }
    }

    // optional .mesos.v1.TTYInfo.WindowSize window_size = 1;

    pub fn clear_window_size(&mut self) {
        self.window_size.clear();
    }

    pub fn has_window_size(&self) -> bool {
        self.window_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_size(&mut self, v: TTYInfo_WindowSize) {
        self.window_size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_size(&mut self) -> &mut TTYInfo_WindowSize {
        if self.window_size.is_none() {
            self.window_size.set_default();
        }
        self.window_size.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_size(&mut self) -> TTYInfo_WindowSize {
        self.window_size.take().unwrap_or_else(|| TTYInfo_WindowSize::new())
    }

    pub fn get_window_size(&self) -> &TTYInfo_WindowSize {
        self.window_size.as_ref().unwrap_or_else(|| TTYInfo_WindowSize::default_instance())
    }

    fn get_window_size_for_reflect(&self) -> &::protobuf::SingularPtrField<TTYInfo_WindowSize> {
        &self.window_size
    }

    fn mut_window_size_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TTYInfo_WindowSize> {
        &mut self.window_size
    }
}

impl ::protobuf::Message for TTYInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.window_size {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.window_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.window_size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.window_size.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TTYInfo {
    fn new() -> TTYInfo {
        TTYInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<TTYInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TTYInfo_WindowSize>>(
                    "window_size",
                    TTYInfo::get_window_size_for_reflect,
                    TTYInfo::mut_window_size_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TTYInfo>(
                    "TTYInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TTYInfo {
    fn clear(&mut self) {
        self.clear_window_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TTYInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TTYInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TTYInfo_WindowSize {
    // message fields
    rows: ::std::option::Option<u32>,
    columns: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TTYInfo_WindowSize {}

impl TTYInfo_WindowSize {
    pub fn new() -> TTYInfo_WindowSize {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TTYInfo_WindowSize {
        static mut instance: ::protobuf::lazy::Lazy<TTYInfo_WindowSize> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TTYInfo_WindowSize,
        };
        unsafe {
            instance.get(TTYInfo_WindowSize::new)
        }
    }

    // required uint32 rows = 1;

    pub fn clear_rows(&mut self) {
        self.rows = ::std::option::Option::None;
    }

    pub fn has_rows(&self) -> bool {
        self.rows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: u32) {
        self.rows = ::std::option::Option::Some(v);
    }

    pub fn get_rows(&self) -> u32 {
        self.rows.unwrap_or(0)
    }

    fn get_rows_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rows
    }

    fn mut_rows_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rows
    }

    // required uint32 columns = 2;

    pub fn clear_columns(&mut self) {
        self.columns = ::std::option::Option::None;
    }

    pub fn has_columns(&self) -> bool {
        self.columns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: u32) {
        self.columns = ::std::option::Option::Some(v);
    }

    pub fn get_columns(&self) -> u32 {
        self.columns.unwrap_or(0)
    }

    fn get_columns_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.columns
    }

    fn mut_columns_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.columns
    }
}

impl ::protobuf::Message for TTYInfo_WindowSize {
    fn is_initialized(&self) -> bool {
        if self.rows.is_none() {
            return false;
        }
        if self.columns.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rows = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.columns = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rows {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.columns {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rows {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.columns {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TTYInfo_WindowSize {
    fn new() -> TTYInfo_WindowSize {
        TTYInfo_WindowSize::new()
    }

    fn descriptor_static(_: ::std::option::Option<TTYInfo_WindowSize>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rows",
                    TTYInfo_WindowSize::get_rows_for_reflect,
                    TTYInfo_WindowSize::mut_rows_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "columns",
                    TTYInfo_WindowSize::get_columns_for_reflect,
                    TTYInfo_WindowSize::mut_columns_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TTYInfo_WindowSize>(
                    "TTYInfo_WindowSize",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TTYInfo_WindowSize {
    fn clear(&mut self) {
        self.clear_rows();
        self.clear_columns();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TTYInfo_WindowSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TTYInfo_WindowSize {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerInfo {
    // message fields
    field_type: ::std::option::Option<ContainerInfo_Type>,
    volumes: ::protobuf::RepeatedField<Volume>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    docker: ::protobuf::SingularPtrField<ContainerInfo_DockerInfo>,
    mesos: ::protobuf::SingularPtrField<ContainerInfo_MesosInfo>,
    network_infos: ::protobuf::RepeatedField<NetworkInfo>,
    linux_info: ::protobuf::SingularPtrField<LinuxInfo>,
    rlimit_info: ::protobuf::SingularPtrField<RLimitInfo>,
    tty_info: ::protobuf::SingularPtrField<TTYInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo {}

impl ContainerInfo {
    pub fn new() -> ContainerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo,
        };
        unsafe {
            instance.get(ContainerInfo::new)
        }
    }

    // required .mesos.v1.ContainerInfo.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ContainerInfo_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> ContainerInfo_Type {
        self.field_type.unwrap_or(ContainerInfo_Type::DOCKER)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<ContainerInfo_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<ContainerInfo_Type> {
        &mut self.field_type
    }

    // repeated .mesos.v1.Volume volumes = 2;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Volume>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::protobuf::RepeatedField<Volume> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Volume> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes(&self) -> &[Volume] {
        &self.volumes
    }

    fn get_volumes_for_reflect(&self) -> &::protobuf::RepeatedField<Volume> {
        &self.volumes
    }

    fn mut_volumes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Volume> {
        &mut self.volumes
    }

    // optional string hostname = 4;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional .mesos.v1.ContainerInfo.DockerInfo docker = 3;

    pub fn clear_docker(&mut self) {
        self.docker.clear();
    }

    pub fn has_docker(&self) -> bool {
        self.docker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_docker(&mut self, v: ContainerInfo_DockerInfo) {
        self.docker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker(&mut self) -> &mut ContainerInfo_DockerInfo {
        if self.docker.is_none() {
            self.docker.set_default();
        }
        self.docker.as_mut().unwrap()
    }

    // Take field
    pub fn take_docker(&mut self) -> ContainerInfo_DockerInfo {
        self.docker.take().unwrap_or_else(|| ContainerInfo_DockerInfo::new())
    }

    pub fn get_docker(&self) -> &ContainerInfo_DockerInfo {
        self.docker.as_ref().unwrap_or_else(|| ContainerInfo_DockerInfo::default_instance())
    }

    fn get_docker_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerInfo_DockerInfo> {
        &self.docker
    }

    fn mut_docker_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerInfo_DockerInfo> {
        &mut self.docker
    }

    // optional .mesos.v1.ContainerInfo.MesosInfo mesos = 5;

    pub fn clear_mesos(&mut self) {
        self.mesos.clear();
    }

    pub fn has_mesos(&self) -> bool {
        self.mesos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mesos(&mut self, v: ContainerInfo_MesosInfo) {
        self.mesos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mesos(&mut self) -> &mut ContainerInfo_MesosInfo {
        if self.mesos.is_none() {
            self.mesos.set_default();
        }
        self.mesos.as_mut().unwrap()
    }

    // Take field
    pub fn take_mesos(&mut self) -> ContainerInfo_MesosInfo {
        self.mesos.take().unwrap_or_else(|| ContainerInfo_MesosInfo::new())
    }

    pub fn get_mesos(&self) -> &ContainerInfo_MesosInfo {
        self.mesos.as_ref().unwrap_or_else(|| ContainerInfo_MesosInfo::default_instance())
    }

    fn get_mesos_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerInfo_MesosInfo> {
        &self.mesos
    }

    fn mut_mesos_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerInfo_MesosInfo> {
        &mut self.mesos
    }

    // repeated .mesos.v1.NetworkInfo network_infos = 7;

    pub fn clear_network_infos(&mut self) {
        self.network_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_network_infos(&mut self, v: ::protobuf::RepeatedField<NetworkInfo>) {
        self.network_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network_infos(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo> {
        &mut self.network_infos
    }

    // Take field
    pub fn take_network_infos(&mut self) -> ::protobuf::RepeatedField<NetworkInfo> {
        ::std::mem::replace(&mut self.network_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_network_infos(&self) -> &[NetworkInfo] {
        &self.network_infos
    }

    fn get_network_infos_for_reflect(&self) -> &::protobuf::RepeatedField<NetworkInfo> {
        &self.network_infos
    }

    fn mut_network_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo> {
        &mut self.network_infos
    }

    // optional .mesos.v1.LinuxInfo linux_info = 8;

    pub fn clear_linux_info(&mut self) {
        self.linux_info.clear();
    }

    pub fn has_linux_info(&self) -> bool {
        self.linux_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linux_info(&mut self, v: LinuxInfo) {
        self.linux_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linux_info(&mut self) -> &mut LinuxInfo {
        if self.linux_info.is_none() {
            self.linux_info.set_default();
        }
        self.linux_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_linux_info(&mut self) -> LinuxInfo {
        self.linux_info.take().unwrap_or_else(|| LinuxInfo::new())
    }

    pub fn get_linux_info(&self) -> &LinuxInfo {
        self.linux_info.as_ref().unwrap_or_else(|| LinuxInfo::default_instance())
    }

    fn get_linux_info_for_reflect(&self) -> &::protobuf::SingularPtrField<LinuxInfo> {
        &self.linux_info
    }

    fn mut_linux_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LinuxInfo> {
        &mut self.linux_info
    }

    // optional .mesos.v1.RLimitInfo rlimit_info = 9;

    pub fn clear_rlimit_info(&mut self) {
        self.rlimit_info.clear();
    }

    pub fn has_rlimit_info(&self) -> bool {
        self.rlimit_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rlimit_info(&mut self, v: RLimitInfo) {
        self.rlimit_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rlimit_info(&mut self) -> &mut RLimitInfo {
        if self.rlimit_info.is_none() {
            self.rlimit_info.set_default();
        }
        self.rlimit_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_rlimit_info(&mut self) -> RLimitInfo {
        self.rlimit_info.take().unwrap_or_else(|| RLimitInfo::new())
    }

    pub fn get_rlimit_info(&self) -> &RLimitInfo {
        self.rlimit_info.as_ref().unwrap_or_else(|| RLimitInfo::default_instance())
    }

    fn get_rlimit_info_for_reflect(&self) -> &::protobuf::SingularPtrField<RLimitInfo> {
        &self.rlimit_info
    }

    fn mut_rlimit_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<RLimitInfo> {
        &mut self.rlimit_info
    }

    // optional .mesos.v1.TTYInfo tty_info = 10;

    pub fn clear_tty_info(&mut self) {
        self.tty_info.clear();
    }

    pub fn has_tty_info(&self) -> bool {
        self.tty_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty_info(&mut self, v: TTYInfo) {
        self.tty_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tty_info(&mut self) -> &mut TTYInfo {
        if self.tty_info.is_none() {
            self.tty_info.set_default();
        }
        self.tty_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tty_info(&mut self) -> TTYInfo {
        self.tty_info.take().unwrap_or_else(|| TTYInfo::new())
    }

    pub fn get_tty_info(&self) -> &TTYInfo {
        self.tty_info.as_ref().unwrap_or_else(|| TTYInfo::default_instance())
    }

    fn get_tty_info_for_reflect(&self) -> &::protobuf::SingularPtrField<TTYInfo> {
        &self.tty_info
    }

    fn mut_tty_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TTYInfo> {
        &mut self.tty_info
    }
}

impl ::protobuf::Message for ContainerInfo {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mesos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.linux_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rlimit_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tty_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docker)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mesos)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network_infos)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linux_info)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rlimit_info)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tty_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.docker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mesos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.network_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.linux_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rlimit_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tty_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        for v in &self.volumes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.docker.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mesos.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.network_infos {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.linux_info.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rlimit_info.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tty_info.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo {
    fn new() -> ContainerInfo {
        ContainerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContainerInfo_Type>>(
                    "type",
                    ContainerInfo::get_field_type_for_reflect,
                    ContainerInfo::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume>>(
                    "volumes",
                    ContainerInfo::get_volumes_for_reflect,
                    ContainerInfo::mut_volumes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    ContainerInfo::get_hostname_for_reflect,
                    ContainerInfo::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerInfo_DockerInfo>>(
                    "docker",
                    ContainerInfo::get_docker_for_reflect,
                    ContainerInfo::mut_docker_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerInfo_MesosInfo>>(
                    "mesos",
                    ContainerInfo::get_mesos_for_reflect,
                    ContainerInfo::mut_mesos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkInfo>>(
                    "network_infos",
                    ContainerInfo::get_network_infos_for_reflect,
                    ContainerInfo::mut_network_infos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxInfo>>(
                    "linux_info",
                    ContainerInfo::get_linux_info_for_reflect,
                    ContainerInfo::mut_linux_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RLimitInfo>>(
                    "rlimit_info",
                    ContainerInfo::get_rlimit_info_for_reflect,
                    ContainerInfo::mut_rlimit_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TTYInfo>>(
                    "tty_info",
                    ContainerInfo::get_tty_info_for_reflect,
                    ContainerInfo::mut_tty_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo>(
                    "ContainerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_volumes();
        self.clear_hostname();
        self.clear_docker();
        self.clear_mesos();
        self.clear_network_infos();
        self.clear_linux_info();
        self.clear_rlimit_info();
        self.clear_tty_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerInfo_DockerInfo {
    // message fields
    image: ::protobuf::SingularField<::std::string::String>,
    network: ::std::option::Option<ContainerInfo_DockerInfo_Network>,
    port_mappings: ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping>,
    privileged: ::std::option::Option<bool>,
    parameters: ::protobuf::RepeatedField<Parameter>,
    force_pull_image: ::std::option::Option<bool>,
    volume_driver: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo_DockerInfo {}

impl ContainerInfo_DockerInfo {
    pub fn new() -> ContainerInfo_DockerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_DockerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_DockerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_DockerInfo,
        };
        unsafe {
            instance.get(ContainerInfo_DockerInfo::new)
        }
    }

    // required string image = 1;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.image
    }

    // optional .mesos.v1.ContainerInfo.DockerInfo.Network network = 2;

    pub fn clear_network(&mut self) {
        self.network = ::std::option::Option::None;
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ContainerInfo_DockerInfo_Network) {
        self.network = ::std::option::Option::Some(v);
    }

    pub fn get_network(&self) -> ContainerInfo_DockerInfo_Network {
        self.network.unwrap_or(ContainerInfo_DockerInfo_Network::HOST)
    }

    fn get_network_for_reflect(&self) -> &::std::option::Option<ContainerInfo_DockerInfo_Network> {
        &self.network
    }

    fn mut_network_for_reflect(&mut self) -> &mut ::std::option::Option<ContainerInfo_DockerInfo_Network> {
        &mut self.network
    }

    // repeated .mesos.v1.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;

    pub fn clear_port_mappings(&mut self) {
        self.port_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_mappings(&mut self, v: ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping>) {
        self.port_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port_mappings(&mut self) -> &mut ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        &mut self.port_mappings
    }

    // Take field
    pub fn take_port_mappings(&mut self) -> ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        ::std::mem::replace(&mut self.port_mappings, ::protobuf::RepeatedField::new())
    }

    pub fn get_port_mappings(&self) -> &[ContainerInfo_DockerInfo_PortMapping] {
        &self.port_mappings
    }

    fn get_port_mappings_for_reflect(&self) -> &::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        &self.port_mappings
    }

    fn mut_port_mappings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        &mut self.port_mappings
    }

    // optional bool privileged = 4;

    pub fn clear_privileged(&mut self) {
        self.privileged = ::std::option::Option::None;
    }

    pub fn has_privileged(&self) -> bool {
        self.privileged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = ::std::option::Option::Some(v);
    }

    pub fn get_privileged(&self) -> bool {
        self.privileged.unwrap_or(false)
    }

    fn get_privileged_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.privileged
    }

    fn mut_privileged_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.privileged
    }

    // repeated .mesos.v1.Parameter parameters = 5;

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameters(&self) -> &[Parameter] {
        &self.parameters
    }

    fn get_parameters_for_reflect(&self) -> &::protobuf::RepeatedField<Parameter> {
        &self.parameters
    }

    fn mut_parameters_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameters
    }

    // optional bool force_pull_image = 6;

    pub fn clear_force_pull_image(&mut self) {
        self.force_pull_image = ::std::option::Option::None;
    }

    pub fn has_force_pull_image(&self) -> bool {
        self.force_pull_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_pull_image(&mut self, v: bool) {
        self.force_pull_image = ::std::option::Option::Some(v);
    }

    pub fn get_force_pull_image(&self) -> bool {
        self.force_pull_image.unwrap_or(false)
    }

    fn get_force_pull_image_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.force_pull_image
    }

    fn mut_force_pull_image_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.force_pull_image
    }

    // optional string volume_driver = 7;

    pub fn clear_volume_driver(&mut self) {
        self.volume_driver.clear();
    }

    pub fn has_volume_driver(&self) -> bool {
        self.volume_driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume_driver(&mut self, v: ::std::string::String) {
        self.volume_driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume_driver(&mut self) -> &mut ::std::string::String {
        if self.volume_driver.is_none() {
            self.volume_driver.set_default();
        }
        self.volume_driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume_driver(&mut self) -> ::std::string::String {
        self.volume_driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volume_driver(&self) -> &str {
        match self.volume_driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volume_driver_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volume_driver
    }

    fn mut_volume_driver_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volume_driver
    }
}

impl ::protobuf::Message for ContainerInfo_DockerInfo {
    fn is_initialized(&self) -> bool {
        if self.image.is_none() {
            return false;
        }
        for v in &self.port_mappings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.network = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.port_mappings)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privileged = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_pull_image = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume_driver)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.network {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        for value in &self.port_mappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.privileged {
            my_size += 2;
        }
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.force_pull_image {
            my_size += 2;
        }
        if let Some(ref v) = self.volume_driver.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.network {
            os.write_enum(2, v.value())?;
        }
        for v in &self.port_mappings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.privileged {
            os.write_bool(4, v)?;
        }
        for v in &self.parameters {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.force_pull_image {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.volume_driver.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_DockerInfo {
    fn new() -> ContainerInfo_DockerInfo {
        ContainerInfo_DockerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_DockerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    ContainerInfo_DockerInfo::get_image_for_reflect,
                    ContainerInfo_DockerInfo::mut_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContainerInfo_DockerInfo_Network>>(
                    "network",
                    ContainerInfo_DockerInfo::get_network_for_reflect,
                    ContainerInfo_DockerInfo::mut_network_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerInfo_DockerInfo_PortMapping>>(
                    "port_mappings",
                    ContainerInfo_DockerInfo::get_port_mappings_for_reflect,
                    ContainerInfo_DockerInfo::mut_port_mappings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "privileged",
                    ContainerInfo_DockerInfo::get_privileged_for_reflect,
                    ContainerInfo_DockerInfo::mut_privileged_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Parameter>>(
                    "parameters",
                    ContainerInfo_DockerInfo::get_parameters_for_reflect,
                    ContainerInfo_DockerInfo::mut_parameters_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force_pull_image",
                    ContainerInfo_DockerInfo::get_force_pull_image_for_reflect,
                    ContainerInfo_DockerInfo::mut_force_pull_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volume_driver",
                    ContainerInfo_DockerInfo::get_volume_driver_for_reflect,
                    ContainerInfo_DockerInfo::mut_volume_driver_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_DockerInfo>(
                    "ContainerInfo_DockerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_DockerInfo {
    fn clear(&mut self) {
        self.clear_image();
        self.clear_network();
        self.clear_port_mappings();
        self.clear_privileged();
        self.clear_parameters();
        self.clear_force_pull_image();
        self.clear_volume_driver();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerInfo_DockerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerInfo_DockerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerInfo_DockerInfo_PortMapping {
    // message fields
    host_port: ::std::option::Option<u32>,
    container_port: ::std::option::Option<u32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo_DockerInfo_PortMapping {}

impl ContainerInfo_DockerInfo_PortMapping {
    pub fn new() -> ContainerInfo_DockerInfo_PortMapping {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_DockerInfo_PortMapping {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_DockerInfo_PortMapping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_DockerInfo_PortMapping,
        };
        unsafe {
            instance.get(ContainerInfo_DockerInfo_PortMapping::new)
        }
    }

    // required uint32 host_port = 1;

    pub fn clear_host_port(&mut self) {
        self.host_port = ::std::option::Option::None;
    }

    pub fn has_host_port(&self) -> bool {
        self.host_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_port(&mut self, v: u32) {
        self.host_port = ::std::option::Option::Some(v);
    }

    pub fn get_host_port(&self) -> u32 {
        self.host_port.unwrap_or(0)
    }

    fn get_host_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.host_port
    }

    fn mut_host_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.host_port
    }

    // required uint32 container_port = 2;

    pub fn clear_container_port(&mut self) {
        self.container_port = ::std::option::Option::None;
    }

    pub fn has_container_port(&self) -> bool {
        self.container_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_port(&mut self, v: u32) {
        self.container_port = ::std::option::Option::Some(v);
    }

    pub fn get_container_port(&self) -> u32 {
        self.container_port.unwrap_or(0)
    }

    fn get_container_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.container_port
    }

    fn mut_container_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.container_port
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_protocol_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.protocol
    }
}

impl ::protobuf::Message for ContainerInfo_DockerInfo_PortMapping {
    fn is_initialized(&self) -> bool {
        if self.host_port.is_none() {
            return false;
        }
        if self.container_port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.host_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.container_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.host_port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.container_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.host_port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.container_port {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_DockerInfo_PortMapping {
    fn new() -> ContainerInfo_DockerInfo_PortMapping {
        ContainerInfo_DockerInfo_PortMapping::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_DockerInfo_PortMapping>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "host_port",
                    ContainerInfo_DockerInfo_PortMapping::get_host_port_for_reflect,
                    ContainerInfo_DockerInfo_PortMapping::mut_host_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "container_port",
                    ContainerInfo_DockerInfo_PortMapping::get_container_port_for_reflect,
                    ContainerInfo_DockerInfo_PortMapping::mut_container_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocol",
                    ContainerInfo_DockerInfo_PortMapping::get_protocol_for_reflect,
                    ContainerInfo_DockerInfo_PortMapping::mut_protocol_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_DockerInfo_PortMapping>(
                    "ContainerInfo_DockerInfo_PortMapping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_DockerInfo_PortMapping {
    fn clear(&mut self) {
        self.clear_host_port();
        self.clear_container_port();
        self.clear_protocol();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerInfo_DockerInfo_PortMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerInfo_DockerInfo_PortMapping {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContainerInfo_DockerInfo_Network {
    HOST = 1,
    BRIDGE = 2,
    NONE = 3,
    USER = 4,
}

impl ::protobuf::ProtobufEnum for ContainerInfo_DockerInfo_Network {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContainerInfo_DockerInfo_Network> {
        match value {
            1 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::HOST),
            2 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::BRIDGE),
            3 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::NONE),
            4 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::USER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContainerInfo_DockerInfo_Network] = &[
            ContainerInfo_DockerInfo_Network::HOST,
            ContainerInfo_DockerInfo_Network::BRIDGE,
            ContainerInfo_DockerInfo_Network::NONE,
            ContainerInfo_DockerInfo_Network::USER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ContainerInfo_DockerInfo_Network>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContainerInfo_DockerInfo_Network", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContainerInfo_DockerInfo_Network {
}

impl ::protobuf::reflect::ProtobufValue for ContainerInfo_DockerInfo_Network {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerInfo_MesosInfo {
    // message fields
    image: ::protobuf::SingularPtrField<Image>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo_MesosInfo {}

impl ContainerInfo_MesosInfo {
    pub fn new() -> ContainerInfo_MesosInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_MesosInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_MesosInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_MesosInfo,
        };
        unsafe {
            instance.get(ContainerInfo_MesosInfo::new)
        }
    }

    // optional .mesos.v1.Image image = 1;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Image {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| Image::default_instance())
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularPtrField<Image> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Image> {
        &mut self.image
    }
}

impl ::protobuf::Message for ContainerInfo_MesosInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_MesosInfo {
    fn new() -> ContainerInfo_MesosInfo {
        ContainerInfo_MesosInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_MesosInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                    "image",
                    ContainerInfo_MesosInfo::get_image_for_reflect,
                    ContainerInfo_MesosInfo::mut_image_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_MesosInfo>(
                    "ContainerInfo_MesosInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_MesosInfo {
    fn clear(&mut self) {
        self.clear_image();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerInfo_MesosInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerInfo_MesosInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContainerInfo_Type {
    DOCKER = 1,
    MESOS = 2,
}

impl ::protobuf::ProtobufEnum for ContainerInfo_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContainerInfo_Type> {
        match value {
            1 => ::std::option::Option::Some(ContainerInfo_Type::DOCKER),
            2 => ::std::option::Option::Some(ContainerInfo_Type::MESOS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContainerInfo_Type] = &[
            ContainerInfo_Type::DOCKER,
            ContainerInfo_Type::MESOS,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ContainerInfo_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContainerInfo_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContainerInfo_Type {
}

impl ::protobuf::reflect::ProtobufValue for ContainerInfo_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatus {
    // message fields
    container_id: ::protobuf::SingularPtrField<ContainerID>,
    network_infos: ::protobuf::RepeatedField<NetworkInfo>,
    cgroup_info: ::protobuf::SingularPtrField<CgroupInfo>,
    executor_pid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerStatus {}

impl ContainerStatus {
    pub fn new() -> ContainerStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerStatus {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStatus,
        };
        unsafe {
            instance.get(ContainerStatus::new)
        }
    }

    // optional .mesos.v1.ContainerID container_id = 4;

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    pub fn has_container_id(&self) -> bool {
        self.container_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ContainerID) {
        self.container_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ContainerID {
        if self.container_id.is_none() {
            self.container_id.set_default();
        }
        self.container_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_id(&mut self) -> ContainerID {
        self.container_id.take().unwrap_or_else(|| ContainerID::new())
    }

    pub fn get_container_id(&self) -> &ContainerID {
        self.container_id.as_ref().unwrap_or_else(|| ContainerID::default_instance())
    }

    fn get_container_id_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerID> {
        &self.container_id
    }

    fn mut_container_id_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerID> {
        &mut self.container_id
    }

    // repeated .mesos.v1.NetworkInfo network_infos = 1;

    pub fn clear_network_infos(&mut self) {
        self.network_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_network_infos(&mut self, v: ::protobuf::RepeatedField<NetworkInfo>) {
        self.network_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network_infos(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo> {
        &mut self.network_infos
    }

    // Take field
    pub fn take_network_infos(&mut self) -> ::protobuf::RepeatedField<NetworkInfo> {
        ::std::mem::replace(&mut self.network_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_network_infos(&self) -> &[NetworkInfo] {
        &self.network_infos
    }

    fn get_network_infos_for_reflect(&self) -> &::protobuf::RepeatedField<NetworkInfo> {
        &self.network_infos
    }

    fn mut_network_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NetworkInfo> {
        &mut self.network_infos
    }

    // optional .mesos.v1.CgroupInfo cgroup_info = 2;

    pub fn clear_cgroup_info(&mut self) {
        self.cgroup_info.clear();
    }

    pub fn has_cgroup_info(&self) -> bool {
        self.cgroup_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cgroup_info(&mut self, v: CgroupInfo) {
        self.cgroup_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_info(&mut self) -> &mut CgroupInfo {
        if self.cgroup_info.is_none() {
            self.cgroup_info.set_default();
        }
        self.cgroup_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_cgroup_info(&mut self) -> CgroupInfo {
        self.cgroup_info.take().unwrap_or_else(|| CgroupInfo::new())
    }

    pub fn get_cgroup_info(&self) -> &CgroupInfo {
        self.cgroup_info.as_ref().unwrap_or_else(|| CgroupInfo::default_instance())
    }

    fn get_cgroup_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CgroupInfo> {
        &self.cgroup_info
    }

    fn mut_cgroup_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CgroupInfo> {
        &mut self.cgroup_info
    }

    // optional uint32 executor_pid = 3;

    pub fn clear_executor_pid(&mut self) {
        self.executor_pid = ::std::option::Option::None;
    }

    pub fn has_executor_pid(&self) -> bool {
        self.executor_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_pid(&mut self, v: u32) {
        self.executor_pid = ::std::option::Option::Some(v);
    }

    pub fn get_executor_pid(&self) -> u32 {
        self.executor_pid.unwrap_or(0)
    }

    fn get_executor_pid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.executor_pid
    }

    fn mut_executor_pid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.executor_pid
    }
}

impl ::protobuf::Message for ContainerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.container_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cgroup_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container_id)?;
                },
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network_infos)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cgroup_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.executor_pid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.container_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.network_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.cgroup_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.executor_pid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.container_id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.network_infos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.cgroup_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.executor_pid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerStatus {
    fn new() -> ContainerStatus {
        ContainerStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerID>>(
                    "container_id",
                    ContainerStatus::get_container_id_for_reflect,
                    ContainerStatus::mut_container_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkInfo>>(
                    "network_infos",
                    ContainerStatus::get_network_infos_for_reflect,
                    ContainerStatus::mut_network_infos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo>>(
                    "cgroup_info",
                    ContainerStatus::get_cgroup_info_for_reflect,
                    ContainerStatus::mut_cgroup_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "executor_pid",
                    ContainerStatus::get_executor_pid_for_reflect,
                    ContainerStatus::mut_executor_pid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStatus>(
                    "ContainerStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerStatus {
    fn clear(&mut self) {
        self.clear_container_id();
        self.clear_network_infos();
        self.clear_cgroup_info();
        self.clear_executor_pid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo {
    // message fields
    net_cls: ::protobuf::SingularPtrField<CgroupInfo_NetCls>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo {}

impl CgroupInfo {
    pub fn new() -> CgroupInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo,
        };
        unsafe {
            instance.get(CgroupInfo::new)
        }
    }

    // optional .mesos.v1.CgroupInfo.NetCls net_cls = 1;

    pub fn clear_net_cls(&mut self) {
        self.net_cls.clear();
    }

    pub fn has_net_cls(&self) -> bool {
        self.net_cls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_cls(&mut self, v: CgroupInfo_NetCls) {
        self.net_cls = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_cls(&mut self) -> &mut CgroupInfo_NetCls {
        if self.net_cls.is_none() {
            self.net_cls.set_default();
        }
        self.net_cls.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_cls(&mut self) -> CgroupInfo_NetCls {
        self.net_cls.take().unwrap_or_else(|| CgroupInfo_NetCls::new())
    }

    pub fn get_net_cls(&self) -> &CgroupInfo_NetCls {
        self.net_cls.as_ref().unwrap_or_else(|| CgroupInfo_NetCls::default_instance())
    }

    fn get_net_cls_for_reflect(&self) -> &::protobuf::SingularPtrField<CgroupInfo_NetCls> {
        &self.net_cls
    }

    fn mut_net_cls_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CgroupInfo_NetCls> {
        &mut self.net_cls
    }
}

impl ::protobuf::Message for CgroupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.net_cls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.net_cls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.net_cls.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.net_cls.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo {
    fn new() -> CgroupInfo {
        CgroupInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_NetCls>>(
                    "net_cls",
                    CgroupInfo::get_net_cls_for_reflect,
                    CgroupInfo::mut_net_cls_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo>(
                    "CgroupInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo {
    fn clear(&mut self) {
        self.clear_net_cls();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_Blkio {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_Blkio {}

impl CgroupInfo_Blkio {
    pub fn new() -> CgroupInfo_Blkio {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_Blkio {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_Blkio> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_Blkio,
        };
        unsafe {
            instance.get(CgroupInfo_Blkio::new)
        }
    }
}

impl ::protobuf::Message for CgroupInfo_Blkio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_Blkio {
    fn new() -> CgroupInfo_Blkio {
        CgroupInfo_Blkio::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_Blkio>(
                    "CgroupInfo_Blkio",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_Blkio {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_Blkio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_Blkio_Value {
    // message fields
    op: ::std::option::Option<CgroupInfo_Blkio_Operation>,
    value: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_Blkio_Value {}

impl CgroupInfo_Blkio_Value {
    pub fn new() -> CgroupInfo_Blkio_Value {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_Blkio_Value {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_Blkio_Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_Blkio_Value,
        };
        unsafe {
            instance.get(CgroupInfo_Blkio_Value::new)
        }
    }

    // optional .mesos.v1.CgroupInfo.Blkio.Operation op = 1;

    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: CgroupInfo_Blkio_Operation) {
        self.op = ::std::option::Option::Some(v);
    }

    pub fn get_op(&self) -> CgroupInfo_Blkio_Operation {
        self.op.unwrap_or(CgroupInfo_Blkio_Operation::UNKNOWN)
    }

    fn get_op_for_reflect(&self) -> &::std::option::Option<CgroupInfo_Blkio_Operation> {
        &self.op
    }

    fn mut_op_for_reflect(&mut self) -> &mut ::std::option::Option<CgroupInfo_Blkio_Operation> {
        &mut self.op
    }

    // optional uint64 value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.value
    }
}

impl ::protobuf::Message for CgroupInfo_Blkio_Value {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.op = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.op {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.value {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_Blkio_Value {
    fn new() -> CgroupInfo_Blkio_Value {
        CgroupInfo_Blkio_Value::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio_Value>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CgroupInfo_Blkio_Operation>>(
                    "op",
                    CgroupInfo_Blkio_Value::get_op_for_reflect,
                    CgroupInfo_Blkio_Value::mut_op_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    CgroupInfo_Blkio_Value::get_value_for_reflect,
                    CgroupInfo_Blkio_Value::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_Blkio_Value>(
                    "CgroupInfo_Blkio_Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_Blkio_Value {
    fn clear(&mut self) {
        self.clear_op();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_Blkio_Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_Blkio_CFQ {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_Blkio_CFQ {}

impl CgroupInfo_Blkio_CFQ {
    pub fn new() -> CgroupInfo_Blkio_CFQ {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_Blkio_CFQ {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_Blkio_CFQ> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_Blkio_CFQ,
        };
        unsafe {
            instance.get(CgroupInfo_Blkio_CFQ::new)
        }
    }
}

impl ::protobuf::Message for CgroupInfo_Blkio_CFQ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_Blkio_CFQ {
    fn new() -> CgroupInfo_Blkio_CFQ {
        CgroupInfo_Blkio_CFQ::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio_CFQ>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_Blkio_CFQ>(
                    "CgroupInfo_Blkio_CFQ",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_Blkio_CFQ {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_Blkio_CFQ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio_CFQ {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_Blkio_CFQ_Statistics {
    // message fields
    device: ::protobuf::SingularPtrField<Device_Number>,
    sectors: ::std::option::Option<u64>,
    time: ::std::option::Option<u64>,
    io_serviced: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    io_service_bytes: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    io_service_time: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    io_wait_time: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    io_merged: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    io_queued: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_Blkio_CFQ_Statistics {}

impl CgroupInfo_Blkio_CFQ_Statistics {
    pub fn new() -> CgroupInfo_Blkio_CFQ_Statistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_Blkio_CFQ_Statistics {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_Blkio_CFQ_Statistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_Blkio_CFQ_Statistics,
        };
        unsafe {
            instance.get(CgroupInfo_Blkio_CFQ_Statistics::new)
        }
    }

    // optional .mesos.v1.Device.Number device = 1;

    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: Device_Number) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut Device_Number {
        if self.device.is_none() {
            self.device.set_default();
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> Device_Number {
        self.device.take().unwrap_or_else(|| Device_Number::new())
    }

    pub fn get_device(&self) -> &Device_Number {
        self.device.as_ref().unwrap_or_else(|| Device_Number::default_instance())
    }

    fn get_device_for_reflect(&self) -> &::protobuf::SingularPtrField<Device_Number> {
        &self.device
    }

    fn mut_device_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Device_Number> {
        &mut self.device
    }

    // optional uint64 sectors = 2;

    pub fn clear_sectors(&mut self) {
        self.sectors = ::std::option::Option::None;
    }

    pub fn has_sectors(&self) -> bool {
        self.sectors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectors(&mut self, v: u64) {
        self.sectors = ::std::option::Option::Some(v);
    }

    pub fn get_sectors(&self) -> u64 {
        self.sectors.unwrap_or(0)
    }

    fn get_sectors_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.sectors
    }

    fn mut_sectors_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.sectors
    }

    // optional uint64 time = 3;

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u64) {
        self.time = ::std::option::Option::Some(v);
    }

    pub fn get_time(&self) -> u64 {
        self.time.unwrap_or(0)
    }

    fn get_time_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.time
    }

    fn mut_time_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.time
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_serviced = 4;

    pub fn clear_io_serviced(&mut self) {
        self.io_serviced.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_serviced(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_serviced = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_serviced(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_serviced
    }

    // Take field
    pub fn take_io_serviced(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_serviced, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_serviced(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_serviced
    }

    fn get_io_serviced_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_serviced
    }

    fn mut_io_serviced_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_serviced
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_service_bytes = 5;

    pub fn clear_io_service_bytes(&mut self) {
        self.io_service_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_bytes(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_service_bytes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_bytes(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_service_bytes
    }

    // Take field
    pub fn take_io_service_bytes(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_service_bytes, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_service_bytes(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_service_bytes
    }

    fn get_io_service_bytes_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_service_bytes
    }

    fn mut_io_service_bytes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_service_bytes
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_service_time = 6;

    pub fn clear_io_service_time(&mut self) {
        self.io_service_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_time(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_service_time = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_time(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_service_time
    }

    // Take field
    pub fn take_io_service_time(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_service_time, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_service_time(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_service_time
    }

    fn get_io_service_time_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_service_time
    }

    fn mut_io_service_time_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_service_time
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_wait_time = 7;

    pub fn clear_io_wait_time(&mut self) {
        self.io_wait_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_wait_time(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_wait_time = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_wait_time(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_wait_time
    }

    // Take field
    pub fn take_io_wait_time(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_wait_time, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_wait_time(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_wait_time
    }

    fn get_io_wait_time_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_wait_time
    }

    fn mut_io_wait_time_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_wait_time
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_merged = 8;

    pub fn clear_io_merged(&mut self) {
        self.io_merged.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_merged(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_merged = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_merged(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_merged
    }

    // Take field
    pub fn take_io_merged(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_merged, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_merged(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_merged
    }

    fn get_io_merged_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_merged
    }

    fn mut_io_merged_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_merged
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_queued = 9;

    pub fn clear_io_queued(&mut self) {
        self.io_queued.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_queued(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_queued = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_queued(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_queued
    }

    // Take field
    pub fn take_io_queued(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_queued, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_queued(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_queued
    }

    fn get_io_queued_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_queued
    }

    fn mut_io_queued_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_queued
    }
}

impl ::protobuf::Message for CgroupInfo_Blkio_CFQ_Statistics {
    fn is_initialized(&self) -> bool {
        for v in &self.device {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_serviced {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_service_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_service_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_wait_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_merged {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_queued {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sectors = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_serviced)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_bytes)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_time)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_wait_time)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_merged)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_queued)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sectors {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.io_serviced {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_service_bytes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_service_time {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_wait_time {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_merged {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_queued {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.sectors {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.time {
            os.write_uint64(3, v)?;
        }
        for v in &self.io_serviced {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_service_bytes {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_service_time {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_wait_time {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_merged {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_queued {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_Blkio_CFQ_Statistics {
    fn new() -> CgroupInfo_Blkio_CFQ_Statistics {
        CgroupInfo_Blkio_CFQ_Statistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio_CFQ_Statistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device_Number>>(
                    "device",
                    CgroupInfo_Blkio_CFQ_Statistics::get_device_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_device_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sectors",
                    CgroupInfo_Blkio_CFQ_Statistics::get_sectors_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_sectors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "time",
                    CgroupInfo_Blkio_CFQ_Statistics::get_time_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_serviced",
                    CgroupInfo_Blkio_CFQ_Statistics::get_io_serviced_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_io_serviced_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_service_bytes",
                    CgroupInfo_Blkio_CFQ_Statistics::get_io_service_bytes_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_io_service_bytes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_service_time",
                    CgroupInfo_Blkio_CFQ_Statistics::get_io_service_time_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_io_service_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_wait_time",
                    CgroupInfo_Blkio_CFQ_Statistics::get_io_wait_time_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_io_wait_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_merged",
                    CgroupInfo_Blkio_CFQ_Statistics::get_io_merged_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_io_merged_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_queued",
                    CgroupInfo_Blkio_CFQ_Statistics::get_io_queued_for_reflect,
                    CgroupInfo_Blkio_CFQ_Statistics::mut_io_queued_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_Blkio_CFQ_Statistics>(
                    "CgroupInfo_Blkio_CFQ_Statistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_Blkio_CFQ_Statistics {
    fn clear(&mut self) {
        self.clear_device();
        self.clear_sectors();
        self.clear_time();
        self.clear_io_serviced();
        self.clear_io_service_bytes();
        self.clear_io_service_time();
        self.clear_io_wait_time();
        self.clear_io_merged();
        self.clear_io_queued();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_Blkio_CFQ_Statistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio_CFQ_Statistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_Blkio_Throttling {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_Blkio_Throttling {}

impl CgroupInfo_Blkio_Throttling {
    pub fn new() -> CgroupInfo_Blkio_Throttling {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_Blkio_Throttling {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_Blkio_Throttling> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_Blkio_Throttling,
        };
        unsafe {
            instance.get(CgroupInfo_Blkio_Throttling::new)
        }
    }
}

impl ::protobuf::Message for CgroupInfo_Blkio_Throttling {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_Blkio_Throttling {
    fn new() -> CgroupInfo_Blkio_Throttling {
        CgroupInfo_Blkio_Throttling::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio_Throttling>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_Blkio_Throttling>(
                    "CgroupInfo_Blkio_Throttling",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_Blkio_Throttling {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_Blkio_Throttling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio_Throttling {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_Blkio_Throttling_Statistics {
    // message fields
    device: ::protobuf::SingularPtrField<Device_Number>,
    io_serviced: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    io_service_bytes: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_Blkio_Throttling_Statistics {}

impl CgroupInfo_Blkio_Throttling_Statistics {
    pub fn new() -> CgroupInfo_Blkio_Throttling_Statistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_Blkio_Throttling_Statistics {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_Blkio_Throttling_Statistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_Blkio_Throttling_Statistics,
        };
        unsafe {
            instance.get(CgroupInfo_Blkio_Throttling_Statistics::new)
        }
    }

    // optional .mesos.v1.Device.Number device = 1;

    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: Device_Number) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut Device_Number {
        if self.device.is_none() {
            self.device.set_default();
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> Device_Number {
        self.device.take().unwrap_or_else(|| Device_Number::new())
    }

    pub fn get_device(&self) -> &Device_Number {
        self.device.as_ref().unwrap_or_else(|| Device_Number::default_instance())
    }

    fn get_device_for_reflect(&self) -> &::protobuf::SingularPtrField<Device_Number> {
        &self.device
    }

    fn mut_device_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Device_Number> {
        &mut self.device
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_serviced = 2;

    pub fn clear_io_serviced(&mut self) {
        self.io_serviced.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_serviced(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_serviced = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_serviced(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_serviced
    }

    // Take field
    pub fn take_io_serviced(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_serviced, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_serviced(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_serviced
    }

    fn get_io_serviced_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_serviced
    }

    fn mut_io_serviced_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_serviced
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Value io_service_bytes = 3;

    pub fn clear_io_service_bytes(&mut self) {
        self.io_service_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_bytes(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Value>) {
        self.io_service_bytes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_bytes(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_service_bytes
    }

    // Take field
    pub fn take_io_service_bytes(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        ::std::mem::replace(&mut self.io_service_bytes, ::protobuf::RepeatedField::new())
    }

    pub fn get_io_service_bytes(&self) -> &[CgroupInfo_Blkio_Value] {
        &self.io_service_bytes
    }

    fn get_io_service_bytes_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &self.io_service_bytes
    }

    fn mut_io_service_bytes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Value> {
        &mut self.io_service_bytes
    }
}

impl ::protobuf::Message for CgroupInfo_Blkio_Throttling_Statistics {
    fn is_initialized(&self) -> bool {
        for v in &self.device {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_serviced {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_service_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_serviced)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.io_serviced {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_service_bytes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.io_serviced {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_service_bytes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_Blkio_Throttling_Statistics {
    fn new() -> CgroupInfo_Blkio_Throttling_Statistics {
        CgroupInfo_Blkio_Throttling_Statistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio_Throttling_Statistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device_Number>>(
                    "device",
                    CgroupInfo_Blkio_Throttling_Statistics::get_device_for_reflect,
                    CgroupInfo_Blkio_Throttling_Statistics::mut_device_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_serviced",
                    CgroupInfo_Blkio_Throttling_Statistics::get_io_serviced_for_reflect,
                    CgroupInfo_Blkio_Throttling_Statistics::mut_io_serviced_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Value>>(
                    "io_service_bytes",
                    CgroupInfo_Blkio_Throttling_Statistics::get_io_service_bytes_for_reflect,
                    CgroupInfo_Blkio_Throttling_Statistics::mut_io_service_bytes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_Blkio_Throttling_Statistics>(
                    "CgroupInfo_Blkio_Throttling_Statistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_Blkio_Throttling_Statistics {
    fn clear(&mut self) {
        self.clear_device();
        self.clear_io_serviced();
        self.clear_io_service_bytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_Blkio_Throttling_Statistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio_Throttling_Statistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_Blkio_Statistics {
    // message fields
    cfq: ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics>,
    cfq_recursive: ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics>,
    throttling: ::protobuf::RepeatedField<CgroupInfo_Blkio_Throttling_Statistics>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_Blkio_Statistics {}

impl CgroupInfo_Blkio_Statistics {
    pub fn new() -> CgroupInfo_Blkio_Statistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_Blkio_Statistics {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_Blkio_Statistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_Blkio_Statistics,
        };
        unsafe {
            instance.get(CgroupInfo_Blkio_Statistics::new)
        }
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.CFQ.Statistics cfq = 1;

    pub fn clear_cfq(&mut self) {
        self.cfq.clear();
    }

    // Param is passed by value, moved
    pub fn set_cfq(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics>) {
        self.cfq = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cfq(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        &mut self.cfq
    }

    // Take field
    pub fn take_cfq(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        ::std::mem::replace(&mut self.cfq, ::protobuf::RepeatedField::new())
    }

    pub fn get_cfq(&self) -> &[CgroupInfo_Blkio_CFQ_Statistics] {
        &self.cfq
    }

    fn get_cfq_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        &self.cfq
    }

    fn mut_cfq_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        &mut self.cfq
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.CFQ.Statistics cfq_recursive = 2;

    pub fn clear_cfq_recursive(&mut self) {
        self.cfq_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_cfq_recursive(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics>) {
        self.cfq_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cfq_recursive(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        &mut self.cfq_recursive
    }

    // Take field
    pub fn take_cfq_recursive(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        ::std::mem::replace(&mut self.cfq_recursive, ::protobuf::RepeatedField::new())
    }

    pub fn get_cfq_recursive(&self) -> &[CgroupInfo_Blkio_CFQ_Statistics] {
        &self.cfq_recursive
    }

    fn get_cfq_recursive_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        &self.cfq_recursive
    }

    fn mut_cfq_recursive_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_CFQ_Statistics> {
        &mut self.cfq_recursive
    }

    // repeated .mesos.v1.CgroupInfo.Blkio.Throttling.Statistics throttling = 3;

    pub fn clear_throttling(&mut self) {
        self.throttling.clear();
    }

    // Param is passed by value, moved
    pub fn set_throttling(&mut self, v: ::protobuf::RepeatedField<CgroupInfo_Blkio_Throttling_Statistics>) {
        self.throttling = v;
    }

    // Mutable pointer to the field.
    pub fn mut_throttling(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Throttling_Statistics> {
        &mut self.throttling
    }

    // Take field
    pub fn take_throttling(&mut self) -> ::protobuf::RepeatedField<CgroupInfo_Blkio_Throttling_Statistics> {
        ::std::mem::replace(&mut self.throttling, ::protobuf::RepeatedField::new())
    }

    pub fn get_throttling(&self) -> &[CgroupInfo_Blkio_Throttling_Statistics] {
        &self.throttling
    }

    fn get_throttling_for_reflect(&self) -> &::protobuf::RepeatedField<CgroupInfo_Blkio_Throttling_Statistics> {
        &self.throttling
    }

    fn mut_throttling_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CgroupInfo_Blkio_Throttling_Statistics> {
        &mut self.throttling
    }
}

impl ::protobuf::Message for CgroupInfo_Blkio_Statistics {
    fn is_initialized(&self) -> bool {
        for v in &self.cfq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cfq_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.throttling {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cfq)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cfq_recursive)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.throttling)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cfq {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.cfq_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.throttling {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cfq {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.cfq_recursive {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.throttling {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_Blkio_Statistics {
    fn new() -> CgroupInfo_Blkio_Statistics {
        CgroupInfo_Blkio_Statistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio_Statistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_CFQ_Statistics>>(
                    "cfq",
                    CgroupInfo_Blkio_Statistics::get_cfq_for_reflect,
                    CgroupInfo_Blkio_Statistics::mut_cfq_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_CFQ_Statistics>>(
                    "cfq_recursive",
                    CgroupInfo_Blkio_Statistics::get_cfq_recursive_for_reflect,
                    CgroupInfo_Blkio_Statistics::mut_cfq_recursive_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupInfo_Blkio_Throttling_Statistics>>(
                    "throttling",
                    CgroupInfo_Blkio_Statistics::get_throttling_for_reflect,
                    CgroupInfo_Blkio_Statistics::mut_throttling_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_Blkio_Statistics>(
                    "CgroupInfo_Blkio_Statistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_Blkio_Statistics {
    fn clear(&mut self) {
        self.clear_cfq();
        self.clear_cfq_recursive();
        self.clear_throttling();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_Blkio_Statistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio_Statistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CgroupInfo_Blkio_Operation {
    UNKNOWN = 0,
    TOTAL = 1,
    READ = 2,
    WRITE = 3,
    SYNC = 4,
    ASYNC = 5,
}

impl ::protobuf::ProtobufEnum for CgroupInfo_Blkio_Operation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CgroupInfo_Blkio_Operation> {
        match value {
            0 => ::std::option::Option::Some(CgroupInfo_Blkio_Operation::UNKNOWN),
            1 => ::std::option::Option::Some(CgroupInfo_Blkio_Operation::TOTAL),
            2 => ::std::option::Option::Some(CgroupInfo_Blkio_Operation::READ),
            3 => ::std::option::Option::Some(CgroupInfo_Blkio_Operation::WRITE),
            4 => ::std::option::Option::Some(CgroupInfo_Blkio_Operation::SYNC),
            5 => ::std::option::Option::Some(CgroupInfo_Blkio_Operation::ASYNC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CgroupInfo_Blkio_Operation] = &[
            CgroupInfo_Blkio_Operation::UNKNOWN,
            CgroupInfo_Blkio_Operation::TOTAL,
            CgroupInfo_Blkio_Operation::READ,
            CgroupInfo_Blkio_Operation::WRITE,
            CgroupInfo_Blkio_Operation::SYNC,
            CgroupInfo_Blkio_Operation::ASYNC,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CgroupInfo_Blkio_Operation>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CgroupInfo_Blkio_Operation", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CgroupInfo_Blkio_Operation {
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_Blkio_Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupInfo_NetCls {
    // message fields
    classid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_NetCls {}

impl CgroupInfo_NetCls {
    pub fn new() -> CgroupInfo_NetCls {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_NetCls {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_NetCls> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_NetCls,
        };
        unsafe {
            instance.get(CgroupInfo_NetCls::new)
        }
    }

    // optional uint32 classid = 1;

    pub fn clear_classid(&mut self) {
        self.classid = ::std::option::Option::None;
    }

    pub fn has_classid(&self) -> bool {
        self.classid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_classid(&mut self, v: u32) {
        self.classid = ::std::option::Option::Some(v);
    }

    pub fn get_classid(&self) -> u32 {
        self.classid.unwrap_or(0)
    }

    fn get_classid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.classid
    }

    fn mut_classid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.classid
    }
}

impl ::protobuf::Message for CgroupInfo_NetCls {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.classid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.classid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.classid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_NetCls {
    fn new() -> CgroupInfo_NetCls {
        CgroupInfo_NetCls::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_NetCls>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "classid",
                    CgroupInfo_NetCls::get_classid_for_reflect,
                    CgroupInfo_NetCls::mut_classid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_NetCls>(
                    "CgroupInfo_NetCls",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_NetCls {
    fn clear(&mut self) {
        self.clear_classid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupInfo_NetCls {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupInfo_NetCls {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Labels {
    // message fields
    labels: ::protobuf::RepeatedField<Label>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Labels {}

impl Labels {
    pub fn new() -> Labels {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Labels {
        static mut instance: ::protobuf::lazy::Lazy<Labels> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Labels,
        };
        unsafe {
            instance.get(Labels::new)
        }
    }

    // repeated .mesos.v1.Label labels = 1;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::protobuf::RepeatedField<Label>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::protobuf::RepeatedField<Label> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::protobuf::RepeatedField<Label> {
        ::std::mem::replace(&mut self.labels, ::protobuf::RepeatedField::new())
    }

    pub fn get_labels(&self) -> &[Label] {
        &self.labels
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::RepeatedField<Label> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Label> {
        &mut self.labels
    }
}

impl ::protobuf::Message for Labels {
    fn is_initialized(&self) -> bool {
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.labels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Labels {
    fn new() -> Labels {
        Labels::new()
    }

    fn descriptor_static(_: ::std::option::Option<Labels>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Label>>(
                    "labels",
                    Labels::get_labels_for_reflect,
                    Labels::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Labels>(
                    "Labels",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Labels {
    fn clear(&mut self) {
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Labels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Labels {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Label {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Label {}

impl Label {
    pub fn new() -> Label {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Label {
        static mut instance: ::protobuf::lazy::Lazy<Label> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Label,
        };
        unsafe {
            instance.get(Label::new)
        }
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for Label {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Label {
    fn new() -> Label {
        Label::new()
    }

    fn descriptor_static(_: ::std::option::Option<Label>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    Label::get_key_for_reflect,
                    Label::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Label::get_value_for_reflect,
                    Label::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Label>(
                    "Label",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Label {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Label {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Label {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Port {
    // message fields
    number: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    visibility: ::std::option::Option<DiscoveryInfo_Visibility>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Port {}

impl Port {
    pub fn new() -> Port {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Port {
        static mut instance: ::protobuf::lazy::Lazy<Port> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Port,
        };
        unsafe {
            instance.get(Port::new)
        }
    }

    // required uint32 number = 1;

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: u32) {
        self.number = ::std::option::Option::Some(v);
    }

    pub fn get_number(&self) -> u32 {
        self.number.unwrap_or(0)
    }

    fn get_number_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.number
    }

    fn mut_number_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.number
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_protocol_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.protocol
    }

    // optional .mesos.v1.DiscoveryInfo.Visibility visibility = 4;

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: DiscoveryInfo_Visibility) {
        self.visibility = ::std::option::Option::Some(v);
    }

    pub fn get_visibility(&self) -> DiscoveryInfo_Visibility {
        self.visibility.unwrap_or(DiscoveryInfo_Visibility::FRAMEWORK)
    }

    fn get_visibility_for_reflect(&self) -> &::std::option::Option<DiscoveryInfo_Visibility> {
        &self.visibility
    }

    fn mut_visibility_for_reflect(&mut self) -> &mut ::std::option::Option<DiscoveryInfo_Visibility> {
        &mut self.visibility
    }

    // optional .mesos.v1.Labels labels = 5;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }
}

impl ::protobuf::Message for Port {
    fn is_initialized(&self) -> bool {
        if self.number.is_none() {
            return false;
        }
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.number {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(4, v.value())?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Port {
    fn new() -> Port {
        Port::new()
    }

    fn descriptor_static(_: ::std::option::Option<Port>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "number",
                    Port::get_number_for_reflect,
                    Port::mut_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Port::get_name_for_reflect,
                    Port::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocol",
                    Port::get_protocol_for_reflect,
                    Port::mut_protocol_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DiscoveryInfo_Visibility>>(
                    "visibility",
                    Port::get_visibility_for_reflect,
                    Port::mut_visibility_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    Port::get_labels_for_reflect,
                    Port::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Port>(
                    "Port",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Port {
    fn clear(&mut self) {
        self.clear_number();
        self.clear_name();
        self.clear_protocol();
        self.clear_visibility();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Port {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ports {
    // message fields
    ports: ::protobuf::RepeatedField<Port>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Ports {}

impl Ports {
    pub fn new() -> Ports {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Ports {
        static mut instance: ::protobuf::lazy::Lazy<Ports> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ports,
        };
        unsafe {
            instance.get(Ports::new)
        }
    }

    // repeated .mesos.v1.Port ports = 1;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<Port>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<Port> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<Port> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    pub fn get_ports(&self) -> &[Port] {
        &self.ports
    }

    fn get_ports_for_reflect(&self) -> &::protobuf::RepeatedField<Port> {
        &self.ports
    }

    fn mut_ports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Port> {
        &mut self.ports
    }
}

impl ::protobuf::Message for Ports {
    fn is_initialized(&self) -> bool {
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Ports {
    fn new() -> Ports {
        Ports::new()
    }

    fn descriptor_static(_: ::std::option::Option<Ports>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Port>>(
                    "ports",
                    Ports::get_ports_for_reflect,
                    Ports::mut_ports_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ports>(
                    "Ports",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Ports {
    fn clear(&mut self) {
        self.clear_ports();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ports {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ports {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscoveryInfo {
    // message fields
    visibility: ::std::option::Option<DiscoveryInfo_Visibility>,
    name: ::protobuf::SingularField<::std::string::String>,
    environment: ::protobuf::SingularField<::std::string::String>,
    location: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    ports: ::protobuf::SingularPtrField<Ports>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DiscoveryInfo {}

impl DiscoveryInfo {
    pub fn new() -> DiscoveryInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DiscoveryInfo {
        static mut instance: ::protobuf::lazy::Lazy<DiscoveryInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiscoveryInfo,
        };
        unsafe {
            instance.get(DiscoveryInfo::new)
        }
    }

    // required .mesos.v1.DiscoveryInfo.Visibility visibility = 1;

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: DiscoveryInfo_Visibility) {
        self.visibility = ::std::option::Option::Some(v);
    }

    pub fn get_visibility(&self) -> DiscoveryInfo_Visibility {
        self.visibility.unwrap_or(DiscoveryInfo_Visibility::FRAMEWORK)
    }

    fn get_visibility_for_reflect(&self) -> &::std::option::Option<DiscoveryInfo_Visibility> {
        &self.visibility
    }

    fn mut_visibility_for_reflect(&mut self) -> &mut ::std::option::Option<DiscoveryInfo_Visibility> {
        &mut self.visibility
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string environment = 3;

    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::std::string::String) {
        self.environment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment(&mut self) -> &mut ::std::string::String {
        if self.environment.is_none() {
            self.environment.set_default();
        }
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> ::std::string::String {
        self.environment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_environment(&self) -> &str {
        match self.environment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_environment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.environment
    }

    fn mut_environment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.environment
    }

    // optional string location = 4;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_location_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.location
    }

    fn mut_location_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.location
    }

    // optional string version = 5;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_version_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.version
    }

    // optional .mesos.v1.Ports ports = 6;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    pub fn has_ports(&self) -> bool {
        self.ports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: Ports) {
        self.ports = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ports(&mut self) -> &mut Ports {
        if self.ports.is_none() {
            self.ports.set_default();
        }
        self.ports.as_mut().unwrap()
    }

    // Take field
    pub fn take_ports(&mut self) -> Ports {
        self.ports.take().unwrap_or_else(|| Ports::new())
    }

    pub fn get_ports(&self) -> &Ports {
        self.ports.as_ref().unwrap_or_else(|| Ports::default_instance())
    }

    fn get_ports_for_reflect(&self) -> &::protobuf::SingularPtrField<Ports> {
        &self.ports
    }

    fn mut_ports_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Ports> {
        &mut self.ports
    }

    // optional .mesos.v1.Labels labels = 7;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        }
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels(&self) -> &Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    fn get_labels_for_reflect(&self) -> &::protobuf::SingularPtrField<Labels> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Labels> {
        &mut self.labels
    }
}

impl ::protobuf::Message for DiscoveryInfo {
    fn is_initialized(&self) -> bool {
        if self.visibility.is_none() {
            return false;
        }
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.environment)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.location)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ports)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.environment.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.ports.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.labels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.visibility {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.environment.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.ports.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.labels.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DiscoveryInfo {
    fn new() -> DiscoveryInfo {
        DiscoveryInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DiscoveryInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DiscoveryInfo_Visibility>>(
                    "visibility",
                    DiscoveryInfo::get_visibility_for_reflect,
                    DiscoveryInfo::mut_visibility_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    DiscoveryInfo::get_name_for_reflect,
                    DiscoveryInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "environment",
                    DiscoveryInfo::get_environment_for_reflect,
                    DiscoveryInfo::mut_environment_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "location",
                    DiscoveryInfo::get_location_for_reflect,
                    DiscoveryInfo::mut_location_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    DiscoveryInfo::get_version_for_reflect,
                    DiscoveryInfo::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ports>>(
                    "ports",
                    DiscoveryInfo::get_ports_for_reflect,
                    DiscoveryInfo::mut_ports_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Labels>>(
                    "labels",
                    DiscoveryInfo::get_labels_for_reflect,
                    DiscoveryInfo::mut_labels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiscoveryInfo>(
                    "DiscoveryInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DiscoveryInfo {
    fn clear(&mut self) {
        self.clear_visibility();
        self.clear_name();
        self.clear_environment();
        self.clear_location();
        self.clear_version();
        self.clear_ports();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveryInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveryInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DiscoveryInfo_Visibility {
    FRAMEWORK = 0,
    CLUSTER = 1,
    EXTERNAL = 2,
}

impl ::protobuf::ProtobufEnum for DiscoveryInfo_Visibility {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DiscoveryInfo_Visibility> {
        match value {
            0 => ::std::option::Option::Some(DiscoveryInfo_Visibility::FRAMEWORK),
            1 => ::std::option::Option::Some(DiscoveryInfo_Visibility::CLUSTER),
            2 => ::std::option::Option::Some(DiscoveryInfo_Visibility::EXTERNAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DiscoveryInfo_Visibility] = &[
            DiscoveryInfo_Visibility::FRAMEWORK,
            DiscoveryInfo_Visibility::CLUSTER,
            DiscoveryInfo_Visibility::EXTERNAL,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DiscoveryInfo_Visibility>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DiscoveryInfo_Visibility", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DiscoveryInfo_Visibility {
}

impl ::protobuf::reflect::ProtobufValue for DiscoveryInfo_Visibility {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeightInfo {
    // message fields
    weight: ::std::option::Option<f64>,
    role: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for WeightInfo {}

impl WeightInfo {
    pub fn new() -> WeightInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static WeightInfo {
        static mut instance: ::protobuf::lazy::Lazy<WeightInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WeightInfo,
        };
        unsafe {
            instance.get(WeightInfo::new)
        }
    }

    // required double weight = 1;

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f64) {
        self.weight = ::std::option::Option::Some(v);
    }

    pub fn get_weight(&self) -> f64 {
        self.weight.unwrap_or(0.)
    }

    fn get_weight_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.weight
    }

    fn mut_weight_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.weight
    }

    // optional string role = 2;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_role_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.role
    }
}

impl ::protobuf::Message for WeightInfo {
    fn is_initialized(&self) -> bool {
        if self.weight.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += 9;
        }
        if let Some(ref v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.weight {
            os.write_double(1, v)?;
        }
        if let Some(ref v) = self.role.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for WeightInfo {
    fn new() -> WeightInfo {
        WeightInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<WeightInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "weight",
                    WeightInfo::get_weight_for_reflect,
                    WeightInfo::mut_weight_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    WeightInfo::get_role_for_reflect,
                    WeightInfo::mut_role_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WeightInfo>(
                    "WeightInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for WeightInfo {
    fn clear(&mut self) {
        self.clear_weight();
        self.clear_role();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeightInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionInfo {
    // message fields
    version: ::protobuf::SingularField<::std::string::String>,
    build_date: ::protobuf::SingularField<::std::string::String>,
    build_time: ::std::option::Option<f64>,
    build_user: ::protobuf::SingularField<::std::string::String>,
    git_sha: ::protobuf::SingularField<::std::string::String>,
    git_branch: ::protobuf::SingularField<::std::string::String>,
    git_tag: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for VersionInfo {}

impl VersionInfo {
    pub fn new() -> VersionInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static VersionInfo {
        static mut instance: ::protobuf::lazy::Lazy<VersionInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VersionInfo,
        };
        unsafe {
            instance.get(VersionInfo::new)
        }
    }

    // required string version = 1;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_version_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.version
    }

    // optional string build_date = 2;

    pub fn clear_build_date(&mut self) {
        self.build_date.clear();
    }

    pub fn has_build_date(&self) -> bool {
        self.build_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_date(&mut self, v: ::std::string::String) {
        self.build_date = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_date(&mut self) -> &mut ::std::string::String {
        if self.build_date.is_none() {
            self.build_date.set_default();
        }
        self.build_date.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_date(&mut self) -> ::std::string::String {
        self.build_date.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_build_date(&self) -> &str {
        match self.build_date.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_build_date_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.build_date
    }

    fn mut_build_date_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.build_date
    }

    // optional double build_time = 3;

    pub fn clear_build_time(&mut self) {
        self.build_time = ::std::option::Option::None;
    }

    pub fn has_build_time(&self) -> bool {
        self.build_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_time(&mut self, v: f64) {
        self.build_time = ::std::option::Option::Some(v);
    }

    pub fn get_build_time(&self) -> f64 {
        self.build_time.unwrap_or(0.)
    }

    fn get_build_time_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.build_time
    }

    fn mut_build_time_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.build_time
    }

    // optional string build_user = 4;

    pub fn clear_build_user(&mut self) {
        self.build_user.clear();
    }

    pub fn has_build_user(&self) -> bool {
        self.build_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_user(&mut self, v: ::std::string::String) {
        self.build_user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_user(&mut self) -> &mut ::std::string::String {
        if self.build_user.is_none() {
            self.build_user.set_default();
        }
        self.build_user.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_user(&mut self) -> ::std::string::String {
        self.build_user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_build_user(&self) -> &str {
        match self.build_user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_build_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.build_user
    }

    fn mut_build_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.build_user
    }

    // optional string git_sha = 5;

    pub fn clear_git_sha(&mut self) {
        self.git_sha.clear();
    }

    pub fn has_git_sha(&self) -> bool {
        self.git_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_git_sha(&mut self, v: ::std::string::String) {
        self.git_sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_git_sha(&mut self) -> &mut ::std::string::String {
        if self.git_sha.is_none() {
            self.git_sha.set_default();
        }
        self.git_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_git_sha(&mut self) -> ::std::string::String {
        self.git_sha.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_git_sha(&self) -> &str {
        match self.git_sha.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_git_sha_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.git_sha
    }

    fn mut_git_sha_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.git_sha
    }

    // optional string git_branch = 6;

    pub fn clear_git_branch(&mut self) {
        self.git_branch.clear();
    }

    pub fn has_git_branch(&self) -> bool {
        self.git_branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_git_branch(&mut self, v: ::std::string::String) {
        self.git_branch = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_git_branch(&mut self) -> &mut ::std::string::String {
        if self.git_branch.is_none() {
            self.git_branch.set_default();
        }
        self.git_branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_git_branch(&mut self) -> ::std::string::String {
        self.git_branch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_git_branch(&self) -> &str {
        match self.git_branch.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_git_branch_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.git_branch
    }

    fn mut_git_branch_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.git_branch
    }

    // optional string git_tag = 7;

    pub fn clear_git_tag(&mut self) {
        self.git_tag.clear();
    }

    pub fn has_git_tag(&self) -> bool {
        self.git_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_git_tag(&mut self, v: ::std::string::String) {
        self.git_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_git_tag(&mut self) -> &mut ::std::string::String {
        if self.git_tag.is_none() {
            self.git_tag.set_default();
        }
        self.git_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_git_tag(&mut self) -> ::std::string::String {
        self.git_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_git_tag(&self) -> &str {
        match self.git_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_git_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.git_tag
    }

    fn mut_git_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.git_tag
    }
}

impl ::protobuf::Message for VersionInfo {
    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.build_date)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.build_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.build_user)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.git_sha)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.git_branch)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.git_tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.build_date.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.build_time {
            my_size += 9;
        }
        if let Some(ref v) = self.build_user.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.git_sha.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.git_branch.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.git_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.build_date.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.build_time {
            os.write_double(3, v)?;
        }
        if let Some(ref v) = self.build_user.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.git_sha.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.git_branch.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.git_tag.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for VersionInfo {
    fn new() -> VersionInfo {
        VersionInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<VersionInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    VersionInfo::get_version_for_reflect,
                    VersionInfo::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "build_date",
                    VersionInfo::get_build_date_for_reflect,
                    VersionInfo::mut_build_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "build_time",
                    VersionInfo::get_build_time_for_reflect,
                    VersionInfo::mut_build_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "build_user",
                    VersionInfo::get_build_user_for_reflect,
                    VersionInfo::mut_build_user_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "git_sha",
                    VersionInfo::get_git_sha_for_reflect,
                    VersionInfo::mut_git_sha_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "git_branch",
                    VersionInfo::get_git_branch_for_reflect,
                    VersionInfo::mut_git_branch_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "git_tag",
                    VersionInfo::get_git_tag_for_reflect,
                    VersionInfo::mut_git_tag_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VersionInfo>(
                    "VersionInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for VersionInfo {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_build_date();
        self.clear_build_time();
        self.clear_build_user();
        self.clear_git_sha();
        self.clear_git_branch();
        self.clear_git_tag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Flag {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Flag {}

impl Flag {
    pub fn new() -> Flag {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Flag {
        static mut instance: ::protobuf::lazy::Lazy<Flag> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Flag,
        };
        unsafe {
            instance.get(Flag::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for Flag {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Flag {
    fn new() -> Flag {
        Flag::new()
    }

    fn descriptor_static(_: ::std::option::Option<Flag>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Flag::get_name_for_reflect,
                    Flag::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Flag::get_value_for_reflect,
                    Flag::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Flag>(
                    "Flag",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Flag {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Flag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Flag {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Role {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    weight: ::std::option::Option<f64>,
    frameworks: ::protobuf::RepeatedField<FrameworkID>,
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Role {}

impl Role {
    pub fn new() -> Role {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Role {
        static mut instance: ::protobuf::lazy::Lazy<Role> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Role,
        };
        unsafe {
            instance.get(Role::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required double weight = 2;

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f64) {
        self.weight = ::std::option::Option::Some(v);
    }

    pub fn get_weight(&self) -> f64 {
        self.weight.unwrap_or(0.)
    }

    fn get_weight_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.weight
    }

    fn mut_weight_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.weight
    }

    // repeated .mesos.v1.FrameworkID frameworks = 3;

    pub fn clear_frameworks(&mut self) {
        self.frameworks.clear();
    }

    // Param is passed by value, moved
    pub fn set_frameworks(&mut self, v: ::protobuf::RepeatedField<FrameworkID>) {
        self.frameworks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frameworks(&mut self) -> &mut ::protobuf::RepeatedField<FrameworkID> {
        &mut self.frameworks
    }

    // Take field
    pub fn take_frameworks(&mut self) -> ::protobuf::RepeatedField<FrameworkID> {
        ::std::mem::replace(&mut self.frameworks, ::protobuf::RepeatedField::new())
    }

    pub fn get_frameworks(&self) -> &[FrameworkID] {
        &self.frameworks
    }

    fn get_frameworks_for_reflect(&self) -> &::protobuf::RepeatedField<FrameworkID> {
        &self.frameworks
    }

    fn mut_frameworks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<FrameworkID> {
        &mut self.frameworks
    }

    // repeated .mesos.v1.Resource resources = 4;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources(&self) -> &[Resource] {
        &self.resources
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::RepeatedField<Resource> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }
}

impl ::protobuf::Message for Role {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.weight.is_none() {
            return false;
        }
        for v in &self.frameworks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frameworks)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.weight {
            my_size += 9;
        }
        for value in &self.frameworks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.weight {
            os.write_double(2, v)?;
        }
        for v in &self.frameworks {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.resources {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Role {
    fn new() -> Role {
        Role::new()
    }

    fn descriptor_static(_: ::std::option::Option<Role>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Role::get_name_for_reflect,
                    Role::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "weight",
                    Role::get_weight_for_reflect,
                    Role::mut_weight_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameworkID>>(
                    "frameworks",
                    Role::get_frameworks_for_reflect,
                    Role::mut_frameworks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                    "resources",
                    Role::get_resources_for_reflect,
                    Role::mut_resources_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Role>(
                    "Role",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Role {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_weight();
        self.clear_frameworks();
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Role {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Role {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Metric {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Metric {}

impl Metric {
    pub fn new() -> Metric {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Metric {
        static mut instance: ::protobuf::lazy::Lazy<Metric> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Metric,
        };
        unsafe {
            instance.get(Metric::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional double value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> f64 {
        self.value.unwrap_or(0.)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<f64> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<f64> {
        &mut self.value
    }
}

impl ::protobuf::Message for Metric {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.value {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Metric {
    fn new() -> Metric {
        Metric::new()
    }

    fn descriptor_static(_: ::std::option::Option<Metric>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Metric::get_name_for_reflect,
                    Metric::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "value",
                    Metric::get_value_for_reflect,
                    Metric::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Metric>(
                    "Metric",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Metric {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metric {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileInfo {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    nlink: ::std::option::Option<i32>,
    size: ::std::option::Option<u64>,
    mtime: ::protobuf::SingularPtrField<TimeInfo>,
    mode: ::std::option::Option<u32>,
    uid: ::protobuf::SingularField<::std::string::String>,
    gid: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FileInfo {}

impl FileInfo {
    pub fn new() -> FileInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FileInfo {
        static mut instance: ::protobuf::lazy::Lazy<FileInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileInfo,
        };
        unsafe {
            instance.get(FileInfo::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional int32 nlink = 2;

    pub fn clear_nlink(&mut self) {
        self.nlink = ::std::option::Option::None;
    }

    pub fn has_nlink(&self) -> bool {
        self.nlink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nlink(&mut self, v: i32) {
        self.nlink = ::std::option::Option::Some(v);
    }

    pub fn get_nlink(&self) -> i32 {
        self.nlink.unwrap_or(0)
    }

    fn get_nlink_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.nlink
    }

    fn mut_nlink_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.nlink
    }

    // optional uint64 size = 3;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.size
    }

    // optional .mesos.v1.TimeInfo mtime = 4;

    pub fn clear_mtime(&mut self) {
        self.mtime.clear();
    }

    pub fn has_mtime(&self) -> bool {
        self.mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: TimeInfo) {
        self.mtime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mtime(&mut self) -> &mut TimeInfo {
        if self.mtime.is_none() {
            self.mtime.set_default();
        }
        self.mtime.as_mut().unwrap()
    }

    // Take field
    pub fn take_mtime(&mut self) -> TimeInfo {
        self.mtime.take().unwrap_or_else(|| TimeInfo::new())
    }

    pub fn get_mtime(&self) -> &TimeInfo {
        self.mtime.as_ref().unwrap_or_else(|| TimeInfo::default_instance())
    }

    fn get_mtime_for_reflect(&self) -> &::protobuf::SingularPtrField<TimeInfo> {
        &self.mtime
    }

    fn mut_mtime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TimeInfo> {
        &mut self.mtime
    }

    // optional uint32 mode = 5;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mode
    }

    // optional string uid = 6;

    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_uid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.uid
    }

    fn mut_uid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.uid
    }

    // optional string gid = 7;

    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::string::String) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::string::String {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::string::String {
        self.gid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gid(&self) -> &str {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gid
    }

    fn mut_gid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gid
    }
}

impl ::protobuf::Message for FileInfo {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        for v in &self.mtime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nlink = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mtime)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.nlink {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mtime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.nlink {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.mtime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.gid.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FileInfo {
    fn new() -> FileInfo {
        FileInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<FileInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    FileInfo::get_path_for_reflect,
                    FileInfo::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nlink",
                    FileInfo::get_nlink_for_reflect,
                    FileInfo::mut_nlink_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    FileInfo::get_size_for_reflect,
                    FileInfo::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeInfo>>(
                    "mtime",
                    FileInfo::get_mtime_for_reflect,
                    FileInfo::mut_mtime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode",
                    FileInfo::get_mode_for_reflect,
                    FileInfo::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    FileInfo::get_uid_for_reflect,
                    FileInfo::mut_uid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gid",
                    FileInfo::get_gid_for_reflect,
                    FileInfo::mut_gid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FileInfo>(
                    "FileInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FileInfo {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_nlink();
        self.clear_size();
        self.clear_mtime();
        self.clear_mode();
        self.clear_uid();
        self.clear_gid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    number: ::protobuf::SingularPtrField<Device_Number>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Device {}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Device {
        static mut instance: ::protobuf::lazy::Lazy<Device> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Device,
        };
        unsafe {
            instance.get(Device::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional .mesos.v1.Device.Number number = 2;

    pub fn clear_number(&mut self) {
        self.number.clear();
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: Device_Number) {
        self.number = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_number(&mut self) -> &mut Device_Number {
        if self.number.is_none() {
            self.number.set_default();
        }
        self.number.as_mut().unwrap()
    }

    // Take field
    pub fn take_number(&mut self) -> Device_Number {
        self.number.take().unwrap_or_else(|| Device_Number::new())
    }

    pub fn get_number(&self) -> &Device_Number {
        self.number.as_ref().unwrap_or_else(|| Device_Number::default_instance())
    }

    fn get_number_for_reflect(&self) -> &::protobuf::SingularPtrField<Device_Number> {
        &self.number
    }

    fn mut_number_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Device_Number> {
        &mut self.number
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        for v in &self.number {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.number)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.number.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.number.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Device {
    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static(_: ::std::option::Option<Device>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    Device::get_path_for_reflect,
                    Device::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device_Number>>(
                    "number",
                    Device::get_number_for_reflect,
                    Device::mut_number_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Device>(
                    "Device",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_number();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device_Number {
    // message fields
    major_number: ::std::option::Option<u64>,
    minor_number: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Device_Number {}

impl Device_Number {
    pub fn new() -> Device_Number {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Device_Number {
        static mut instance: ::protobuf::lazy::Lazy<Device_Number> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Device_Number,
        };
        unsafe {
            instance.get(Device_Number::new)
        }
    }

    // required uint64 major_number = 1;

    pub fn clear_major_number(&mut self) {
        self.major_number = ::std::option::Option::None;
    }

    pub fn has_major_number(&self) -> bool {
        self.major_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_number(&mut self, v: u64) {
        self.major_number = ::std::option::Option::Some(v);
    }

    pub fn get_major_number(&self) -> u64 {
        self.major_number.unwrap_or(0)
    }

    fn get_major_number_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.major_number
    }

    fn mut_major_number_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.major_number
    }

    // required uint64 minor_number = 2;

    pub fn clear_minor_number(&mut self) {
        self.minor_number = ::std::option::Option::None;
    }

    pub fn has_minor_number(&self) -> bool {
        self.minor_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_number(&mut self, v: u64) {
        self.minor_number = ::std::option::Option::Some(v);
    }

    pub fn get_minor_number(&self) -> u64 {
        self.minor_number.unwrap_or(0)
    }

    fn get_minor_number_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.minor_number
    }

    fn mut_minor_number_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.minor_number
    }
}

impl ::protobuf::Message for Device_Number {
    fn is_initialized(&self) -> bool {
        if self.major_number.is_none() {
            return false;
        }
        if self.minor_number.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.major_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minor_number = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.major_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minor_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.major_number {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.minor_number {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Device_Number {
    fn new() -> Device_Number {
        Device_Number::new()
    }

    fn descriptor_static(_: ::std::option::Option<Device_Number>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "major_number",
                    Device_Number::get_major_number_for_reflect,
                    Device_Number::mut_major_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minor_number",
                    Device_Number::get_minor_number_for_reflect,
                    Device_Number::mut_minor_number_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Device_Number>(
                    "Device_Number",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Device_Number {
    fn clear(&mut self) {
        self.clear_major_number();
        self.clear_minor_number();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device_Number {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device_Number {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceAccess {
    // message fields
    device: ::protobuf::SingularPtrField<Device>,
    access: ::protobuf::SingularPtrField<DeviceAccess_Access>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeviceAccess {}

impl DeviceAccess {
    pub fn new() -> DeviceAccess {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeviceAccess {
        static mut instance: ::protobuf::lazy::Lazy<DeviceAccess> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceAccess,
        };
        unsafe {
            instance.get(DeviceAccess::new)
        }
    }

    // required .mesos.v1.Device device = 1;

    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: Device) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut Device {
        if self.device.is_none() {
            self.device.set_default();
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> Device {
        self.device.take().unwrap_or_else(|| Device::new())
    }

    pub fn get_device(&self) -> &Device {
        self.device.as_ref().unwrap_or_else(|| Device::default_instance())
    }

    fn get_device_for_reflect(&self) -> &::protobuf::SingularPtrField<Device> {
        &self.device
    }

    fn mut_device_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Device> {
        &mut self.device
    }

    // required .mesos.v1.DeviceAccess.Access access = 2;

    pub fn clear_access(&mut self) {
        self.access.clear();
    }

    pub fn has_access(&self) -> bool {
        self.access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access(&mut self, v: DeviceAccess_Access) {
        self.access = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access(&mut self) -> &mut DeviceAccess_Access {
        if self.access.is_none() {
            self.access.set_default();
        }
        self.access.as_mut().unwrap()
    }

    // Take field
    pub fn take_access(&mut self) -> DeviceAccess_Access {
        self.access.take().unwrap_or_else(|| DeviceAccess_Access::new())
    }

    pub fn get_access(&self) -> &DeviceAccess_Access {
        self.access.as_ref().unwrap_or_else(|| DeviceAccess_Access::default_instance())
    }

    fn get_access_for_reflect(&self) -> &::protobuf::SingularPtrField<DeviceAccess_Access> {
        &self.access
    }

    fn mut_access_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DeviceAccess_Access> {
        &mut self.access
    }
}

impl ::protobuf::Message for DeviceAccess {
    fn is_initialized(&self) -> bool {
        if self.device.is_none() {
            return false;
        }
        if self.access.is_none() {
            return false;
        }
        for v in &self.device {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.access {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.access)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.access.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.access.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeviceAccess {
    fn new() -> DeviceAccess {
        DeviceAccess::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeviceAccess>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                    "device",
                    DeviceAccess::get_device_for_reflect,
                    DeviceAccess::mut_device_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceAccess_Access>>(
                    "access",
                    DeviceAccess::get_access_for_reflect,
                    DeviceAccess::mut_access_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceAccess>(
                    "DeviceAccess",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeviceAccess {
    fn clear(&mut self) {
        self.clear_device();
        self.clear_access();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceAccess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAccess {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceAccess_Access {
    // message fields
    read: ::std::option::Option<bool>,
    write: ::std::option::Option<bool>,
    mknod: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeviceAccess_Access {}

impl DeviceAccess_Access {
    pub fn new() -> DeviceAccess_Access {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeviceAccess_Access {
        static mut instance: ::protobuf::lazy::Lazy<DeviceAccess_Access> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceAccess_Access,
        };
        unsafe {
            instance.get(DeviceAccess_Access::new)
        }
    }

    // optional bool read = 1;

    pub fn clear_read(&mut self) {
        self.read = ::std::option::Option::None;
    }

    pub fn has_read(&self) -> bool {
        self.read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: bool) {
        self.read = ::std::option::Option::Some(v);
    }

    pub fn get_read(&self) -> bool {
        self.read.unwrap_or(false)
    }

    fn get_read_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.read
    }

    fn mut_read_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.read
    }

    // optional bool write = 2;

    pub fn clear_write(&mut self) {
        self.write = ::std::option::Option::None;
    }

    pub fn has_write(&self) -> bool {
        self.write.is_some()
    }

    // Param is passed by value, moved
    pub fn set_write(&mut self, v: bool) {
        self.write = ::std::option::Option::Some(v);
    }

    pub fn get_write(&self) -> bool {
        self.write.unwrap_or(false)
    }

    fn get_write_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.write
    }

    fn mut_write_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.write
    }

    // optional bool mknod = 3;

    pub fn clear_mknod(&mut self) {
        self.mknod = ::std::option::Option::None;
    }

    pub fn has_mknod(&self) -> bool {
        self.mknod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mknod(&mut self, v: bool) {
        self.mknod = ::std::option::Option::Some(v);
    }

    pub fn get_mknod(&self) -> bool {
        self.mknod.unwrap_or(false)
    }

    fn get_mknod_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.mknod
    }

    fn mut_mknod_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.mknod
    }
}

impl ::protobuf::Message for DeviceAccess_Access {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.read = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.write = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mknod = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.read {
            my_size += 2;
        }
        if let Some(v) = self.write {
            my_size += 2;
        }
        if let Some(v) = self.mknod {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.read {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.write {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.mknod {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeviceAccess_Access {
    fn new() -> DeviceAccess_Access {
        DeviceAccess_Access::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeviceAccess_Access>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "read",
                    DeviceAccess_Access::get_read_for_reflect,
                    DeviceAccess_Access::mut_read_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "write",
                    DeviceAccess_Access::get_write_for_reflect,
                    DeviceAccess_Access::mut_write_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mknod",
                    DeviceAccess_Access::get_mknod_for_reflect,
                    DeviceAccess_Access::mut_mknod_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceAccess_Access>(
                    "DeviceAccess_Access",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeviceAccess_Access {
    fn clear(&mut self) {
        self.clear_read();
        self.clear_write();
        self.clear_mknod();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceAccess_Access {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAccess_Access {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceWhitelist {
    // message fields
    allowed_devices: ::protobuf::RepeatedField<DeviceAccess>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeviceWhitelist {}

impl DeviceWhitelist {
    pub fn new() -> DeviceWhitelist {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeviceWhitelist {
        static mut instance: ::protobuf::lazy::Lazy<DeviceWhitelist> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceWhitelist,
        };
        unsafe {
            instance.get(DeviceWhitelist::new)
        }
    }

    // repeated .mesos.v1.DeviceAccess allowed_devices = 1;

    pub fn clear_allowed_devices(&mut self) {
        self.allowed_devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_devices(&mut self, v: ::protobuf::RepeatedField<DeviceAccess>) {
        self.allowed_devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_devices(&mut self) -> &mut ::protobuf::RepeatedField<DeviceAccess> {
        &mut self.allowed_devices
    }

    // Take field
    pub fn take_allowed_devices(&mut self) -> ::protobuf::RepeatedField<DeviceAccess> {
        ::std::mem::replace(&mut self.allowed_devices, ::protobuf::RepeatedField::new())
    }

    pub fn get_allowed_devices(&self) -> &[DeviceAccess] {
        &self.allowed_devices
    }

    fn get_allowed_devices_for_reflect(&self) -> &::protobuf::RepeatedField<DeviceAccess> {
        &self.allowed_devices
    }

    fn mut_allowed_devices_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DeviceAccess> {
        &mut self.allowed_devices
    }
}

impl ::protobuf::Message for DeviceWhitelist {
    fn is_initialized(&self) -> bool {
        for v in &self.allowed_devices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allowed_devices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_devices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeviceWhitelist {
    fn new() -> DeviceWhitelist {
        DeviceWhitelist::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeviceWhitelist>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceAccess>>(
                    "allowed_devices",
                    DeviceWhitelist::get_allowed_devices_for_reflect,
                    DeviceWhitelist::mut_allowed_devices_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceWhitelist>(
                    "DeviceWhitelist",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeviceWhitelist {
    fn clear(&mut self) {
        self.clear_allowed_devices();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceWhitelist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceWhitelist {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    DRIVER_NOT_STARTED = 1,
    DRIVER_RUNNING = 2,
    DRIVER_ABORTED = 3,
    DRIVER_STOPPED = 4,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            1 => ::std::option::Option::Some(Status::DRIVER_NOT_STARTED),
            2 => ::std::option::Option::Some(Status::DRIVER_RUNNING),
            3 => ::std::option::Option::Some(Status::DRIVER_ABORTED),
            4 => ::std::option::Option::Some(Status::DRIVER_STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::DRIVER_NOT_STARTED,
            Status::DRIVER_RUNNING,
            Status::DRIVER_ABORTED,
            Status::DRIVER_STOPPED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Status>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Status {
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskState {
    TASK_STAGING = 6,
    TASK_STARTING = 0,
    TASK_RUNNING = 1,
    TASK_KILLING = 8,
    TASK_FINISHED = 2,
    TASK_FAILED = 3,
    TASK_KILLED = 4,
    TASK_ERROR = 7,
    TASK_LOST = 5,
    TASK_DROPPED = 9,
    TASK_UNREACHABLE = 10,
    TASK_GONE = 11,
    TASK_GONE_BY_OPERATOR = 12,
    TASK_UNKNOWN = 13,
}

impl ::protobuf::ProtobufEnum for TaskState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskState> {
        match value {
            6 => ::std::option::Option::Some(TaskState::TASK_STAGING),
            0 => ::std::option::Option::Some(TaskState::TASK_STARTING),
            1 => ::std::option::Option::Some(TaskState::TASK_RUNNING),
            8 => ::std::option::Option::Some(TaskState::TASK_KILLING),
            2 => ::std::option::Option::Some(TaskState::TASK_FINISHED),
            3 => ::std::option::Option::Some(TaskState::TASK_FAILED),
            4 => ::std::option::Option::Some(TaskState::TASK_KILLED),
            7 => ::std::option::Option::Some(TaskState::TASK_ERROR),
            5 => ::std::option::Option::Some(TaskState::TASK_LOST),
            9 => ::std::option::Option::Some(TaskState::TASK_DROPPED),
            10 => ::std::option::Option::Some(TaskState::TASK_UNREACHABLE),
            11 => ::std::option::Option::Some(TaskState::TASK_GONE),
            12 => ::std::option::Option::Some(TaskState::TASK_GONE_BY_OPERATOR),
            13 => ::std::option::Option::Some(TaskState::TASK_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskState] = &[
            TaskState::TASK_STAGING,
            TaskState::TASK_STARTING,
            TaskState::TASK_RUNNING,
            TaskState::TASK_KILLING,
            TaskState::TASK_FINISHED,
            TaskState::TASK_FAILED,
            TaskState::TASK_KILLED,
            TaskState::TASK_ERROR,
            TaskState::TASK_LOST,
            TaskState::TASK_DROPPED,
            TaskState::TASK_UNREACHABLE,
            TaskState::TASK_GONE,
            TaskState::TASK_GONE_BY_OPERATOR,
            TaskState::TASK_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<TaskState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskState {
}

impl ::protobuf::reflect::ProtobufValue for TaskState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationState {
    OPERATION_UNSUPPORTED = 0,
    OPERATION_PENDING = 1,
    OPERATION_FINISHED = 2,
    OPERATION_FAILED = 3,
    OPERATION_ERROR = 4,
    OPERATION_DROPPED = 5,
}

impl ::protobuf::ProtobufEnum for OperationState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationState> {
        match value {
            0 => ::std::option::Option::Some(OperationState::OPERATION_UNSUPPORTED),
            1 => ::std::option::Option::Some(OperationState::OPERATION_PENDING),
            2 => ::std::option::Option::Some(OperationState::OPERATION_FINISHED),
            3 => ::std::option::Option::Some(OperationState::OPERATION_FAILED),
            4 => ::std::option::Option::Some(OperationState::OPERATION_ERROR),
            5 => ::std::option::Option::Some(OperationState::OPERATION_DROPPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationState] = &[
            OperationState::OPERATION_UNSUPPORTED,
            OperationState::OPERATION_PENDING,
            OperationState::OPERATION_FINISHED,
            OperationState::OPERATION_FAILED,
            OperationState::OPERATION_ERROR,
            OperationState::OPERATION_DROPPED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<OperationState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OperationState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OperationState {
}

impl ::protobuf::reflect::ProtobufValue for OperationState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14mesos/v1/mesos.proto\x12\x08mesos.v1\"#\n\x0bFrameworkID\x12\x14\n\
    \x05value\x18\x01\x20\x02(\tR\x05value\"\x1f\n\x07OfferID\x12\x14\n\x05v\
    alue\x18\x01\x20\x02(\tR\x05value\"\x1f\n\x07AgentID\x12\x14\n\x05value\
    \x18\x01\x20\x02(\tR\x05value\"\x1e\n\x06TaskID\x12\x14\n\x05value\x18\
    \x01\x20\x02(\tR\x05value\"\"\n\nExecutorID\x12\x14\n\x05value\x18\x01\
    \x20\x02(\tR\x05value\"R\n\x0bContainerID\x12\x14\n\x05value\x18\x01\x20\
    \x02(\tR\x05value\x12-\n\x06parent\x18\x02\x20\x01(\x0b2\x15.mesos.v1.Co\
    ntainerIDR\x06parent\"*\n\x12ResourceProviderID\x12\x14\n\x05value\x18\
    \x01\x20\x02(\tR\x05value\"#\n\x0bOperationID\x12\x14\n\x05value\x18\x01\
    \x20\x02(\tR\x05value\",\n\x08TimeInfo\x12\x20\n\x0bnanoseconds\x18\x01\
    \x20\x02(\x03R\x0bnanoseconds\"0\n\x0cDurationInfo\x12\x20\n\x0bnanoseco\
    nds\x18\x01\x20\x02(\x03R\x0bnanoseconds\"I\n\x07Address\x12\x1a\n\x08ho\
    stname\x18\x01\x20\x01(\tR\x08hostname\x12\x0e\n\x02ip\x18\x02\x20\x01(\
    \tR\x02ip\x12\x12\n\x04port\x18\x03\x20\x02(\x05R\x04port\"\xa5\x01\n\
    \x03URL\x12\x16\n\x06scheme\x18\x01\x20\x02(\tR\x06scheme\x12+\n\x07addr\
    ess\x18\x02\x20\x02(\x0b2\x11.mesos.v1.AddressR\x07address\x12\x12\n\x04\
    path\x18\x03\x20\x01(\tR\x04path\x12)\n\x05query\x18\x04\x20\x03(\x0b2\
    \x13.mesos.v1.ParameterR\x05query\x12\x1a\n\x08fragment\x18\x05\x20\x01(\
    \tR\x08fragment\"n\n\x0eUnavailability\x12(\n\x05start\x18\x01\x20\x02(\
    \x0b2\x12.mesos.v1.TimeInfoR\x05start\x122\n\x08duration\x18\x02\x20\x01\
    (\x0b2\x16.mesos.v1.DurationInfoR\x08duration\"7\n\tMachineID\x12\x1a\n\
    \x08hostname\x18\x01\x20\x01(\tR\x08hostname\x12\x0e\n\x02ip\x18\x02\x20\
    \x01(\tR\x02ip\"\xcc\x01\n\x0bMachineInfo\x12#\n\x02id\x18\x01\x20\x02(\
    \x0b2\x13.mesos.v1.MachineIDR\x02id\x12.\n\x04mode\x18\x02\x20\x01(\x0e2\
    \x1a.mesos.v1.MachineInfo.ModeR\x04mode\x12@\n\x0eunavailability\x18\x03\
    \x20\x01(\x0b2\x18.mesos.v1.UnavailabilityR\x0eunavailability\"&\n\x04Mo\
    de\x12\x06\n\x02UP\x10\x01\x12\x0c\n\x08DRAINING\x10\x02\x12\x08\n\x04DO\
    WN\x10\x03\"\xbc\x05\n\rFrameworkInfo\x12\x12\n\x04user\x18\x01\x20\x02(\
    \tR\x04user\x12\x12\n\x04name\x18\x02\x20\x02(\tR\x04name\x12%\n\x02id\
    \x18\x03\x20\x01(\x0b2\x15.mesos.v1.FrameworkIDR\x02id\x12,\n\x10failove\
    r_timeout\x18\x04\x20\x01(\x01:\x010R\x0ffailoverTimeout\x12%\n\ncheckpo\
    int\x18\x05\x20\x01(\x08:\x05falseR\ncheckpoint\x12\x19\n\x04role\x18\
    \x06\x20\x01(\t:\x01*R\x04roleB\x02\x18\x01\x12\x14\n\x05roles\x18\x0c\
    \x20\x03(\tR\x05roles\x12\x1a\n\x08hostname\x18\x07\x20\x01(\tR\x08hostn\
    ame\x12\x1c\n\tprincipal\x18\x08\x20\x01(\tR\tprincipal\x12\x1b\n\twebui\
    _url\x18\t\x20\x01(\tR\x08webuiUrl\x12F\n\x0ccapabilities\x18\n\x20\x03(\
    \x0b2\".mesos.v1.FrameworkInfo.CapabilityR\x0ccapabilities\x12(\n\x06lab\
    els\x18\x0b\x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06labels\x1a\x8c\x02\n\n\
    Capability\x12;\n\x04type\x18\x01\x20\x01(\x0e2'.mesos.v1.FrameworkInfo.\
    Capability.TypeR\x04type\"\xc0\x01\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\
    \x12\x17\n\x13REVOCABLE_RESOURCES\x10\x01\x12\x16\n\x12TASK_KILLING_STAT\
    E\x10\x02\x12\x11\n\rGPU_RESOURCES\x10\x03\x12\x14\n\x10SHARED_RESOURCES\
    \x10\x04\x12\x13\n\x0fPARTITION_AWARE\x10\x05\x12\x0e\n\nMULTI_ROLE\x10\
    \x06\x12\x1a\n\x16RESERVATION_REFINEMENT\x10\x07\x12\x10\n\x0cREGION_AWA\
    RE\x10\x08\"\x8a\x04\n\tCheckInfo\x12,\n\x04type\x18\x01\x20\x01(\x0e2\
    \x18.mesos.v1.CheckInfo.TypeR\x04type\x125\n\x07command\x18\x02\x20\x01(\
    \x0b2\x1b.mesos.v1.CheckInfo.CommandR\x07command\x12,\n\x04http\x18\x03\
    \x20\x01(\x0b2\x18.mesos.v1.CheckInfo.HttpR\x04http\x12)\n\x03tcp\x18\
    \x07\x20\x01(\x0b2\x17.mesos.v1.CheckInfo.TcpR\x03tcp\x12'\n\rdelay_seco\
    nds\x18\x04\x20\x01(\x01:\x0215R\x0cdelaySeconds\x12-\n\x10interval_seco\
    nds\x18\x05\x20\x01(\x01:\x0210R\x0fintervalSeconds\x12+\n\x0ftimeout_se\
    conds\x18\x06\x20\x01(\x01:\x0220R\x0etimeoutSeconds\x1a:\n\x07Command\
    \x12/\n\x07command\x18\x01\x20\x02(\x0b2\x15.mesos.v1.CommandInfoR\x07co\
    mmand\x1a.\n\x04Http\x12\x12\n\x04port\x18\x01\x20\x02(\rR\x04port\x12\
    \x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x1a\x19\n\x03Tcp\x12\x12\n\
    \x04port\x18\x01\x20\x02(\rR\x04port\"3\n\x04Type\x12\x0b\n\x07UNKNOWN\
    \x10\0\x12\x0b\n\x07COMMAND\x10\x01\x12\x08\n\x04HTTP\x10\x02\x12\x07\n\
    \x03TCP\x10\x03\"\x99\x06\n\x0bHealthCheck\x12'\n\rdelay_seconds\x18\x02\
    \x20\x01(\x01:\x0215R\x0cdelaySeconds\x12-\n\x10interval_seconds\x18\x03\
    \x20\x01(\x01:\x0210R\x0fintervalSeconds\x12+\n\x0ftimeout_seconds\x18\
    \x04\x20\x01(\x01:\x0220R\x0etimeoutSeconds\x124\n\x14consecutive_failur\
    es\x18\x05\x20\x01(\r:\x013R\x13consecutiveFailures\x124\n\x14grace_peri\
    od_seconds\x18\x06\x20\x01(\x01:\x0210R\x12gracePeriodSeconds\x12.\n\x04\
    type\x18\x08\x20\x01(\x0e2\x1a.mesos.v1.HealthCheck.TypeR\x04type\x12/\n\
    \x07command\x18\x07\x20\x01(\x0b2\x15.mesos.v1.CommandInfoR\x07command\
    \x127\n\x04http\x18\x01\x20\x01(\x0b2#.mesos.v1.HealthCheck.HTTPCheckInf\
    oR\x04http\x124\n\x03tcp\x18\t\x20\x01(\x0b2\".mesos.v1.HealthCheck.TCPC\
    heckInfoR\x03tcp\x1a\xad\x01\n\rHTTPCheckInfo\x12@\n\x08protocol\x18\x05\
    \x20\x01(\x0e2\x1e.mesos.v1.NetworkInfo.Protocol:\x04IPv4R\x08protocol\
    \x12\x16\n\x06scheme\x18\x03\x20\x01(\tR\x06scheme\x12\x12\n\x04port\x18\
    \x01\x20\x02(\rR\x04port\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\
    \x12\x1a\n\x08statuses\x18\x04\x20\x03(\rR\x08statuses\x1ad\n\x0cTCPChec\
    kInfo\x12@\n\x08protocol\x18\x02\x20\x01(\x0e2\x1e.mesos.v1.NetworkInfo.\
    Protocol:\x04IPv4R\x08protocol\x12\x12\n\x04port\x18\x01\x20\x02(\rR\x04\
    port\"3\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07COMMAND\x10\
    \x01\x12\x08\n\x04HTTP\x10\x02\x12\x07\n\x03TCP\x10\x03\"G\n\nKillPolicy\
    \x129\n\x0cgrace_period\x18\x01\x20\x01(\x0b2\x16.mesos.v1.DurationInfoR\
    \x0bgracePeriod\"\xee\x02\n\x0bCommandInfo\x12-\n\x04uris\x18\x01\x20\
    \x03(\x0b2\x19.mesos.v1.CommandInfo.URIR\x04uris\x127\n\x0benvironment\
    \x18\x02\x20\x01(\x0b2\x15.mesos.v1.EnvironmentR\x0benvironment\x12\x1a\
    \n\x05shell\x18\x06\x20\x01(\x08:\x04trueR\x05shell\x12\x14\n\x05value\
    \x18\x03\x20\x01(\tR\x05value\x12\x1c\n\targuments\x18\x07\x20\x03(\tR\t\
    arguments\x12\x12\n\x04user\x18\x05\x20\x01(\tR\x04user\x1a\x92\x01\n\
    \x03URI\x12\x14\n\x05value\x18\x01\x20\x02(\tR\x05value\x12\x1e\n\nexecu\
    table\x18\x02\x20\x01(\x08R\nexecutable\x12\x1e\n\x07extract\x18\x03\x20\
    \x01(\x08:\x04trueR\x07extract\x12\x14\n\x05cache\x18\x04\x20\x01(\x08R\
    \x05cache\x12\x1f\n\x0boutput_file\x18\x05\x20\x01(\tR\noutputFile\"\xe9\
    \x04\n\x0cExecutorInfo\x12/\n\x04type\x18\x0f\x20\x01(\x0e2\x1b.mesos.v1\
    .ExecutorInfo.TypeR\x04type\x125\n\x0bexecutor_id\x18\x01\x20\x02(\x0b2\
    \x14.mesos.v1.ExecutorIDR\nexecutorId\x128\n\x0cframework_id\x18\x08\x20\
    \x01(\x0b2\x15.mesos.v1.FrameworkIDR\x0bframeworkId\x12/\n\x07command\
    \x18\x07\x20\x01(\x0b2\x15.mesos.v1.CommandInfoR\x07command\x125\n\tcont\
    ainer\x18\x0b\x20\x01(\x0b2\x17.mesos.v1.ContainerInfoR\tcontainer\x120\
    \n\tresources\x18\x05\x20\x03(\x0b2\x12.mesos.v1.ResourceR\tresources\
    \x12\x12\n\x04name\x18\t\x20\x01(\tR\x04name\x12\x1a\n\x06source\x18\n\
    \x20\x01(\tR\x06sourceB\x02\x18\x01\x12\x12\n\x04data\x18\x04\x20\x01(\
    \x0cR\x04data\x125\n\tdiscovery\x18\x0c\x20\x01(\x0b2\x17.mesos.v1.Disco\
    veryInfoR\tdiscovery\x12J\n\x15shutdown_grace_period\x18\r\x20\x01(\x0b2\
    \x16.mesos.v1.DurationInfoR\x13shutdownGracePeriod\x12(\n\x06labels\x18\
    \x0e\x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06labels\",\n\x04Type\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\x0b\n\x07DEFAULT\x10\x01\x12\n\n\x06CUSTOM\x10\x02\
    \"\xa7\x02\n\nDomainInfo\x12C\n\x0cfault_domain\x18\x01\x20\x01(\x0b2\
    \x20.mesos.v1.DomainInfo.FaultDomainR\x0bfaultDomain\x1a\xd3\x01\n\x0bFa\
    ultDomain\x12C\n\x06region\x18\x01\x20\x02(\x0b2+.mesos.v1.DomainInfo.Fa\
    ultDomain.RegionInfoR\x06region\x12=\n\x04zone\x18\x02\x20\x02(\x0b2).me\
    sos.v1.DomainInfo.FaultDomain.ZoneInfoR\x04zone\x1a\x20\n\nRegionInfo\
    \x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x1a\x1e\n\x08ZoneInfo\x12\
    \x12\n\x04name\x18\x01\x20\x02(\tR\x04name\"\x9d\x03\n\nMasterInfo\x12\
    \x0e\n\x02id\x18\x01\x20\x02(\tR\x02id\x12\x0e\n\x02ip\x18\x02\x20\x02(\
    \rR\x02ip\x12\x18\n\x04port\x18\x03\x20\x02(\r:\x045050R\x04port\x12\x10\
    \n\x03pid\x18\x04\x20\x01(\tR\x03pid\x12\x1a\n\x08hostname\x18\x05\x20\
    \x01(\tR\x08hostname\x12\x18\n\x07version\x18\x06\x20\x01(\tR\x07version\
    \x12+\n\x07address\x18\x07\x20\x01(\x0b2\x11.mesos.v1.AddressR\x07addres\
    s\x12,\n\x06domain\x18\x08\x20\x01(\x0b2\x14.mesos.v1.DomainInfoR\x06dom\
    ain\x12C\n\x0ccapabilities\x18\t\x20\x03(\x0b2\x1f.mesos.v1.MasterInfo.C\
    apabilityR\x0ccapabilities\x1am\n\nCapability\x128\n\x04type\x18\x01\x20\
    \x01(\x0e2$.mesos.v1.MasterInfo.Capability.TypeR\x04type\"%\n\x04Type\
    \x12\x0b\n\x07UNKNOWN\x10\0\x12\x10\n\x0cAGENT_UPDATE\x10\x01\"\xb0\x03\
    \n\tAgentInfo\x12\x1a\n\x08hostname\x18\x01\x20\x02(\tR\x08hostname\x12\
    \x18\n\x04port\x18\x08\x20\x01(\x05:\x045051R\x04port\x120\n\tresources\
    \x18\x03\x20\x03(\x0b2\x12.mesos.v1.ResourceR\tresources\x123\n\nattribu\
    tes\x18\x05\x20\x03(\x0b2\x13.mesos.v1.AttributeR\nattributes\x12!\n\x02\
    id\x18\x06\x20\x01(\x0b2\x11.mesos.v1.AgentIDR\x02id\x12,\n\x06domain\
    \x18\n\x20\x01(\x0b2\x14.mesos.v1.DomainInfoR\x06domain\x1a\xb4\x01\n\nC\
    apability\x127\n\x04type\x18\x01\x20\x01(\x0e2#.mesos.v1.AgentInfo.Capab\
    ility.TypeR\x04type\"m\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0e\n\nM\
    ULTI_ROLE\x10\x01\x12\x15\n\x11HIERARCHICAL_ROLE\x10\x02\x12\x1a\n\x16RE\
    SERVATION_REFINEMENT\x10\x03\x12\x15\n\x11RESOURCE_PROVIDER\x10\x04\"\
    \xba\x02\n\x16CSIPluginContainerInfo\x12D\n\x08services\x18\x01\x20\x03(\
    \x0e2(.mesos.v1.CSIPluginContainerInfo.ServiceR\x08services\x12/\n\x07co\
    mmand\x18\x02\x20\x01(\x0b2\x15.mesos.v1.CommandInfoR\x07command\x120\n\
    \tresources\x18\x03\x20\x03(\x0b2\x12.mesos.v1.ResourceR\tresources\x125\
    \n\tcontainer\x18\x04\x20\x01(\x0b2\x17.mesos.v1.ContainerInfoR\tcontain\
    er\"@\n\x07Service\x12\x0b\n\x07UNKNOWN\x10\0\x12\x16\n\x12CONTROLLER_SE\
    RVICE\x10\x01\x12\x10\n\x0cNODE_SERVICE\x10\x02\"y\n\rCSIPluginInfo\x12\
    \x12\n\x04type\x18\x01\x20\x02(\tR\x04type\x12\x12\n\x04name\x18\x02\x20\
    \x02(\tR\x04name\x12@\n\ncontainers\x18\x03\x20\x03(\x0b2\x20.mesos.v1.C\
    SIPluginContainerInfoR\ncontainers\"\xf6\x02\n\x14ResourceProviderInfo\
    \x12,\n\x02id\x18\x01\x20\x01(\x0b2\x1c.mesos.v1.ResourceProviderIDR\x02\
    id\x123\n\nattributes\x18\x02\x20\x03(\x0b2\x13.mesos.v1.AttributeR\natt\
    ributes\x12\x12\n\x04type\x18\x03\x20\x02(\tR\x04type\x12\x12\n\x04name\
    \x18\x04\x20\x02(\tR\x04name\x12U\n\x14default_reservations\x18\x05\x20\
    \x03(\x0b2\".mesos.v1.Resource.ReservationInfoR\x13defaultReservations\
    \x12@\n\x07storage\x18\x06\x20\x01(\x0b2&.mesos.v1.ResourceProviderInfo.\
    StorageR\x07storage\x1a:\n\x07Storage\x12/\n\x06plugin\x18\x01\x20\x02(\
    \x0b2\x17.mesos.v1.CSIPluginInfoR\x06plugin\"\xd6\x03\n\x05Value\x12(\n\
    \x04type\x18\x01\x20\x02(\x0e2\x14.mesos.v1.Value.TypeR\x04type\x12.\n\
    \x06scalar\x18\x02\x20\x01(\x0b2\x16.mesos.v1.Value.ScalarR\x06scalar\
    \x12.\n\x06ranges\x18\x03\x20\x01(\x0b2\x16.mesos.v1.Value.RangesR\x06ra\
    nges\x12%\n\x03set\x18\x04\x20\x01(\x0b2\x13.mesos.v1.Value.SetR\x03set\
    \x12(\n\x04text\x18\x05\x20\x01(\x0b2\x14.mesos.v1.Value.TextR\x04text\
    \x1a\x1e\n\x06Scalar\x12\x14\n\x05value\x18\x01\x20\x02(\x01R\x05value\
    \x1a/\n\x05Range\x12\x14\n\x05begin\x18\x01\x20\x02(\x04R\x05begin\x12\
    \x10\n\x03end\x18\x02\x20\x02(\x04R\x03end\x1a5\n\x06Ranges\x12+\n\x05ra\
    nge\x18\x01\x20\x03(\x0b2\x15.mesos.v1.Value.RangeR\x05range\x1a\x19\n\
    \x03Set\x12\x12\n\x04item\x18\x01\x20\x03(\tR\x04item\x1a\x1c\n\x04Text\
    \x12\x14\n\x05value\x18\x01\x20\x02(\tR\x05value\"1\n\x04Type\x12\n\n\
    \x06SCALAR\x10\0\x12\n\n\x06RANGES\x10\x01\x12\x07\n\x03SET\x10\x02\x12\
    \x08\n\x04TEXT\x10\x03\"\xfa\x01\n\tAttribute\x12\x12\n\x04name\x18\x01\
    \x20\x02(\tR\x04name\x12(\n\x04type\x18\x02\x20\x02(\x0e2\x14.mesos.v1.V\
    alue.TypeR\x04type\x12.\n\x06scalar\x18\x03\x20\x01(\x0b2\x16.mesos.v1.V\
    alue.ScalarR\x06scalar\x12.\n\x06ranges\x18\x04\x20\x01(\x0b2\x16.mesos.\
    v1.Value.RangesR\x06ranges\x12%\n\x03set\x18\x06\x20\x01(\x0b2\x13.mesos\
    .v1.Value.SetR\x03set\x12(\n\x04text\x18\x05\x20\x01(\x0b2\x14.mesos.v1.\
    Value.TextR\x04text\"\xda\x0c\n\x08Resource\x12=\n\x0bprovider_id\x18\
    \x0c\x20\x01(\x0b2\x1c.mesos.v1.ResourceProviderIDR\nproviderId\x12\x12\
    \n\x04name\x18\x01\x20\x02(\tR\x04name\x12(\n\x04type\x18\x02\x20\x02(\
    \x0e2\x14.mesos.v1.Value.TypeR\x04type\x12.\n\x06scalar\x18\x03\x20\x01(\
    \x0b2\x16.mesos.v1.Value.ScalarR\x06scalar\x12.\n\x06ranges\x18\x04\x20\
    \x01(\x0b2\x16.mesos.v1.Value.RangesR\x06ranges\x12%\n\x03set\x18\x05\
    \x20\x01(\x0b2\x13.mesos.v1.Value.SetR\x03set\x12\x19\n\x04role\x18\x06\
    \x20\x01(\t:\x01*R\x04roleB\x02\x18\x01\x12J\n\x0fallocation_info\x18\
    \x0b\x20\x01(\x0b2!.mesos.v1.Resource.AllocationInfoR\x0eallocationInfo\
    \x12D\n\x0breservation\x18\x08\x20\x01(\x0b2\".mesos.v1.Resource.Reserva\
    tionInfoR\x0breservation\x12F\n\x0creservations\x18\r\x20\x03(\x0b2\".me\
    sos.v1.Resource.ReservationInfoR\x0creservations\x12/\n\x04disk\x18\x07\
    \x20\x01(\x0b2\x1b.mesos.v1.Resource.DiskInfoR\x04disk\x12>\n\trevocable\
    \x18\t\x20\x01(\x0b2\x20.mesos.v1.Resource.RevocableInfoR\trevocable\x12\
    5\n\x06shared\x18\n\x20\x01(\x0b2\x1d.mesos.v1.Resource.SharedInfoR\x06s\
    hared\x1a$\n\x0eAllocationInfo\x12\x12\n\x04role\x18\x01\x20\x01(\tR\x04\
    role\x1a\xd8\x01\n\x0fReservationInfo\x12;\n\x04type\x18\x04\x20\x01(\
    \x0e2'.mesos.v1.Resource.ReservationInfo.TypeR\x04type\x12\x12\n\x04role\
    \x18\x03\x20\x01(\tR\x04role\x12\x1c\n\tprincipal\x18\x01\x20\x01(\tR\tp\
    rincipal\x12(\n\x06labels\x18\x02\x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06\
    labels\",\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06STATIC\x10\x01\
    \x12\x0b\n\x07DYNAMIC\x10\x02\x1a\x8c\x05\n\x08DiskInfo\x12I\n\x0bpersis\
    tence\x18\x01\x20\x01(\x0b2'.mesos.v1.Resource.DiskInfo.PersistenceR\x0b\
    persistence\x12(\n\x06volume\x18\x02\x20\x01(\x0b2\x10.mesos.v1.VolumeR\
    \x06volume\x12:\n\x06source\x18\x03\x20\x01(\x0b2\".mesos.v1.Resource.Di\
    skInfo.SourceR\x06source\x1a;\n\x0bPersistence\x12\x0e\n\x02id\x18\x01\
    \x20\x02(\tR\x02id\x12\x1c\n\tprincipal\x18\x02\x20\x01(\tR\tprincipal\
    \x1a\x91\x03\n\x06Source\x12;\n\x04type\x18\x01\x20\x02(\x0e2'.mesos.v1.\
    Resource.DiskInfo.Source.TypeR\x04type\x12;\n\x04path\x18\x02\x20\x01(\
    \x0b2'.mesos.v1.Resource.DiskInfo.Source.PathR\x04path\x12>\n\x05mount\
    \x18\x03\x20\x01(\x0b2(.mesos.v1.Resource.DiskInfo.Source.MountR\x05moun\
    t\x12\x0e\n\x02id\x18\x04\x20\x01(\tR\x02id\x12,\n\x08metadata\x18\x05\
    \x20\x01(\x0b2\x10.mesos.v1.LabelsR\x08metadata\x12\x18\n\x07profile\x18\
    \x06\x20\x01(\tR\x07profile\x1a\x1a\n\x04Path\x12\x12\n\x04root\x18\x01\
    \x20\x01(\tR\x04root\x1a\x1b\n\x05Mount\x12\x12\n\x04root\x18\x01\x20\
    \x01(\tR\x04root\"<\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x08\n\x04PA\
    TH\x10\x01\x12\t\n\x05MOUNT\x10\x02\x12\t\n\x05BLOCK\x10\x03\x12\x07\n\
    \x03RAW\x10\x04\x1a\x0f\n\rRevocableInfo\x1a\x0c\n\nSharedInfo\"\x8e\x02\
    \n\x18TrafficControlStatistics\x12\x0e\n\x02id\x18\x01\x20\x02(\tR\x02id\
    \x12\x18\n\x07backlog\x18\x02\x20\x01(\x04R\x07backlog\x12\x14\n\x05byte\
    s\x18\x03\x20\x01(\x04R\x05bytes\x12\x14\n\x05drops\x18\x04\x20\x01(\x04\
    R\x05drops\x12\x1e\n\noverlimits\x18\x05\x20\x01(\x04R\noverlimits\x12\
    \x18\n\x07packets\x18\x06\x20\x01(\x04R\x07packets\x12\x12\n\x04qlen\x18\
    \x07\x20\x01(\x04R\x04qlen\x12\x18\n\x07ratebps\x18\x08\x20\x01(\x04R\
    \x07ratebps\x12\x18\n\x07ratepps\x18\t\x20\x01(\x04R\x07ratepps\x12\x1a\
    \n\x08requeues\x18\n\x20\x01(\x04R\x08requeues\"\x84\x05\n\x0cIpStatisti\
    cs\x12\x1e\n\nForwarding\x18\x01\x20\x01(\x03R\nForwarding\x12\x1e\n\nDe\
    faultTTL\x18\x02\x20\x01(\x03R\nDefaultTTL\x12\x1e\n\nInReceives\x18\x03\
    \x20\x01(\x03R\nInReceives\x12\x20\n\x0bInHdrErrors\x18\x04\x20\x01(\x03\
    R\x0bInHdrErrors\x12\"\n\x0cInAddrErrors\x18\x05\x20\x01(\x03R\x0cInAddr\
    Errors\x12$\n\rForwDatagrams\x18\x06\x20\x01(\x03R\rForwDatagrams\x12(\n\
    \x0fInUnknownProtos\x18\x07\x20\x01(\x03R\x0fInUnknownProtos\x12\x1e\n\n\
    InDiscards\x18\x08\x20\x01(\x03R\nInDiscards\x12\x1e\n\nInDelivers\x18\t\
    \x20\x01(\x03R\nInDelivers\x12\x20\n\x0bOutRequests\x18\n\x20\x01(\x03R\
    \x0bOutRequests\x12\x20\n\x0bOutDiscards\x18\x0b\x20\x01(\x03R\x0bOutDis\
    cards\x12\x20\n\x0bOutNoRoutes\x18\x0c\x20\x01(\x03R\x0bOutNoRoutes\x12\
    \"\n\x0cReasmTimeout\x18\r\x20\x01(\x03R\x0cReasmTimeout\x12\x1e\n\nReas\
    mReqds\x18\x0e\x20\x01(\x03R\nReasmReqds\x12\x1a\n\x08ReasmOKs\x18\x0f\
    \x20\x01(\x03R\x08ReasmOKs\x12\x1e\n\nReasmFails\x18\x10\x20\x01(\x03R\n\
    ReasmFails\x12\x18\n\x07FragOKs\x18\x11\x20\x01(\x03R\x07FragOKs\x12\x1c\
    \n\tFragFails\x18\x12\x20\x01(\x03R\tFragFails\x12\x20\n\x0bFragCreates\
    \x18\x13\x20\x01(\x03R\x0bFragCreates\"\xbe\x07\n\x0eIcmpStatistics\x12\
    \x16\n\x06InMsgs\x18\x01\x20\x01(\x03R\x06InMsgs\x12\x1a\n\x08InErrors\
    \x18\x02\x20\x01(\x03R\x08InErrors\x12\"\n\x0cInCsumErrors\x18\x03\x20\
    \x01(\x03R\x0cInCsumErrors\x12&\n\x0eInDestUnreachs\x18\x04\x20\x01(\x03\
    R\x0eInDestUnreachs\x12\x20\n\x0bInTimeExcds\x18\x05\x20\x01(\x03R\x0bIn\
    TimeExcds\x12\x20\n\x0bInParmProbs\x18\x06\x20\x01(\x03R\x0bInParmProbs\
    \x12\"\n\x0cInSrcQuenchs\x18\x07\x20\x01(\x03R\x0cInSrcQuenchs\x12\x20\n\
    \x0bInRedirects\x18\x08\x20\x01(\x03R\x0bInRedirects\x12\x18\n\x07InEcho\
    s\x18\t\x20\x01(\x03R\x07InEchos\x12\x1e\n\nInEchoReps\x18\n\x20\x01(\
    \x03R\nInEchoReps\x12\"\n\x0cInTimestamps\x18\x0b\x20\x01(\x03R\x0cInTim\
    estamps\x12(\n\x0fInTimestampReps\x18\x0c\x20\x01(\x03R\x0fInTimestampRe\
    ps\x12\x20\n\x0bInAddrMasks\x18\r\x20\x01(\x03R\x0bInAddrMasks\x12&\n\
    \x0eInAddrMaskReps\x18\x0e\x20\x01(\x03R\x0eInAddrMaskReps\x12\x18\n\x07\
    OutMsgs\x18\x0f\x20\x01(\x03R\x07OutMsgs\x12\x1c\n\tOutErrors\x18\x10\
    \x20\x01(\x03R\tOutErrors\x12(\n\x0fOutDestUnreachs\x18\x11\x20\x01(\x03\
    R\x0fOutDestUnreachs\x12\"\n\x0cOutTimeExcds\x18\x12\x20\x01(\x03R\x0cOu\
    tTimeExcds\x12\"\n\x0cOutParmProbs\x18\x13\x20\x01(\x03R\x0cOutParmProbs\
    \x12$\n\rOutSrcQuenchs\x18\x14\x20\x01(\x03R\rOutSrcQuenchs\x12\"\n\x0cO\
    utRedirects\x18\x15\x20\x01(\x03R\x0cOutRedirects\x12\x1a\n\x08OutEchos\
    \x18\x16\x20\x01(\x03R\x08OutEchos\x12\x20\n\x0bOutEchoReps\x18\x17\x20\
    \x01(\x03R\x0bOutEchoReps\x12$\n\rOutTimestamps\x18\x18\x20\x01(\x03R\rO\
    utTimestamps\x12*\n\x10OutTimestampReps\x18\x19\x20\x01(\x03R\x10OutTime\
    stampReps\x12\"\n\x0cOutAddrMasks\x18\x1a\x20\x01(\x03R\x0cOutAddrMasks\
    \x12(\n\x0fOutAddrMaskReps\x18\x1b\x20\x01(\x03R\x0fOutAddrMaskReps\"\
    \xd1\x03\n\rTcpStatistics\x12\"\n\x0cRtoAlgorithm\x18\x01\x20\x01(\x03R\
    \x0cRtoAlgorithm\x12\x16\n\x06RtoMin\x18\x02\x20\x01(\x03R\x06RtoMin\x12\
    \x16\n\x06RtoMax\x18\x03\x20\x01(\x03R\x06RtoMax\x12\x18\n\x07MaxConn\
    \x18\x04\x20\x01(\x03R\x07MaxConn\x12\x20\n\x0bActiveOpens\x18\x05\x20\
    \x01(\x03R\x0bActiveOpens\x12\"\n\x0cPassiveOpens\x18\x06\x20\x01(\x03R\
    \x0cPassiveOpens\x12\"\n\x0cAttemptFails\x18\x07\x20\x01(\x03R\x0cAttemp\
    tFails\x12\x20\n\x0bEstabResets\x18\x08\x20\x01(\x03R\x0bEstabResets\x12\
    \x1c\n\tCurrEstab\x18\t\x20\x01(\x03R\tCurrEstab\x12\x16\n\x06InSegs\x18\
    \n\x20\x01(\x03R\x06InSegs\x12\x18\n\x07OutSegs\x18\x0b\x20\x01(\x03R\
    \x07OutSegs\x12\x20\n\x0bRetransSegs\x18\x0c\x20\x01(\x03R\x0bRetransSeg\
    s\x12\x16\n\x06InErrs\x18\r\x20\x01(\x03R\x06InErrs\x12\x18\n\x07OutRsts\
    \x18\x0e\x20\x01(\x03R\x07OutRsts\x12\"\n\x0cInCsumErrors\x18\x0f\x20\
    \x01(\x03R\x0cInCsumErrors\"\x9b\x02\n\rUdpStatistics\x12\x20\n\x0bInDat\
    agrams\x18\x01\x20\x01(\x03R\x0bInDatagrams\x12\x18\n\x07NoPorts\x18\x02\
    \x20\x01(\x03R\x07NoPorts\x12\x1a\n\x08InErrors\x18\x03\x20\x01(\x03R\
    \x08InErrors\x12\"\n\x0cOutDatagrams\x18\x04\x20\x01(\x03R\x0cOutDatagra\
    ms\x12\"\n\x0cRcvbufErrors\x18\x05\x20\x01(\x03R\x0cRcvbufErrors\x12\"\n\
    \x0cSndbufErrors\x18\x06\x20\x01(\x03R\x0cSndbufErrors\x12\"\n\x0cInCsum\
    Errors\x18\x07\x20\x01(\x03R\x0cInCsumErrors\x12\"\n\x0cIgnoredMulti\x18\
    \x08\x20\x01(\x03R\x0cIgnoredMulti\"\xe8\x01\n\x0eSNMPStatistics\x121\n\
    \x08ip_stats\x18\x01\x20\x01(\x0b2\x16.mesos.v1.IpStatisticsR\x07ipStats\
    \x127\n\nicmp_stats\x18\x02\x20\x01(\x0b2\x18.mesos.v1.IcmpStatisticsR\t\
    icmpStats\x124\n\ttcp_stats\x18\x03\x20\x01(\x0b2\x17.mesos.v1.TcpStatis\
    ticsR\x08tcpStats\x124\n\tudp_stats\x18\x04\x20\x01(\x0b2\x17.mesos.v1.U\
    dpStatisticsR\x08udpStats\"\xd7\x01\n\x0eDiskStatistics\x12:\n\x06source\
    \x18\x01\x20\x01(\x0b2\".mesos.v1.Resource.DiskInfo.SourceR\x06source\
    \x12I\n\x0bpersistence\x18\x02\x20\x01(\x0b2'.mesos.v1.Resource.DiskInfo\
    .PersistenceR\x0bpersistence\x12\x1f\n\x0blimit_bytes\x18\x03\x20\x01(\
    \x04R\nlimitBytes\x12\x1d\n\nused_bytes\x18\x04\x20\x01(\x04R\tusedBytes\
    \"\xdf\x10\n\x12ResourceStatistics\x12\x1c\n\ttimestamp\x18\x01\x20\x02(\
    \x01R\ttimestamp\x12\x1c\n\tprocesses\x18\x1e\x20\x01(\rR\tprocesses\x12\
    \x18\n\x07threads\x18\x1f\x20\x01(\rR\x07threads\x12-\n\x13cpus_user_tim\
    e_secs\x18\x02\x20\x01(\x01R\x10cpusUserTimeSecs\x121\n\x15cpus_system_t\
    ime_secs\x18\x03\x20\x01(\x01R\x12cpusSystemTimeSecs\x12\x1d\n\ncpus_lim\
    it\x18\x04\x20\x01(\x01R\tcpusLimit\x12&\n\x0fcpus_nr_periods\x18\x07\
    \x20\x01(\rR\rcpusNrPeriods\x12*\n\x11cpus_nr_throttled\x18\x08\x20\x01(\
    \rR\x0fcpusNrThrottled\x127\n\x18cpus_throttled_time_secs\x18\t\x20\x01(\
    \x01R\x15cpusThrottledTimeSecs\x12&\n\x0fmem_total_bytes\x18$\x20\x01(\
    \x04R\rmemTotalBytes\x121\n\x15mem_total_memsw_bytes\x18%\x20\x01(\x04R\
    \x12memTotalMemswBytes\x12&\n\x0fmem_limit_bytes\x18\x06\x20\x01(\x04R\r\
    memLimitBytes\x12/\n\x14mem_soft_limit_bytes\x18&\x20\x01(\x04R\x11memSo\
    ftLimitBytes\x12$\n\x0emem_file_bytes\x18\n\x20\x01(\x04R\x0cmemFileByte\
    s\x12$\n\x0emem_anon_bytes\x18\x0b\x20\x01(\x04R\x0cmemAnonBytes\x12&\n\
    \x0fmem_cache_bytes\x18'\x20\x01(\x04R\rmemCacheBytes\x12\"\n\rmem_rss_b\
    ytes\x18\x05\x20\x01(\x04R\x0bmemRssBytes\x121\n\x15mem_mapped_file_byte\
    s\x18\x0c\x20\x01(\x04R\x12memMappedFileBytes\x12$\n\x0emem_swap_bytes\
    \x18(\x20\x01(\x04R\x0cmemSwapBytes\x122\n\x15mem_unevictable_bytes\x18)\
    \x20\x01(\x04R\x13memUnevictableBytes\x127\n\x18mem_low_pressure_counter\
    \x18\x20\x20\x01(\x04R\x15memLowPressureCounter\x12=\n\x1bmem_medium_pre\
    ssure_counter\x18!\x20\x01(\x04R\x18memMediumPressureCounter\x12A\n\x1dm\
    em_critical_pressure_counter\x18\"\x20\x01(\x04R\x1amemCriticalPressureC\
    ounter\x12(\n\x10disk_limit_bytes\x18\x1a\x20\x01(\x04R\x0ediskLimitByte\
    s\x12&\n\x0fdisk_used_bytes\x18\x1b\x20\x01(\x04R\rdiskUsedBytes\x12A\n\
    \x0fdisk_statistics\x18+\x20\x03(\x0b2\x18.mesos.v1.DiskStatisticsR\x0ed\
    iskStatistics\x12P\n\x10blkio_statistics\x18,\x20\x01(\x0b2%.mesos.v1.Cg\
    roupInfo.Blkio.StatisticsR\x0fblkioStatistics\x12,\n\x04perf\x18\r\x20\
    \x01(\x0b2\x18.mesos.v1.PerfStatisticsR\x04perf\x12$\n\x0enet_rx_packets\
    \x18\x0e\x20\x01(\x04R\x0cnetRxPackets\x12\x20\n\x0cnet_rx_bytes\x18\x0f\
    \x20\x01(\x04R\nnetRxBytes\x12\"\n\rnet_rx_errors\x18\x10\x20\x01(\x04R\
    \x0bnetRxErrors\x12$\n\x0enet_rx_dropped\x18\x11\x20\x01(\x04R\x0cnetRxD\
    ropped\x12$\n\x0enet_tx_packets\x18\x12\x20\x01(\x04R\x0cnetTxPackets\
    \x12\x20\n\x0cnet_tx_bytes\x18\x13\x20\x01(\x04R\nnetTxBytes\x12\"\n\rne\
    t_tx_errors\x18\x14\x20\x01(\x04R\x0bnetTxErrors\x12$\n\x0enet_tx_droppe\
    d\x18\x15\x20\x01(\x04R\x0cnetTxDropped\x128\n\x19net_tcp_rtt_microsecs_\
    p50\x18\x16\x20\x01(\x01R\x15netTcpRttMicrosecsP50\x128\n\x19net_tcp_rtt\
    _microsecs_p90\x18\x17\x20\x01(\x01R\x15netTcpRttMicrosecsP90\x128\n\x19\
    net_tcp_rtt_microsecs_p95\x18\x18\x20\x01(\x01R\x15netTcpRttMicrosecsP95\
    \x128\n\x19net_tcp_rtt_microsecs_p99\x18\x19\x20\x01(\x01R\x15netTcpRttM\
    icrosecsP99\x12;\n\x1anet_tcp_active_connections\x18\x1c\x20\x01(\x01R\
    \x17netTcpActiveConnections\x12@\n\x1dnet_tcp_time_wait_connections\x18\
    \x1d\x20\x01(\x01R\x19netTcpTimeWaitConnections\x12g\n\x1enet_traffic_co\
    ntrol_statistics\x18#\x20\x03(\x0b2\".mesos.v1.TrafficControlStatisticsR\
    \x1bnetTrafficControlStatistics\x12H\n\x13net_snmp_statistics\x18*\x20\
    \x01(\x0b2\x18.mesos.v1.SNMPStatisticsR\x11netSnmpStatistics\"\xc5\x04\n\
    \rResourceUsage\x12>\n\texecutors\x18\x01\x20\x03(\x0b2\x20.mesos.v1.Res\
    ourceUsage.ExecutorR\texecutors\x12(\n\x05total\x18\x02\x20\x03(\x0b2\
    \x12.mesos.v1.ResourceR\x05total\x1a\xc9\x03\n\x08Executor\x12;\n\rexecu\
    tor_info\x18\x01\x20\x02(\x0b2\x16.mesos.v1.ExecutorInfoR\x0cexecutorInf\
    o\x120\n\tallocated\x18\x02\x20\x03(\x0b2\x12.mesos.v1.ResourceR\talloca\
    ted\x12<\n\nstatistics\x18\x03\x20\x01(\x0b2\x1c.mesos.v1.ResourceStatis\
    ticsR\nstatistics\x128\n\x0ccontainer_id\x18\x04\x20\x02(\x0b2\x15.mesos\
    .v1.ContainerIDR\x0bcontainerId\x12;\n\x05tasks\x18\x05\x20\x03(\x0b2%.m\
    esos.v1.ResourceUsage.Executor.TaskR\x05tasks\x1a\x98\x01\n\x04Task\x12\
    \x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x20\n\x02id\x18\x02\x20\
    \x02(\x0b2\x10.mesos.v1.TaskIDR\x02id\x120\n\tresources\x18\x03\x20\x03(\
    \x0b2\x12.mesos.v1.ResourceR\tresources\x12(\n\x06labels\x18\x04\x20\x01\
    (\x0b2\x10.mesos.v1.LabelsR\x06labels\"\xdc\x10\n\x0ePerfStatistics\x12\
    \x1c\n\ttimestamp\x18\x01\x20\x02(\x01R\ttimestamp\x12\x1a\n\x08duration\
    \x18\x02\x20\x02(\x01R\x08duration\x12\x16\n\x06cycles\x18\x03\x20\x01(\
    \x04R\x06cycles\x126\n\x17stalled_cycles_frontend\x18\x04\x20\x01(\x04R\
    \x15stalledCyclesFrontend\x124\n\x16stalled_cycles_backend\x18\x05\x20\
    \x01(\x04R\x14stalledCyclesBackend\x12\"\n\x0cinstructions\x18\x06\x20\
    \x01(\x04R\x0cinstructions\x12)\n\x10cache_references\x18\x07\x20\x01(\
    \x04R\x0fcacheReferences\x12!\n\x0ccache_misses\x18\x08\x20\x01(\x04R\
    \x0bcacheMisses\x12\x1a\n\x08branches\x18\t\x20\x01(\x04R\x08branches\
    \x12#\n\rbranch_misses\x18\n\x20\x01(\x04R\x0cbranchMisses\x12\x1d\n\nbu\
    s_cycles\x18\x0b\x20\x01(\x04R\tbusCycles\x12\x1d\n\nref_cycles\x18\x0c\
    \x20\x01(\x04R\trefCycles\x12\x1b\n\tcpu_clock\x18\r\x20\x01(\x01R\x08cp\
    uClock\x12\x1d\n\ntask_clock\x18\x0e\x20\x01(\x01R\ttaskClock\x12\x1f\n\
    \x0bpage_faults\x18\x0f\x20\x01(\x04R\npageFaults\x12!\n\x0cminor_faults\
    \x18\x10\x20\x01(\x04R\x0bminorFaults\x12!\n\x0cmajor_faults\x18\x11\x20\
    \x01(\x04R\x0bmajorFaults\x12)\n\x10context_switches\x18\x12\x20\x01(\
    \x04R\x0fcontextSwitches\x12%\n\x0ecpu_migrations\x18\x13\x20\x01(\x04R\
    \rcpuMigrations\x12)\n\x10alignment_faults\x18\x14\x20\x01(\x04R\x0falig\
    nmentFaults\x12)\n\x10emulation_faults\x18\x15\x20\x01(\x04R\x0femulatio\
    nFaults\x12&\n\x0fl1_dcache_loads\x18\x16\x20\x01(\x04R\rl1DcacheLoads\
    \x121\n\x15l1_dcache_load_misses\x18\x17\x20\x01(\x04R\x12l1DcacheLoadMi\
    sses\x12(\n\x10l1_dcache_stores\x18\x18\x20\x01(\x04R\x0el1DcacheStores\
    \x123\n\x16l1_dcache_store_misses\x18\x19\x20\x01(\x04R\x13l1DcacheStore\
    Misses\x120\n\x14l1_dcache_prefetches\x18\x1a\x20\x01(\x04R\x12l1DcacheP\
    refetches\x129\n\x19l1_dcache_prefetch_misses\x18\x1b\x20\x01(\x04R\x16l\
    1DcachePrefetchMisses\x12&\n\x0fl1_icache_loads\x18\x1c\x20\x01(\x04R\rl\
    1IcacheLoads\x121\n\x15l1_icache_load_misses\x18\x1d\x20\x01(\x04R\x12l1\
    IcacheLoadMisses\x120\n\x14l1_icache_prefetches\x18\x1e\x20\x01(\x04R\
    \x12l1IcachePrefetches\x129\n\x19l1_icache_prefetch_misses\x18\x1f\x20\
    \x01(\x04R\x16l1IcachePrefetchMisses\x12\x1b\n\tllc_loads\x18\x20\x20\
    \x01(\x04R\x08llcLoads\x12&\n\x0fllc_load_misses\x18!\x20\x01(\x04R\rllc\
    LoadMisses\x12\x1d\n\nllc_stores\x18\"\x20\x01(\x04R\tllcStores\x12(\n\
    \x10llc_store_misses\x18#\x20\x01(\x04R\x0ellcStoreMisses\x12%\n\x0ellc_\
    prefetches\x18$\x20\x01(\x04R\rllcPrefetches\x12.\n\x13llc_prefetch_miss\
    es\x18%\x20\x01(\x04R\x11llcPrefetchMisses\x12\x1d\n\ndtlb_loads\x18&\
    \x20\x01(\x04R\tdtlbLoads\x12(\n\x10dtlb_load_misses\x18'\x20\x01(\x04R\
    \x0edtlbLoadMisses\x12\x1f\n\x0bdtlb_stores\x18(\x20\x01(\x04R\ndtlbStor\
    es\x12*\n\x11dtlb_store_misses\x18)\x20\x01(\x04R\x0fdtlbStoreMisses\x12\
    '\n\x0fdtlb_prefetches\x18*\x20\x01(\x04R\x0edtlbPrefetches\x120\n\x14dt\
    lb_prefetch_misses\x18+\x20\x01(\x04R\x12dtlbPrefetchMisses\x12\x1d\n\ni\
    tlb_loads\x18,\x20\x01(\x04R\titlbLoads\x12(\n\x10itlb_load_misses\x18-\
    \x20\x01(\x04R\x0eitlbLoadMisses\x12!\n\x0cbranch_loads\x18.\x20\x01(\
    \x04R\x0bbranchLoads\x12,\n\x12branch_load_misses\x18/\x20\x01(\x04R\x10\
    branchLoadMisses\x12\x1d\n\nnode_loads\x180\x20\x01(\x04R\tnodeLoads\x12\
    (\n\x10node_load_misses\x181\x20\x01(\x04R\x0enodeLoadMisses\x12\x1f\n\
    \x0bnode_stores\x182\x20\x01(\x04R\nnodeStores\x12*\n\x11node_store_miss\
    es\x183\x20\x01(\x04R\x0fnodeStoreMisses\x12'\n\x0fnode_prefetches\x184\
    \x20\x01(\x04R\x0enodePrefetches\x120\n\x14node_prefetch_misses\x185\x20\
    \x01(\x04R\x12nodePrefetchMisses\"i\n\x07Request\x12,\n\x08agent_id\x18\
    \x01\x20\x01(\x0b2\x11.mesos.v1.AgentIDR\x07agentId\x120\n\tresources\
    \x18\x02\x20\x03(\x0b2\x12.mesos.v1.ResourceR\tresources\"\xd6\x11\n\x05\
    Offer\x12!\n\x02id\x18\x01\x20\x02(\x0b2\x11.mesos.v1.OfferIDR\x02id\x12\
    8\n\x0cframework_id\x18\x02\x20\x02(\x0b2\x15.mesos.v1.FrameworkIDR\x0bf\
    rameworkId\x12,\n\x08agent_id\x18\x03\x20\x02(\x0b2\x11.mesos.v1.AgentID\
    R\x07agentId\x12\x1a\n\x08hostname\x18\x04\x20\x02(\tR\x08hostname\x12\
    \x1f\n\x03url\x18\x08\x20\x01(\x0b2\r.mesos.v1.URLR\x03url\x12,\n\x06dom\
    ain\x18\x0b\x20\x01(\x0b2\x14.mesos.v1.DomainInfoR\x06domain\x120\n\tres\
    ources\x18\x05\x20\x03(\x0b2\x12.mesos.v1.ResourceR\tresources\x123\n\na\
    ttributes\x18\x07\x20\x03(\x0b2\x13.mesos.v1.AttributeR\nattributes\x127\
    \n\x0cexecutor_ids\x18\x06\x20\x03(\x0b2\x14.mesos.v1.ExecutorIDR\x0bexe\
    cutorIds\x12@\n\x0eunavailability\x18\t\x20\x01(\x0b2\x18.mesos.v1.Unava\
    ilabilityR\x0eunavailability\x12J\n\x0fallocation_info\x18\n\x20\x01(\
    \x0b2!.mesos.v1.Resource.AllocationInfoR\x0eallocationInfo\x1a\xa8\r\n\t\
    Operation\x122\n\x04type\x18\x01\x20\x01(\x0e2\x1e.mesos.v1.Offer.Operat\
    ion.TypeR\x04type\x12%\n\x02id\x18\x0c\x20\x01(\x0b2\x15.mesos.v1.Operat\
    ionIDR\x02id\x128\n\x06launch\x18\x02\x20\x01(\x0b2\x20.mesos.v1.Offer.O\
    peration.LaunchR\x06launch\x12H\n\x0claunch_group\x18\x07\x20\x01(\x0b2%\
    .mesos.v1.Offer.Operation.LaunchGroupR\x0blaunchGroup\x12;\n\x07reserve\
    \x18\x03\x20\x01(\x0b2!.mesos.v1.Offer.Operation.ReserveR\x07reserve\x12\
    A\n\tunreserve\x18\x04\x20\x01(\x0b2#.mesos.v1.Offer.Operation.Unreserve\
    R\tunreserve\x128\n\x06create\x18\x05\x20\x01(\x0b2\x20.mesos.v1.Offer.O\
    peration.CreateR\x06create\x12;\n\x07destroy\x18\x06\x20\x01(\x0b2!.meso\
    s.v1.Offer.Operation.DestroyR\x07destroy\x12K\n\rcreate_volume\x18\x08\
    \x20\x01(\x0b2&.mesos.v1.Offer.Operation.CreateVolumeR\x0ccreateVolume\
    \x12N\n\x0edestroy_volume\x18\t\x20\x01(\x0b2'.mesos.v1.Offer.Operation.\
    DestroyVolumeR\rdestroyVolume\x12H\n\x0ccreate_block\x18\n\x20\x01(\x0b2\
    %.mesos.v1.Offer.Operation.CreateBlockR\x0bcreateBlock\x12K\n\rdestroy_b\
    lock\x18\x0b\x20\x01(\x0b2&.mesos.v1.Offer.Operation.DestroyBlockR\x0cde\
    stroyBlock\x1a;\n\x06Launch\x121\n\ntask_infos\x18\x01\x20\x03(\x0b2\x12\
    .mesos.v1.TaskInfoR\ttaskInfos\x1ay\n\x0bLaunchGroup\x122\n\x08executor\
    \x18\x01\x20\x02(\x0b2\x16.mesos.v1.ExecutorInfoR\x08executor\x126\n\nta\
    sk_group\x18\x02\x20\x02(\x0b2\x17.mesos.v1.TaskGroupInfoR\ttaskGroup\
    \x1a;\n\x07Reserve\x120\n\tresources\x18\x01\x20\x03(\x0b2\x12.mesos.v1.\
    ResourceR\tresources\x1a=\n\tUnreserve\x120\n\tresources\x18\x01\x20\x03\
    (\x0b2\x12.mesos.v1.ResourceR\tresources\x1a6\n\x06Create\x12,\n\x07volu\
    mes\x18\x01\x20\x03(\x0b2\x12.mesos.v1.ResourceR\x07volumes\x1a7\n\x07De\
    stroy\x12,\n\x07volumes\x18\x01\x20\x03(\x0b2\x12.mesos.v1.ResourceR\x07\
    volumes\x1a\x84\x01\n\x0cCreateVolume\x12*\n\x06source\x18\x01\x20\x02(\
    \x0b2\x12.mesos.v1.ResourceR\x06source\x12H\n\x0btarget_type\x18\x02\x20\
    \x02(\x0e2'.mesos.v1.Resource.DiskInfo.Source.TypeR\ntargetType\x1a;\n\r\
    DestroyVolume\x12*\n\x06volume\x18\x01\x20\x02(\x0b2\x12.mesos.v1.Resour\
    ceR\x06volume\x1a9\n\x0bCreateBlock\x12*\n\x06source\x18\x01\x20\x02(\
    \x0b2\x12.mesos.v1.ResourceR\x06source\x1a8\n\x0cDestroyBlock\x12(\n\x05\
    block\x18\x01\x20\x02(\x0b2\x12.mesos.v1.ResourceR\x05block\"\xb2\x01\n\
    \x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06LAUNCH\x10\x01\x12\x10\n\
    \x0cLAUNCH_GROUP\x10\x06\x12\x0b\n\x07RESERVE\x10\x02\x12\r\n\tUNRESERVE\
    \x10\x03\x12\n\n\x06CREATE\x10\x04\x12\x0b\n\x07DESTROY\x10\x05\x12\x11\
    \n\rCREATE_VOLUME\x10\x07\x12\x12\n\x0eDESTROY_VOLUME\x10\x08\x12\x10\n\
    \x0cCREATE_BLOCK\x10\t\x12\x11\n\rDESTROY_BLOCK\x10\n\"\xae\x02\n\x0cInv\
    erseOffer\x12!\n\x02id\x18\x01\x20\x02(\x0b2\x11.mesos.v1.OfferIDR\x02id\
    \x12\x1f\n\x03url\x18\x02\x20\x01(\x0b2\r.mesos.v1.URLR\x03url\x128\n\
    \x0cframework_id\x18\x03\x20\x02(\x0b2\x15.mesos.v1.FrameworkIDR\x0bfram\
    eworkId\x12,\n\x08agent_id\x18\x04\x20\x01(\x0b2\x11.mesos.v1.AgentIDR\
    \x07agentId\x12@\n\x0eunavailability\x18\x05\x20\x02(\x0b2\x18.mesos.v1.\
    UnavailabilityR\x0eunavailability\x120\n\tresources\x18\x06\x20\x03(\x0b\
    2\x12.mesos.v1.ResourceR\tresources\"\xd6\x04\n\x08TaskInfo\x12\x12\n\
    \x04name\x18\x01\x20\x02(\tR\x04name\x12)\n\x07task_id\x18\x02\x20\x02(\
    \x0b2\x10.mesos.v1.TaskIDR\x06taskId\x12,\n\x08agent_id\x18\x03\x20\x02(\
    \x0b2\x11.mesos.v1.AgentIDR\x07agentId\x120\n\tresources\x18\x04\x20\x03\
    (\x0b2\x12.mesos.v1.ResourceR\tresources\x122\n\x08executor\x18\x05\x20\
    \x01(\x0b2\x16.mesos.v1.ExecutorInfoR\x08executor\x12/\n\x07command\x18\
    \x07\x20\x01(\x0b2\x15.mesos.v1.CommandInfoR\x07command\x125\n\tcontaine\
    r\x18\t\x20\x01(\x0b2\x17.mesos.v1.ContainerInfoR\tcontainer\x128\n\x0ch\
    ealth_check\x18\x08\x20\x01(\x0b2\x15.mesos.v1.HealthCheckR\x0bhealthChe\
    ck\x12)\n\x05check\x18\r\x20\x01(\x0b2\x13.mesos.v1.CheckInfoR\x05check\
    \x125\n\x0bkill_policy\x18\x0c\x20\x01(\x0b2\x14.mesos.v1.KillPolicyR\nk\
    illPolicy\x12\x12\n\x04data\x18\x06\x20\x01(\x0cR\x04data\x12(\n\x06labe\
    ls\x18\n\x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06labels\x125\n\tdiscovery\
    \x18\x0b\x20\x01(\x0b2\x17.mesos.v1.DiscoveryInfoR\tdiscovery\"9\n\rTask\
    GroupInfo\x12(\n\x05tasks\x18\x01\x20\x03(\x0b2\x12.mesos.v1.TaskInfoR\
    \x05tasks\"\x92\x05\n\x04Task\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04n\
    ame\x12)\n\x07task_id\x18\x02\x20\x02(\x0b2\x10.mesos.v1.TaskIDR\x06task\
    Id\x128\n\x0cframework_id\x18\x03\x20\x02(\x0b2\x15.mesos.v1.FrameworkID\
    R\x0bframeworkId\x125\n\x0bexecutor_id\x18\x04\x20\x01(\x0b2\x14.mesos.v\
    1.ExecutorIDR\nexecutorId\x12,\n\x08agent_id\x18\x05\x20\x02(\x0b2\x11.m\
    esos.v1.AgentIDR\x07agentId\x12)\n\x05state\x18\x06\x20\x02(\x0e2\x13.me\
    sos.v1.TaskStateR\x05state\x120\n\tresources\x18\x07\x20\x03(\x0b2\x12.m\
    esos.v1.ResourceR\tresources\x120\n\x08statuses\x18\x08\x20\x03(\x0b2\
    \x14.mesos.v1.TaskStatusR\x08statuses\x12C\n\x13status_update_state\x18\
    \t\x20\x01(\x0e2\x13.mesos.v1.TaskStateR\x11statusUpdateState\x12,\n\x12\
    status_update_uuid\x18\n\x20\x01(\x0cR\x10statusUpdateUuid\x12(\n\x06lab\
    els\x18\x0b\x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06labels\x125\n\tdiscove\
    ry\x18\x0c\x20\x01(\x0b2\x17.mesos.v1.DiscoveryInfoR\tdiscovery\x125\n\t\
    container\x18\r\x20\x01(\x0b2\x17.mesos.v1.ContainerInfoR\tcontainer\x12\
    \x12\n\x04user\x18\x0e\x20\x01(\tR\x04user\"J\n\x16TaskResourceLimitatio\
    n\x120\n\tresources\x18\x01\x20\x03(\x0b2\x12.mesos.v1.ResourceR\tresour\
    ces\"\x1c\n\x04UUID\x12\x14\n\x05value\x18\x01\x20\x02(\x0cR\x05value\"\
    \xbd\x02\n\tOperation\x128\n\x0cframework_id\x18\x01\x20\x01(\x0b2\x15.m\
    esos.v1.FrameworkIDR\x0bframeworkId\x12,\n\x08agent_id\x18\x02\x20\x01(\
    \x0b2\x11.mesos.v1.AgentIDR\x07agentId\x12-\n\x04info\x18\x03\x20\x02(\
    \x0b2\x19.mesos.v1.Offer.OperationR\x04info\x12>\n\rlatest_status\x18\
    \x04\x20\x02(\x0b2\x19.mesos.v1.OperationStatusR\x0clatestStatus\x125\n\
    \x08statuses\x18\x05\x20\x03(\x0b2\x19.mesos.v1.OperationStatusR\x08stat\
    uses\x12\"\n\x04uuid\x18\x06\x20\x02(\x0b2\x0e.mesos.v1.UUIDR\x04uuid\"\
    \xfe\x01\n\x0fOperationStatus\x128\n\x0coperation_id\x18\x01\x20\x01(\
    \x0b2\x15.mesos.v1.OperationIDR\x0boperationId\x12.\n\x05state\x18\x02\
    \x20\x02(\x0e2\x18.mesos.v1.OperationStateR\x05state\x12\x18\n\x07messag\
    e\x18\x03\x20\x01(\tR\x07message\x12C\n\x13converted_resources\x18\x04\
    \x20\x03(\x0b2\x12.mesos.v1.ResourceR\x12convertedResources\x12\"\n\x04u\
    uid\x18\x05\x20\x01(\x0b2\x0e.mesos.v1.UUIDR\x04uuid\"\xd7\x02\n\x0fChec\
    kStatusInfo\x12,\n\x04type\x18\x01\x20\x01(\x0e2\x18.mesos.v1.CheckInfo.\
    TypeR\x04type\x12;\n\x07command\x18\x02\x20\x01(\x0b2!.mesos.v1.CheckSta\
    tusInfo.CommandR\x07command\x122\n\x04http\x18\x03\x20\x01(\x0b2\x1e.mes\
    os.v1.CheckStatusInfo.HttpR\x04http\x12/\n\x03tcp\x18\x04\x20\x01(\x0b2\
    \x1d.mesos.v1.CheckStatusInfo.TcpR\x03tcp\x1a&\n\x07Command\x12\x1b\n\te\
    xit_code\x18\x01\x20\x01(\x05R\x08exitCode\x1a'\n\x04Http\x12\x1f\n\x0bs\
    tatus_code\x18\x01\x20\x01(\rR\nstatusCode\x1a#\n\x03Tcp\x12\x1c\n\tsucc\
    eeded\x18\x01\x20\x01(\x08R\tsucceeded\"\xe5\x0e\n\nTaskStatus\x12)\n\
    \x07task_id\x18\x01\x20\x02(\x0b2\x10.mesos.v1.TaskIDR\x06taskId\x12)\n\
    \x05state\x18\x02\x20\x02(\x0e2\x13.mesos.v1.TaskStateR\x05state\x12\x18\
    \n\x07message\x18\x04\x20\x01(\tR\x07message\x123\n\x06source\x18\t\x20\
    \x01(\x0e2\x1b.mesos.v1.TaskStatus.SourceR\x06source\x123\n\x06reason\
    \x18\n\x20\x01(\x0e2\x1b.mesos.v1.TaskStatus.ReasonR\x06reason\x12\x12\n\
    \x04data\x18\x03\x20\x01(\x0cR\x04data\x12,\n\x08agent_id\x18\x05\x20\
    \x01(\x0b2\x11.mesos.v1.AgentIDR\x07agentId\x125\n\x0bexecutor_id\x18\
    \x07\x20\x01(\x0b2\x14.mesos.v1.ExecutorIDR\nexecutorId\x12\x1c\n\ttimes\
    tamp\x18\x06\x20\x01(\x01R\ttimestamp\x12\x12\n\x04uuid\x18\x0b\x20\x01(\
    \x0cR\x04uuid\x12\x18\n\x07healthy\x18\x08\x20\x01(\x08R\x07healthy\x12<\
    \n\x0ccheck_status\x18\x0f\x20\x01(\x0b2\x19.mesos.v1.CheckStatusInfoR\
    \x0bcheckStatus\x12(\n\x06labels\x18\x0c\x20\x01(\x0b2\x10.mesos.v1.Labe\
    lsR\x06labels\x12D\n\x10container_status\x18\r\x20\x01(\x0b2\x19.mesos.v\
    1.ContainerStatusR\x0fcontainerStatus\x12=\n\x10unreachable_time\x18\x0e\
    \x20\x01(\x0b2\x12.mesos.v1.TimeInfoR\x0funreachableTime\x12@\n\nlimitat\
    ion\x18\x10\x20\x01(\x0b2\x20.mesos.v1.TaskResourceLimitationR\nlimitati\
    on\"B\n\x06Source\x12\x11\n\rSOURCE_MASTER\x10\0\x12\x10\n\x0cSOURCE_AGE\
    NT\x10\x01\x12\x13\n\x0fSOURCE_EXECUTOR\x10\x02\"\xc4\x08\n\x06Reason\
    \x12\"\n\x1eREASON_COMMAND_EXECUTOR_FAILED\x10\0\x12\"\n\x1eREASON_CONTA\
    INER_LAUNCH_FAILED\x10\x15\x12\x1f\n\x1bREASON_CONTAINER_LIMITATION\x10\
    \x13\x12$\n\x20REASON_CONTAINER_LIMITATION_DISK\x10\x14\x12&\n\"REASON_C\
    ONTAINER_LIMITATION_MEMORY\x10\x08\x12\x1e\n\x1aREASON_CONTAINER_PREEMPT\
    ED\x10\x11\x12\"\n\x1eREASON_CONTAINER_UPDATE_FAILED\x10\x16\x12(\n$REAS\
    ON_EXECUTOR_REGISTRATION_TIMEOUT\x10\x17\x12*\n&REASON_EXECUTOR_REREGIST\
    RATION_TIMEOUT\x10\x18\x12\x1e\n\x1aREASON_EXECUTOR_TERMINATED\x10\x01\
    \x12\x20\n\x1cREASON_EXECUTOR_UNREGISTERED\x10\x02\x12\x1c\n\x18REASON_F\
    RAMEWORK_REMOVED\x10\x03\x12\x13\n\x0fREASON_GC_ERROR\x10\x04\x12\x1e\n\
    \x1aREASON_INVALID_FRAMEWORKID\x10\x05\x12\x19\n\x15REASON_INVALID_OFFER\
    S\x10\x06\x12\x20\n\x1cREASON_IO_SWITCHBOARD_EXITED\x10\x1b\x12\x1e\n\
    \x1aREASON_MASTER_DISCONNECTED\x10\x07\x12\x19\n\x15REASON_RECONCILIATIO\
    N\x10\t\x12\x1c\n\x18REASON_RESOURCES_UNKNOWN\x10\x12\x12\x1d\n\x19REASO\
    N_AGENT_DISCONNECTED\x10\n\x12\x18\n\x14REASON_AGENT_REMOVED\x10\x0b\x12\
    $\n\x20REASON_AGENT_REMOVED_BY_OPERATOR\x10\x1f\x12\x1d\n\x19REASON_AGEN\
    T_REREGISTERED\x10\x20\x12\x1a\n\x16REASON_AGENT_RESTARTED\x10\x0c\x12\
    \x18\n\x14REASON_AGENT_UNKNOWN\x10\r\x12$\n\x20REASON_TASK_KILLED_DURING\
    _LAUNCH\x10\x1e\x12$\n\x20REASON_TASK_CHECK_STATUS_UPDATED\x10\x1c\x12+\
    \n'REASON_TASK_HEALTH_CHECK_STATUS_UPDATED\x10\x1d\x12\x1d\n\x19REASON_T\
    ASK_GROUP_INVALID\x10\x19\x12\"\n\x1eREASON_TASK_GROUP_UNAUTHORIZED\x10\
    \x1a\x12\x17\n\x13REASON_TASK_INVALID\x10\x0e\x12\x1c\n\x18REASON_TASK_U\
    NAUTHORIZED\x10\x0f\x12\x17\n\x13REASON_TASK_UNKNOWN\x10\x10\"3\n\x07Fil\
    ters\x12(\n\x0erefuse_seconds\x18\x01\x20\x01(\x01:\x015R\rrefuseSeconds\
    \"\x98\x02\n\x0bEnvironment\x12<\n\tvariables\x18\x01\x20\x03(\x0b2\x1e.\
    mesos.v1.Environment.VariableR\tvariables\x1a\xca\x01\n\x08Variable\x12\
    \x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12>\n\x04type\x18\x03\x20\
    \x01(\x0e2#.mesos.v1.Environment.Variable.Type:\x05VALUER\x04type\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12(\n\x06secret\x18\x04\
    \x20\x01(\x0b2\x10.mesos.v1.SecretR\x06secret\"*\n\x04Type\x12\x0b\n\x07\
    UNKNOWN\x10\0\x12\t\n\x05VALUE\x10\x01\x12\n\n\x06SECRET\x10\x02\"3\n\tP\
    arameter\x12\x10\n\x03key\x18\x01\x20\x02(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x02(\tR\x05value\"?\n\nParameters\x121\n\tparameter\x18\x01\
    \x20\x03(\x0b2\x13.mesos.v1.ParameterR\tparameter\"B\n\nCredential\x12\
    \x1c\n\tprincipal\x18\x01\x20\x02(\tR\tprincipal\x12\x16\n\x06secret\x18\
    \x02\x20\x01(\tR\x06secret\"E\n\x0bCredentials\x126\n\x0bcredentials\x18\
    \x01\x20\x03(\x0b2\x14.mesos.v1.CredentialR\x0bcredentials\"\x9a\x02\n\
    \x06Secret\x12)\n\x04type\x18\x01\x20\x01(\x0e2\x15.mesos.v1.Secret.Type\
    R\x04type\x128\n\treference\x18\x02\x20\x01(\x0b2\x1a.mesos.v1.Secret.Re\
    ferenceR\treference\x12,\n\x05value\x18\x03\x20\x01(\x0b2\x16.mesos.v1.S\
    ecret.ValueR\x05value\x1a1\n\tReference\x12\x12\n\x04name\x18\x01\x20\
    \x02(\tR\x04name\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x1a\x1b\n\
    \x05Value\x12\x12\n\x04data\x18\x01\x20\x02(\x0cR\x04data\"-\n\x04Type\
    \x12\x0b\n\x07UNKNOWN\x10\0\x12\r\n\tREFERENCE\x10\x01\x12\t\n\x05VALUE\
    \x10\x02\"W\n\tRateLimit\x12\x10\n\x03qps\x18\x01\x20\x01(\x01R\x03qps\
    \x12\x1c\n\tprincipal\x18\x02\x20\x02(\tR\tprincipal\x12\x1a\n\x08capaci\
    ty\x18\x03\x20\x01(\x04R\x08capacity\"\xab\x01\n\nRateLimits\x12+\n\x06l\
    imits\x18\x01\x20\x03(\x0b2\x13.mesos.v1.RateLimitR\x06limits\x122\n\x15\
    aggregate_default_qps\x18\x02\x20\x01(\x01R\x13aggregateDefaultQps\x12<\
    \n\x1aaggregate_default_capacity\x18\x03\x20\x01(\x04R\x18aggregateDefau\
    ltCapacity\"\xa0\x03\n\x05Image\x12(\n\x04type\x18\x01\x20\x02(\x0e2\x14\
    .mesos.v1.Image.TypeR\x04type\x12(\n\x04appc\x18\x02\x20\x01(\x0b2\x14.m\
    esos.v1.Image.AppcR\x04appc\x12.\n\x06docker\x18\x03\x20\x01(\x0b2\x16.m\
    esos.v1.Image.DockerR\x06docker\x12\x1c\n\x06cached\x18\x04\x20\x01(\x08\
    :\x04trueR\x06cached\x1aT\n\x04Appc\x12\x12\n\x04name\x18\x01\x20\x02(\t\
    R\x04name\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12(\n\x06labels\x18\
    \x03\x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06labels\x1a\x80\x01\n\x06Docke\
    r\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x128\n\ncredential\x18\
    \x02\x20\x01(\x0b2\x14.mesos.v1.CredentialR\ncredentialB\x02\x18\x01\x12\
    (\n\x06config\x18\x03\x20\x01(\x0b2\x10.mesos.v1.SecretR\x06config\"\x1c\
    \n\x04Type\x12\x08\n\x04APPC\x10\x01\x12\n\n\x06DOCKER\x10\x02\"\x86\x01\
    \n\x10MountPropagation\x123\n\x04mode\x18\x01\x20\x01(\x0e2\x1f.mesos.v1\
    .MountPropagation.ModeR\x04mode\"=\n\x04Mode\x12\x0b\n\x07UNKNOWN\x10\0\
    \x12\x15\n\x11HOST_TO_CONTAINER\x10\x01\x12\x11\n\rBIDIRECTIONAL\x10\x02\
    \"\xe4\x07\n\x06Volume\x12)\n\x04mode\x18\x03\x20\x02(\x0e2\x15.mesos.v1\
    .Volume.ModeR\x04mode\x12%\n\x0econtainer_path\x18\x01\x20\x02(\tR\rcont\
    ainerPath\x12\x1b\n\thost_path\x18\x02\x20\x01(\tR\x08hostPath\x12%\n\
    \x05image\x18\x04\x20\x01(\x0b2\x0f.mesos.v1.ImageR\x05image\x12/\n\x06s\
    ource\x18\x05\x20\x01(\x0b2\x17.mesos.v1.Volume.SourceR\x06source\x1a\
    \xfa\x05\n\x06Source\x120\n\x04type\x18\x01\x20\x01(\x0e2\x1c.mesos.v1.V\
    olume.Source.TypeR\x04type\x12I\n\rdocker_volume\x18\x02\x20\x01(\x0b2$.\
    mesos.v1.Volume.Source.DockerVolumeR\x0cdockerVolume\x12=\n\thost_path\
    \x18\x05\x20\x01(\x0b2\x20.mesos.v1.Volume.Source.HostPathR\x08hostPath\
    \x12F\n\x0csandbox_path\x18\x03\x20\x01(\x0b2#.mesos.v1.Volume.Source.Sa\
    ndboxPathR\x0bsandboxPath\x12(\n\x06secret\x18\x04\x20\x01(\x0b2\x10.mes\
    os.v1.SecretR\x06secret\x1aw\n\x0cDockerVolume\x12\x16\n\x06driver\x18\
    \x01\x20\x01(\tR\x06driver\x12\x12\n\x04name\x18\x02\x20\x02(\tR\x04name\
    \x12;\n\x0edriver_options\x18\x03\x20\x01(\x0b2\x14.mesos.v1.ParametersR\
    \rdriverOptions\x1ag\n\x08HostPath\x12\x12\n\x04path\x18\x01\x20\x02(\tR\
    \x04path\x12G\n\x11mount_propagation\x18\x02\x20\x01(\x0b2\x1a.mesos.v1.\
    MountPropagationR\x10mountPropagation\x1a\x8a\x01\n\x0bSandboxPath\x12<\
    \n\x04type\x18\x01\x20\x01(\x0e2(.mesos.v1.Volume.Source.SandboxPath.Typ\
    eR\x04type\x12\x12\n\x04path\x18\x02\x20\x02(\tR\x04path\")\n\x04Type\
    \x12\x0b\n\x07UNKNOWN\x10\0\x12\x08\n\x04SELF\x10\x01\x12\n\n\x06PARENT\
    \x10\x02\"S\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x11\n\rDOCKER_VOLUM\
    E\x10\x01\x12\r\n\tHOST_PATH\x10\x04\x12\x10\n\x0cSANDBOX_PATH\x10\x02\
    \x12\n\n\x06SECRET\x10\x03\"\x16\n\x04Mode\x12\x06\n\x02RW\x10\x01\x12\
    \x06\n\x02RO\x10\x02\"\xec\x03\n\x0bNetworkInfo\x12B\n\x0cip_addresses\
    \x18\x05\x20\x03(\x0b2\x1f.mesos.v1.NetworkInfo.IPAddressR\x0bipAddresse\
    s\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\x12\x16\n\x06groups\x18\
    \x03\x20\x03(\tR\x06groups\x12(\n\x06labels\x18\x04\x20\x01(\x0b2\x10.me\
    sos.v1.LabelsR\x06labels\x12F\n\rport_mappings\x18\x07\x20\x03(\x0b2!.me\
    sos.v1.NetworkInfo.PortMappingR\x0cportMappings\x1al\n\tIPAddress\x12@\n\
    \x08protocol\x18\x01\x20\x01(\x0e2\x1e.mesos.v1.NetworkInfo.Protocol:\
    \x04IPv4R\x08protocol\x12\x1d\n\nip_address\x18\x02\x20\x01(\tR\tipAddre\
    ss\x1am\n\x0bPortMapping\x12\x1b\n\thost_port\x18\x01\x20\x02(\rR\x08hos\
    tPort\x12%\n\x0econtainer_port\x18\x02\x20\x02(\rR\rcontainerPort\x12\
    \x1a\n\x08protocol\x18\x03\x20\x01(\tR\x08protocol\"\x1e\n\x08Protocol\
    \x12\x08\n\x04IPv4\x10\x01\x12\x08\n\x04IPv6\x10\x02\"\xdf\x05\n\x0eCapa\
    bilityInfo\x12G\n\x0ccapabilities\x18\x01\x20\x03(\x0e2#.mesos.v1.Capabi\
    lityInfo.CapabilityR\x0ccapabilities\"\x83\x05\n\nCapability\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\n\n\x05CHOWN\x10\xe8\x07\x12\x11\n\x0cDAC_OVERRIDE\
    \x10\xe9\x07\x12\x14\n\x0fDAC_READ_SEARCH\x10\xea\x07\x12\x0b\n\x06FOWNE\
    R\x10\xeb\x07\x12\x0b\n\x06FSETID\x10\xec\x07\x12\t\n\x04KILL\x10\xed\
    \x07\x12\x0b\n\x06SETGID\x10\xee\x07\x12\x0b\n\x06SETUID\x10\xef\x07\x12\
    \x0c\n\x07SETPCAP\x10\xf0\x07\x12\x14\n\x0fLINUX_IMMUTABLE\x10\xf1\x07\
    \x12\x15\n\x10NET_BIND_SERVICE\x10\xf2\x07\x12\x12\n\rNET_BROADCAST\x10\
    \xf3\x07\x12\x0e\n\tNET_ADMIN\x10\xf4\x07\x12\x0c\n\x07NET_RAW\x10\xf5\
    \x07\x12\r\n\x08IPC_LOCK\x10\xf6\x07\x12\x0e\n\tIPC_OWNER\x10\xf7\x07\
    \x12\x0f\n\nSYS_MODULE\x10\xf8\x07\x12\x0e\n\tSYS_RAWIO\x10\xf9\x07\x12\
    \x0f\n\nSYS_CHROOT\x10\xfa\x07\x12\x0f\n\nSYS_PTRACE\x10\xfb\x07\x12\x0e\
    \n\tSYS_PACCT\x10\xfc\x07\x12\x0e\n\tSYS_ADMIN\x10\xfd\x07\x12\r\n\x08SY\
    S_BOOT\x10\xfe\x07\x12\r\n\x08SYS_NICE\x10\xff\x07\x12\x11\n\x0cSYS_RESO\
    URCE\x10\x80\x08\x12\r\n\x08SYS_TIME\x10\x81\x08\x12\x13\n\x0eSYS_TTY_CO\
    NFIG\x10\x82\x08\x12\n\n\x05MKNOD\x10\x83\x08\x12\n\n\x05LEASE\x10\x84\
    \x08\x12\x10\n\x0bAUDIT_WRITE\x10\x85\x08\x12\x12\n\rAUDIT_CONTROL\x10\
    \x86\x08\x12\x0c\n\x07SETFCAP\x10\x87\x08\x12\x11\n\x0cMAC_OVERRIDE\x10\
    \x88\x08\x12\x0e\n\tMAC_ADMIN\x10\x89\x08\x12\x0b\n\x06SYSLOG\x10\x8a\
    \x08\x12\x0f\n\nWAKE_ALARM\x10\x8b\x08\x12\x12\n\rBLOCK_SUSPEND\x10\x8c\
    \x08\x12\x0f\n\nAUDIT_READ\x10\x8d\x08\"\xa2\x02\n\tLinuxInfo\x12E\n\x0f\
    capability_info\x18\x01\x20\x01(\x0b2\x18.mesos.v1.CapabilityInfoR\x0eca\
    pabilityInfoB\x02\x18\x01\x12M\n\x15bounding_capabilities\x18\x02\x20\
    \x01(\x0b2\x18.mesos.v1.CapabilityInfoR\x14boundingCapabilities\x12O\n\
    \x16effective_capabilities\x18\x03\x20\x01(\x0b2\x18.mesos.v1.Capability\
    InfoR\x15effectiveCapabilities\x12.\n\x13share_pid_namespace\x18\x04\x20\
    \x01(\x08R\x11sharePidNamespace\"\xc5\x03\n\nRLimitInfo\x125\n\x07rlimit\
    s\x18\x01\x20\x03(\x0b2\x1b.mesos.v1.RLimitInfo.RLimitR\x07rlimits\x1a\
    \xff\x02\n\x06RLimit\x124\n\x04type\x18\x01\x20\x01(\x0e2\x20.mesos.v1.R\
    LimitInfo.RLimit.TypeR\x04type\x12\x12\n\x04hard\x18\x02\x20\x01(\x04R\
    \x04hard\x12\x12\n\x04soft\x18\x03\x20\x01(\x04R\x04soft\"\x96\x02\n\x04\
    Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07RLMT_AS\x10\x01\x12\r\n\tRL\
    MT_CORE\x10\x02\x12\x0c\n\x08RLMT_CPU\x10\x03\x12\r\n\tRLMT_DATA\x10\x04\
    \x12\x0e\n\nRLMT_FSIZE\x10\x05\x12\x0e\n\nRLMT_LOCKS\x10\x06\x12\x10\n\
    \x0cRLMT_MEMLOCK\x10\x07\x12\x11\n\rRLMT_MSGQUEUE\x10\x08\x12\r\n\tRLMT_\
    NICE\x10\t\x12\x0f\n\x0bRLMT_NOFILE\x10\n\x12\x0e\n\nRLMT_NPROC\x10\x0b\
    \x12\x0c\n\x08RLMT_RSS\x10\x0c\x12\x0f\n\x0bRLMT_RTPRIO\x10\r\x12\x0f\n\
    \x0bRLMT_RTTIME\x10\x0e\x12\x13\n\x0fRLMT_SIGPENDING\x10\x0f\x12\x0e\n\n\
    RLMT_STACK\x10\x10\"\x84\x01\n\x07TTYInfo\x12=\n\x0bwindow_size\x18\x01\
    \x20\x01(\x0b2\x1c.mesos.v1.TTYInfo.WindowSizeR\nwindowSize\x1a:\n\nWind\
    owSize\x12\x12\n\x04rows\x18\x01\x20\x02(\rR\x04rows\x12\x18\n\x07column\
    s\x18\x02\x20\x02(\rR\x07columns\"\xbf\x08\n\rContainerInfo\x120\n\x04ty\
    pe\x18\x01\x20\x02(\x0e2\x1c.mesos.v1.ContainerInfo.TypeR\x04type\x12*\n\
    \x07volumes\x18\x02\x20\x03(\x0b2\x10.mesos.v1.VolumeR\x07volumes\x12\
    \x1a\n\x08hostname\x18\x04\x20\x01(\tR\x08hostname\x12:\n\x06docker\x18\
    \x03\x20\x01(\x0b2\".mesos.v1.ContainerInfo.DockerInfoR\x06docker\x127\n\
    \x05mesos\x18\x05\x20\x01(\x0b2!.mesos.v1.ContainerInfo.MesosInfoR\x05me\
    sos\x12:\n\rnetwork_infos\x18\x07\x20\x03(\x0b2\x15.mesos.v1.NetworkInfo\
    R\x0cnetworkInfos\x122\n\nlinux_info\x18\x08\x20\x01(\x0b2\x13.mesos.v1.\
    LinuxInfoR\tlinuxInfo\x125\n\x0brlimit_info\x18\t\x20\x01(\x0b2\x14.meso\
    s.v1.RLimitInfoR\nrlimitInfo\x12,\n\x08tty_info\x18\n\x20\x01(\x0b2\x11.\
    mesos.v1.TTYInfoR\x07ttyInfo\x1a\x96\x04\n\nDockerInfo\x12\x14\n\x05imag\
    e\x18\x01\x20\x02(\tR\x05image\x12J\n\x07network\x18\x02\x20\x01(\x0e2*.\
    mesos.v1.ContainerInfo.DockerInfo.Network:\x04HOSTR\x07network\x12S\n\rp\
    ort_mappings\x18\x03\x20\x03(\x0b2..mesos.v1.ContainerInfo.DockerInfo.Po\
    rtMappingR\x0cportMappings\x12%\n\nprivileged\x18\x04\x20\x01(\x08:\x05f\
    alseR\nprivileged\x123\n\nparameters\x18\x05\x20\x03(\x0b2\x13.mesos.v1.\
    ParameterR\nparameters\x12(\n\x10force_pull_image\x18\x06\x20\x01(\x08R\
    \x0eforcePullImage\x12'\n\rvolume_driver\x18\x07\x20\x01(\tR\x0cvolumeDr\
    iverB\x02\x18\x01\x1am\n\x0bPortMapping\x12\x1b\n\thost_port\x18\x01\x20\
    \x02(\rR\x08hostPort\x12%\n\x0econtainer_port\x18\x02\x20\x02(\rR\rconta\
    inerPort\x12\x1a\n\x08protocol\x18\x03\x20\x01(\tR\x08protocol\"3\n\x07N\
    etwork\x12\x08\n\x04HOST\x10\x01\x12\n\n\x06BRIDGE\x10\x02\x12\x08\n\x04\
    NONE\x10\x03\x12\x08\n\x04USER\x10\x04\x1a2\n\tMesosInfo\x12%\n\x05image\
    \x18\x01\x20\x01(\x0b2\x0f.mesos.v1.ImageR\x05image\"\x1d\n\x04Type\x12\
    \n\n\x06DOCKER\x10\x01\x12\t\n\x05MESOS\x10\x02\"\xe1\x01\n\x0fContainer\
    Status\x128\n\x0ccontainer_id\x18\x04\x20\x01(\x0b2\x15.mesos.v1.Contain\
    erIDR\x0bcontainerId\x12:\n\rnetwork_infos\x18\x01\x20\x03(\x0b2\x15.mes\
    os.v1.NetworkInfoR\x0cnetworkInfos\x125\n\x0bcgroup_info\x18\x02\x20\x01\
    (\x0b2\x14.mesos.v1.CgroupInfoR\ncgroupInfo\x12!\n\x0cexecutor_pid\x18\
    \x03\x20\x01(\rR\x0bexecutorPid\"\xf1\t\n\nCgroupInfo\x124\n\x07net_cls\
    \x18\x01\x20\x01(\x0b2\x1b.mesos.v1.CgroupInfo.NetClsR\x06netCls\x1a\x88\
    \t\n\x05Blkio\x1aS\n\x05Value\x124\n\x02op\x18\x01\x20\x01(\x0e2$.mesos.\
    v1.CgroupInfo.Blkio.OperationR\x02op\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x04R\x05value\x1a\x8e\x04\n\x03CFQ\x1a\x86\x04\n\nStatistics\x12/\n\x06\
    device\x18\x01\x20\x01(\x0b2\x17.mesos.v1.Device.NumberR\x06device\x12\
    \x18\n\x07sectors\x18\x02\x20\x01(\x04R\x07sectors\x12\x12\n\x04time\x18\
    \x03\x20\x01(\x04R\x04time\x12A\n\x0bio_serviced\x18\x04\x20\x03(\x0b2\
    \x20.mesos.v1.CgroupInfo.Blkio.ValueR\nioServiced\x12J\n\x10io_service_b\
    ytes\x18\x05\x20\x03(\x0b2\x20.mesos.v1.CgroupInfo.Blkio.ValueR\x0eioSer\
    viceBytes\x12H\n\x0fio_service_time\x18\x06\x20\x03(\x0b2\x20.mesos.v1.C\
    groupInfo.Blkio.ValueR\rioServiceTime\x12B\n\x0cio_wait_time\x18\x07\x20\
    \x03(\x0b2\x20.mesos.v1.CgroupInfo.Blkio.ValueR\nioWaitTime\x12=\n\tio_m\
    erged\x18\x08\x20\x03(\x0b2\x20.mesos.v1.CgroupInfo.Blkio.ValueR\x08ioMe\
    rged\x12=\n\tio_queued\x18\t\x20\x03(\x0b2\x20.mesos.v1.CgroupInfo.Blkio\
    .ValueR\x08ioQueued\x1a\xdb\x01\n\nThrottling\x1a\xcc\x01\n\nStatistics\
    \x12/\n\x06device\x18\x01\x20\x01(\x0b2\x17.mesos.v1.Device.NumberR\x06d\
    evice\x12A\n\x0bio_serviced\x18\x02\x20\x03(\x0b2\x20.mesos.v1.CgroupInf\
    o.Blkio.ValueR\nioServiced\x12J\n\x10io_service_bytes\x18\x03\x20\x03(\
    \x0b2\x20.mesos.v1.CgroupInfo.Blkio.ValueR\x0eioServiceBytes\x1a\xeb\x01\
    \n\nStatistics\x12;\n\x03cfq\x18\x01\x20\x03(\x0b2).mesos.v1.CgroupInfo.\
    Blkio.CFQ.StatisticsR\x03cfq\x12N\n\rcfq_recursive\x18\x02\x20\x03(\x0b2\
    ).mesos.v1.CgroupInfo.Blkio.CFQ.StatisticsR\x0ccfqRecursive\x12P\n\nthro\
    ttling\x18\x03\x20\x03(\x0b20.mesos.v1.CgroupInfo.Blkio.Throttling.Stati\
    sticsR\nthrottling\"M\n\tOperation\x12\x0b\n\x07UNKNOWN\x10\0\x12\t\n\
    \x05TOTAL\x10\x01\x12\x08\n\x04READ\x10\x02\x12\t\n\x05WRITE\x10\x03\x12\
    \x08\n\x04SYNC\x10\x04\x12\t\n\x05ASYNC\x10\x05\x1a\"\n\x06NetCls\x12\
    \x18\n\x07classid\x18\x01\x20\x01(\rR\x07classid\"1\n\x06Labels\x12'\n\
    \x06labels\x18\x01\x20\x03(\x0b2\x0f.mesos.v1.LabelR\x06labels\"/\n\x05L\
    abel\x12\x10\n\x03key\x18\x01\x20\x02(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\"\xbc\x01\n\x04Port\x12\x16\n\x06number\x18\
    \x01\x20\x02(\rR\x06number\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x12\x1a\n\x08protocol\x18\x03\x20\x01(\tR\x08protocol\x12B\n\nvisibilit\
    y\x18\x04\x20\x01(\x0e2\".mesos.v1.DiscoveryInfo.VisibilityR\nvisibility\
    \x12(\n\x06labels\x18\x05\x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06labels\"\
    -\n\x05Ports\x12$\n\x05ports\x18\x01\x20\x03(\x0b2\x0e.mesos.v1.PortR\
    \x05ports\"\xc8\x02\n\rDiscoveryInfo\x12B\n\nvisibility\x18\x01\x20\x02(\
    \x0e2\".mesos.v1.DiscoveryInfo.VisibilityR\nvisibility\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0benvironment\x18\x03\x20\x01(\t\
    R\x0benvironment\x12\x1a\n\x08location\x18\x04\x20\x01(\tR\x08location\
    \x12\x18\n\x07version\x18\x05\x20\x01(\tR\x07version\x12%\n\x05ports\x18\
    \x06\x20\x01(\x0b2\x0f.mesos.v1.PortsR\x05ports\x12(\n\x06labels\x18\x07\
    \x20\x01(\x0b2\x10.mesos.v1.LabelsR\x06labels\"6\n\nVisibility\x12\r\n\t\
    FRAMEWORK\x10\0\x12\x0b\n\x07CLUSTER\x10\x01\x12\x0c\n\x08EXTERNAL\x10\
    \x02\"8\n\nWeightInfo\x12\x16\n\x06weight\x18\x01\x20\x02(\x01R\x06weigh\
    t\x12\x12\n\x04role\x18\x02\x20\x01(\tR\x04role\"\xd5\x01\n\x0bVersionIn\
    fo\x12\x18\n\x07version\x18\x01\x20\x02(\tR\x07version\x12\x1d\n\nbuild_\
    date\x18\x02\x20\x01(\tR\tbuildDate\x12\x1d\n\nbuild_time\x18\x03\x20\
    \x01(\x01R\tbuildTime\x12\x1d\n\nbuild_user\x18\x04\x20\x01(\tR\tbuildUs\
    er\x12\x17\n\x07git_sha\x18\x05\x20\x01(\tR\x06gitSha\x12\x1d\n\ngit_bra\
    nch\x18\x06\x20\x01(\tR\tgitBranch\x12\x17\n\x07git_tag\x18\x07\x20\x01(\
    \tR\x06gitTag\"0\n\x04Flag\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x9b\x01\n\x04Role\x12\
    \x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x16\n\x06weight\x18\x02\
    \x20\x02(\x01R\x06weight\x125\n\nframeworks\x18\x03\x20\x03(\x0b2\x15.me\
    sos.v1.FrameworkIDR\nframeworks\x120\n\tresources\x18\x04\x20\x03(\x0b2\
    \x12.mesos.v1.ResourceR\tresources\"2\n\x06Metric\x12\x12\n\x04name\x18\
    \x01\x20\x02(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05val\
    ue\"\xaa\x01\n\x08FileInfo\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\
    \x12\x14\n\x05nlink\x18\x02\x20\x01(\x05R\x05nlink\x12\x12\n\x04size\x18\
    \x03\x20\x01(\x04R\x04size\x12(\n\x05mtime\x18\x04\x20\x01(\x0b2\x12.mes\
    os.v1.TimeInfoR\x05mtime\x12\x12\n\x04mode\x18\x05\x20\x01(\rR\x04mode\
    \x12\x10\n\x03uid\x18\x06\x20\x01(\tR\x03uid\x12\x10\n\x03gid\x18\x07\
    \x20\x01(\tR\x03gid\"\x9d\x01\n\x06Device\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\x12/\n\x06number\x18\x02\x20\x01(\x0b2\x17.mesos.v1.Dev\
    ice.NumberR\x06number\x1aN\n\x06Number\x12!\n\x0cmajor_number\x18\x01\
    \x20\x02(\x04R\x0bmajorNumber\x12!\n\x0cminor_number\x18\x02\x20\x02(\
    \x04R\x0bminorNumber\"\xb9\x01\n\x0cDeviceAccess\x12(\n\x06device\x18\
    \x01\x20\x02(\x0b2\x10.mesos.v1.DeviceR\x06device\x125\n\x06access\x18\
    \x02\x20\x02(\x0b2\x1d.mesos.v1.DeviceAccess.AccessR\x06access\x1aH\n\
    \x06Access\x12\x12\n\x04read\x18\x01\x20\x01(\x08R\x04read\x12\x14\n\x05\
    write\x18\x02\x20\x01(\x08R\x05write\x12\x14\n\x05mknod\x18\x03\x20\x01(\
    \x08R\x05mknod\"R\n\x0fDeviceWhitelist\x12?\n\x0fallowed_devices\x18\x01\
    \x20\x03(\x0b2\x16.mesos.v1.DeviceAccessR\x0eallowedDevices*\\\n\x06Stat\
    us\x12\x16\n\x12DRIVER_NOT_STARTED\x10\x01\x12\x12\n\x0eDRIVER_RUNNING\
    \x10\x02\x12\x12\n\x0eDRIVER_ABORTED\x10\x03\x12\x12\n\x0eDRIVER_STOPPED\
    \x10\x04*\x8c\x02\n\tTaskState\x12\x10\n\x0cTASK_STAGING\x10\x06\x12\x11\
    \n\rTASK_STARTING\x10\0\x12\x10\n\x0cTASK_RUNNING\x10\x01\x12\x10\n\x0cT\
    ASK_KILLING\x10\x08\x12\x11\n\rTASK_FINISHED\x10\x02\x12\x0f\n\x0bTASK_F\
    AILED\x10\x03\x12\x0f\n\x0bTASK_KILLED\x10\x04\x12\x0e\n\nTASK_ERROR\x10\
    \x07\x12\r\n\tTASK_LOST\x10\x05\x12\x10\n\x0cTASK_DROPPED\x10\t\x12\x14\
    \n\x10TASK_UNREACHABLE\x10\n\x12\r\n\tTASK_GONE\x10\x0b\x12\x19\n\x15TAS\
    K_GONE_BY_OPERATOR\x10\x0c\x12\x10\n\x0cTASK_UNKNOWN\x10\r*\x9c\x01\n\
    \x0eOperationState\x12\x19\n\x15OPERATION_UNSUPPORTED\x10\0\x12\x15\n\
    \x11OPERATION_PENDING\x10\x01\x12\x16\n\x12OPERATION_FINISHED\x10\x02\
    \x12\x14\n\x10OPERATION_FAILED\x10\x03\x12\x13\n\x0fOPERATION_ERROR\x10\
    \x04\x12\x15\n\x11OPERATION_DROPPED\x10\x05B\x1d\n\x13org.apache.mesos.v\
    1B\x06ProtosJ\xa0\x90\t\n\x07\x12\x05\x10\0\x8d\x1b\x01\n\x8c\x06\n\x01\
    \x0c\x12\x03\x10\0\x122\x81\x06\x20Licensed\x20to\x20the\x20Apache\x20So\
    ftware\x20Foundation\x20(ASF)\x20under\x20one\n\x20or\x20more\x20contrib\
    utor\x20license\x20agreements.\x20\x20See\x20the\x20NOTICE\x20file\n\x20\
    distributed\x20with\x20this\x20work\x20for\x20additional\x20information\
    \n\x20regarding\x20copyright\x20ownership.\x20\x20The\x20ASF\x20licenses\
    \x20this\x20file\n\x20to\x20you\x20under\x20the\x20Apache\x20License,\
    \x20Version\x202.0\x20(the\n\x20\"License\");\x20you\x20may\x20not\x20us\
    e\x20this\x20file\x20except\x20in\x20compliance\n\x20with\x20the\x20Lice\
    nse.\x20\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\
    \n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x12\x08\
    \x10\n\x08\n\x01\x08\x12\x03\x14\0,\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\
    \x14\0,\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x14\x07\x13\n\r\n\x06\x08\
    \xe7\x07\0\x02\0\x12\x03\x14\x07\x13\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\
    \x12\x03\x14\x07\x13\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x14\x16+\n\
    \x08\n\x01\x08\x12\x03\x15\0'\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x15\0'\
    \n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\x03\x15\x07\x1b\n\r\n\x06\x08\xe7\
    \x07\x01\x02\0\x12\x03\x15\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\
    \x12\x03\x15\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x15\x1e&\np\
    \n\x02\x05\0\x12\x04\x1c\0!\x01\x1ad*\n\x20Status\x20is\x20used\x20to\
    \x20indicate\x20the\x20state\x20of\x20the\x20scheduler\x20and\x20executo\
    r\n\x20driver\x20after\x20function\x20calls.\n\n\n\n\x03\x05\0\x01\x12\
    \x03\x1c\x05\x0b\n\x0b\n\x04\x05\0\x02\0\x12\x03\x1d\x02\x19\n\x0c\n\x05\
    \x05\0\x02\0\x01\x12\x03\x1d\x02\x14\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\
    \x1d\x17\x18\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x1e\x02\x15\n\x0c\n\x05\
    \x05\0\x02\x01\x01\x12\x03\x1e\x02\x10\n\x0c\n\x05\x05\0\x02\x01\x02\x12\
    \x03\x1e\x13\x14\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x1f\x02\x15\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x1f\x02\x10\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x1f\x13\x14\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x20\x02\x15\n\x0c\
    \n\x05\x05\0\x02\x03\x01\x12\x03\x20\x02\x10\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03\x20\x13\x14\n\x87\x01\n\x02\x04\0\x12\x04(\0*\x01\x1a{*\n\
    \x20A\x20unique\x20ID\x20assigned\x20to\x20a\x20framework.\x20A\x20frame\
    work\x20can\x20reuse\x20this\x20ID\n\x20in\x20order\x20to\x20do\x20failo\
    ver\x20(see\x20MesosSchedulerDriver).\n\n\n\n\x03\x04\0\x01\x12\x03(\x08\
    \x13\n\x0b\n\x04\x04\0\x02\0\x12\x03)\x02\x1c\n\x0c\n\x05\x04\0\x02\0\
    \x04\x12\x03)\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03)\x0b\x11\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03)\x12\x17\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03)\x1a\x1b\n1\n\x02\x04\x01\x12\x040\02\x01\x1a%*\n\x20A\x20unique\
    \x20ID\x20assigned\x20to\x20an\x20offer.\n\n\n\n\x03\x04\x01\x01\x12\x03\
    0\x08\x0f\n\x0b\n\x04\x04\x01\x02\0\x12\x031\x02\x1c\n\x0c\n\x05\x04\x01\
    \x02\0\x04\x12\x031\x02\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x031\x0b\x11\
    \n\x0c\n\x05\x04\x01\x02\0\x01\x12\x031\x12\x17\n\x0c\n\x05\x04\x01\x02\
    \0\x03\x12\x031\x1a\x1b\n\xd3\x01\n\x02\x04\x02\x12\x04:\0<\x01\x1a\xc6\
    \x01*\n\x20A\x20unique\x20ID\x20assigned\x20to\x20an\x20agent.\x20Curren\
    tly,\x20an\x20agent\x20gets\x20a\x20new\x20ID\n\x20whenever\x20it\x20(re\
    )registers\x20with\x20Mesos.\x20Framework\x20writers\x20shouldn't\n\x20a\
    ssume\x20any\x20binding\x20between\x20an\x20agent\x20ID\x20and\x20and\
    \x20a\x20hostname.\n\n\n\n\x03\x04\x02\x01\x12\x03:\x08\x0f\n\x0b\n\x04\
    \x04\x02\x02\0\x12\x03;\x02\x1c\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03;\
    \x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03;\x0b\x11\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x03;\x12\x17\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03;\
    \x1a\x1b\n\xc8\x02\n\x02\x04\x03\x12\x04F\0H\x01\x1a\xbb\x02*\n\x20A\x20\
    framework-generated\x20ID\x20to\x20distinguish\x20a\x20task.\x20The\x20I\
    D\x20must\x20remain\n\x20unique\x20while\x20the\x20task\x20is\x20active.\
    \x20A\x20framework\x20can\x20reuse\x20an\x20ID\x20_only_\n\x20if\x20the\
    \x20previous\x20task\x20with\x20the\x20same\x20ID\x20has\x20reached\x20a\
    \x20terminal\x20state\n\x20(e.g.,\x20TASK_FINISHED,\x20TASK_KILLED,\x20e\
    tc.).\x20However,\x20reusing\x20task\x20IDs\n\x20is\x20strongly\x20disco\
    uraged\x20(MESOS-2198).\n\n\n\n\x03\x04\x03\x01\x12\x03F\x08\x0e\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x03G\x02\x1c\n\x0c\n\x05\x04\x03\x02\0\x04\x12\
    \x03G\x02\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03G\x0b\x11\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03G\x12\x17\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x03G\x1a\x1b\n\xc3\x01\n\x02\x04\x04\x12\x04P\0R\x01\x1a\xb6\x01*\n\x20\
    A\x20framework-generated\x20ID\x20to\x20distinguish\x20an\x20executor.\
    \x20Only\x20one\n\x20executor\x20with\x20the\x20same\x20ID\x20can\x20be\
    \x20active\x20on\x20the\x20same\x20agent\x20at\x20a\n\x20time.\x20Howeve\
    r,\x20reusing\x20executor\x20IDs\x20is\x20discouraged.\n\n\n\n\x03\x04\
    \x04\x01\x12\x03P\x08\x12\n\x0b\n\x04\x04\x04\x02\0\x12\x03Q\x02\x1c\n\
    \x0c\n\x05\x04\x04\x02\0\x04\x12\x03Q\x02\n\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03Q\x0b\x11\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03Q\x12\x17\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03Q\x1a\x1b\n\x84\x02\n\x02\x04\x05\
    \x12\x04[\0^\x01\x1a\xf7\x01*\n\x20ID\x20used\x20to\x20uniquely\x20ident\
    ify\x20a\x20container.\x20If\x20the\x20`parent`\x20is\x20not\n\x20specif\
    ied,\x20the\x20ID\x20is\x20a\x20UUID\x20generated\x20by\x20the\x20agent\
    \x20to\x20uniquely\n\x20identify\x20the\x20container\x20of\x20an\x20exec\
    utor\x20run.\x20If\x20the\x20`parent`\x20field\x20is\n\x20specified,\x20\
    it\x20represents\x20a\x20nested\x20container.\n\n\n\n\x03\x04\x05\x01\
    \x12\x03[\x08\x13\n\x0b\n\x04\x04\x05\x02\0\x12\x03\\\x02\x1c\n\x0c\n\
    \x05\x04\x05\x02\0\x04\x12\x03\\\x02\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\
    \x03\\\x0b\x11\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03\\\x12\x17\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03\\\x1a\x1b\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x03]\x02\"\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03]\x02\n\n\x0c\n\x05\
    \x04\x05\x02\x01\x06\x12\x03]\x0b\x16\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03]\x17\x1d\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03]\x20!\n\x91\
    \x01\n\x02\x04\x06\x12\x04e\0g\x01\x1a\x84\x01*\n\x20A\x20unique\x20ID\
    \x20assigned\x20to\x20a\x20resource\x20provider.\x20Currently,\x20a\x20r\
    esource\n\x20provider\x20gets\x20a\x20new\x20ID\x20whenever\x20it\x20(re\
    )registers\x20with\x20Mesos.\n\n\n\n\x03\x04\x06\x01\x12\x03e\x08\x1a\n\
    \x0b\n\x04\x04\x06\x02\0\x12\x03f\x02\x1c\n\x0c\n\x05\x04\x06\x02\0\x04\
    \x12\x03f\x02\n\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03f\x0b\x11\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03f\x12\x17\n\x0c\n\x05\x04\x06\x02\0\x03\
    \x12\x03f\x1a\x1b\nr\n\x02\x04\x07\x12\x04n\0p\x01\x1af*\n\x20A\x20frame\
    work-generated\x20ID\x20to\x20distinguish\x20an\x20operation.\x20The\x20\
    ID\n\x20must\x20be\x20unique\x20within\x20the\x20framework.\n\n\n\n\x03\
    \x04\x07\x01\x12\x03n\x08\x13\n\x0b\n\x04\x04\x07\x02\0\x12\x03o\x02\x1c\
    \n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\x07\x02\0\
    \x05\x12\x03o\x0b\x11\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03o\x12\x17\n\
    \x0c\n\x05\x04\x07\x02\0\x03\x12\x03o\x1a\x1b\n@\n\x02\x04\x08\x12\x04v\
    \0x\x01\x1a4*\n\x20Represents\x20time\x20since\x20the\x20epoch,\x20in\
    \x20nanoseconds.\n\n\n\n\x03\x04\x08\x01\x12\x03v\x08\x10\n\x0b\n\x04\
    \x04\x08\x02\0\x12\x03w\x02!\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03w\x02\
    \n\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03w\x0b\x10\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x03w\x11\x1c\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03w\x1f\
    \x20\n4\n\x02\x04\t\x12\x05~\0\x80\x01\x01\x1a'*\n\x20Represents\x20dura\
    tion\x20in\x20nanoseconds.\n\n\n\n\x03\x04\t\x01\x12\x03~\x08\x14\n\x0b\
    \n\x04\x04\t\x02\0\x12\x03\x7f\x02!\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03\
    \x7f\x02\n\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03\x7f\x0b\x10\n\x0c\n\x05\
    \x04\t\x02\0\x01\x12\x03\x7f\x11\x1c\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03\
    \x7f\x1f\x20\nK\n\x02\x04\n\x12\x06\x88\x01\0\x8e\x01\x01\x1a=*\n\x20A\
    \x20network\x20address.\n\n\x20TODO(bmahler):\x20Use\x20this\x20more\x20\
    widely.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x88\x01\x08\x0f\n<\n\x04\x04\n\
    \x02\0\x12\x04\x8a\x01\x02\x1f\x1a.\x20May\x20contain\x20a\x20hostname,\
    \x20IP\x20address,\x20or\x20both.\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\
    \x8a\x01\x02\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x8a\x01\x0b\x11\n\r\n\
    \x05\x04\n\x02\0\x01\x12\x04\x8a\x01\x12\x1a\n\r\n\x05\x04\n\x02\0\x03\
    \x12\x04\x8a\x01\x1d\x1e\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x8b\x01\x02\
    \x19\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x8b\x01\x02\n\n\r\n\x05\x04\n\
    \x02\x01\x05\x12\x04\x8b\x01\x0b\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\
    \x8b\x01\x12\x14\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x8b\x01\x17\x18\n\
    \x0c\n\x04\x04\n\x02\x02\x12\x04\x8d\x01\x02\x1a\n\r\n\x05\x04\n\x02\x02\
    \x04\x12\x04\x8d\x01\x02\n\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\x8d\x01\
    \x0b\x10\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x8d\x01\x11\x15\n\r\n\x05\
    \x04\n\x02\x02\x03\x12\x04\x8d\x01\x18\x19\n#\n\x02\x04\x0b\x12\x06\x94\
    \x01\0\x9a\x01\x01\x1a\x15*\n\x20Represents\x20a\x20URL.\n\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\x94\x01\x08\x0b\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\
    \x95\x01\x02\x1d\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x95\x01\x02\n\n\r\n\
    \x05\x04\x0b\x02\0\x05\x12\x04\x95\x01\x0b\x11\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\x95\x01\x12\x18\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x95\x01\
    \x1b\x1c\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x96\x01\x02\x1f\n\r\n\x05\
    \x04\x0b\x02\x01\x04\x12\x04\x96\x01\x02\n\n\r\n\x05\x04\x0b\x02\x01\x06\
    \x12\x04\x96\x01\x0b\x12\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x96\x01\
    \x13\x1a\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x96\x01\x1d\x1e\n\x0c\n\
    \x04\x04\x0b\x02\x02\x12\x04\x97\x01\x02\x1b\n\r\n\x05\x04\x0b\x02\x02\
    \x04\x12\x04\x97\x01\x02\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x97\x01\
    \x0b\x11\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x97\x01\x12\x16\n\r\n\x05\
    \x04\x0b\x02\x02\x03\x12\x04\x97\x01\x19\x1a\n\x0c\n\x04\x04\x0b\x02\x03\
    \x12\x04\x98\x01\x02\x1f\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\x98\x01\
    \x02\n\n\r\n\x05\x04\x0b\x02\x03\x06\x12\x04\x98\x01\x0b\x14\n\r\n\x05\
    \x04\x0b\x02\x03\x01\x12\x04\x98\x01\x15\x1a\n\r\n\x05\x04\x0b\x02\x03\
    \x03\x12\x04\x98\x01\x1d\x1e\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\x99\x01\
    \x02\x1f\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\x99\x01\x02\n\n\r\n\x05\
    \x04\x0b\x02\x04\x05\x12\x04\x99\x01\x0b\x11\n\r\n\x05\x04\x0b\x02\x04\
    \x01\x12\x04\x99\x01\x12\x1a\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x99\
    \x01\x1d\x1e\n\xc2\x01\n\x02\x04\x0c\x12\x06\xa2\x01\0\xab\x01\x01\x1a\
    \xb3\x01*\n\x20Represents\x20an\x20interval,\x20from\x20a\x20given\x20st\
    art\x20time\x20over\x20a\x20given\x20duration.\n\x20This\x20interval\x20\
    pertains\x20to\x20an\x20unavailability\x20event,\x20such\x20as\x20mainte\
    nance,\n\x20and\x20is\x20not\x20a\x20generic\x20interval.\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\xa2\x01\x08\x16\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\
    \xa3\x01\x02\x1e\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xa3\x01\x02\n\n\r\n\
    \x05\x04\x0c\x02\0\x06\x12\x04\xa3\x01\x0b\x13\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xa3\x01\x14\x19\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa3\x01\
    \x1c\x1d\n\x88\x01\n\x04\x04\x0c\x02\x01\x12\x04\xa7\x01\x02%\x1az\x20Wh\
    en\x20added\x20to\x20`start`,\x20this\x20represents\x20the\x20end\x20of\
    \x20the\x20interval.\n\x20If\x20unspecified,\x20the\x20duration\x20is\
    \x20assumed\x20to\x20be\x20infinite.\n\n\r\n\x05\x04\x0c\x02\x01\x04\x12\
    \x04\xa7\x01\x02\n\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\xa7\x01\x0b\x17\
    \n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xa7\x01\x18\x20\n\r\n\x05\x04\x0c\
    \x02\x01\x03\x12\x04\xa7\x01#$\n\xff\x01\n\x02\x04\r\x12\x06\xb5\x01\0\
    \xb8\x01\x01\x1a\xf0\x01*\n\x20Represents\x20a\x20single\x20machine,\x20\
    which\x20may\x20hold\x20one\x20or\x20more\x20agents.\n\n\x20NOTE:\x20In\
    \x20order\x20to\x20match\x20an\x20agent\x20to\x20a\x20machine,\x20both\
    \x20the\x20`hostname`\x20and\n\x20`ip`\x20must\x20match\x20the\x20values\
    \x20advertised\x20by\x20the\x20agent\x20to\x20the\x20master.\n\x20Hostna\
    me\x20is\x20not\x20case-sensitive.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xb5\
    \x01\x08\x11\n\x0c\n\x04\x04\r\x02\0\x12\x04\xb6\x01\x02\x1f\n\r\n\x05\
    \x04\r\x02\0\x04\x12\x04\xb6\x01\x02\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \xb6\x01\x0b\x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xb6\x01\x12\x1a\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xb6\x01\x1d\x1e\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\xb7\x01\x02\x19\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xb7\x01\x02\
    \n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xb7\x01\x0b\x11\n\r\n\x05\x04\r\
    \x02\x01\x01\x12\x04\xb7\x01\x12\x14\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\
    \xb7\x01\x17\x18\n\x9a\x01\n\x02\x04\x0e\x12\x06\xbf\x01\0\xdb\x01\x01\
    \x1a\x8b\x01*\n\x20Holds\x20information\x20about\x20a\x20single\x20machi\
    ne,\x20its\x20`mode`,\x20and\x20any\x20other\n\x20relevant\x20informatio\
    n\x20which\x20may\x20affect\x20the\x20behavior\x20of\x20the\x20machine.\
    \n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xbf\x01\x08\x13\n\x96\x01\n\x04\x04\
    \x0e\x04\0\x12\x06\xc2\x01\x02\xd2\x01\x03\x1a\x85\x01\x20Describes\x20t\
    he\x20several\x20states\x20that\x20a\x20machine\x20can\x20be\x20in.\x20\
    \x20A\x20`Mode`\n\x20applies\x20to\x20a\x20machine\x20and\x20to\x20all\
    \x20associated\x20agents\x20on\x20the\x20machine.\n\n\r\n\x05\x04\x0e\
    \x04\0\x01\x12\x04\xc2\x01\x07\x0b\nj\n\x06\x04\x0e\x04\0\x02\0\x12\x04\
    \xc5\x01\x04\x0b\x1aZ\x20In\x20this\x20mode,\x20a\x20machine\x20is\x20be\
    having\x20normally;\n\x20offering\x20resources,\x20executing\x20tasks,\
    \x20etc.\n\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\x04\xc5\x01\x04\x06\n\
    \x0f\n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xc5\x01\t\n\n\xd5\x02\n\x06\
    \x04\x0e\x04\0\x02\x01\x12\x04\xcc\x01\x04\x11\x1a\xc4\x02\x20In\x20this\
    \x20mode,\x20all\x20agents\x20on\x20the\x20machine\x20are\x20expected\
    \x20to\x20cooperate\x20with\n\x20frameworks\x20to\x20drain\x20resources.\
    \x20\x20In\x20general,\x20draining\x20is\x20done\x20ahead\x20of\n\x20a\
    \x20pending\x20`unavailability`.\x20\x20The\x20resources\x20should\x20be\
    \x20drained\x20so\x20as\x20to\n\x20maximize\x20utilization\x20prior\x20t\
    o\x20the\x20maintenance\x20but\x20without\x20knowingly\n\x20violating\
    \x20the\x20frameworks'\x20requirements.\n\n\x0f\n\x07\x04\x0e\x04\0\x02\
    \x01\x01\x12\x04\xcc\x01\x04\x0c\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\x02\
    \x12\x04\xcc\x01\x0f\x10\n\xb6\x01\n\x06\x04\x0e\x04\0\x02\x02\x12\x04\
    \xd1\x01\x04\r\x1a\xa5\x01\x20In\x20this\x20mode,\x20a\x20machine\x20is\
    \x20not\x20running\x20any\x20tasks\x20and\x20will\x20not\x20offer\n\x20a\
    ny\x20of\x20its\x20resources.\x20\x20Agents\x20on\x20the\x20machine\x20w\
    ill\x20not\x20be\x20allowed\x20to\n\x20register\x20with\x20the\x20master\
    .\n\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x01\x12\x04\xd1\x01\x04\x08\n\x0f\
    \n\x07\x04\x0e\x04\0\x02\x02\x02\x12\x04\xd1\x01\x0b\x0c\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\xd4\x01\x02\x1c\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\
    \xd4\x01\x02\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xd4\x01\x0b\x14\n\r\n\
    \x05\x04\x0e\x02\0\x01\x12\x04\xd4\x01\x15\x17\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\xd4\x01\x1a\x1b\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xd5\x01\
    \x02\x19\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xd5\x01\x02\n\n\r\n\x05\
    \x04\x0e\x02\x01\x06\x12\x04\xd5\x01\x0b\x0f\n\r\n\x05\x04\x0e\x02\x01\
    \x01\x12\x04\xd5\x01\x10\x14\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xd5\
    \x01\x17\x18\n\xd4\x01\n\x04\x04\x0e\x02\x02\x12\x04\xda\x01\x02-\x1a\
    \xc5\x01\x20Signifies\x20that\x20the\x20machine\x20may\x20be\x20unavaila\
    ble\x20during\x20the\x20given\x20interval.\n\x20See\x20comments\x20in\
    \x20`Unavailability`\x20and\x20for\x20the\x20`unavailability`\x20fields\
    \n\x20in\x20`Offer`\x20and\x20`InverseOffer`\x20for\x20more\x20informati\
    on.\n\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xda\x01\x02\n\n\r\n\x05\x04\
    \x0e\x02\x02\x06\x12\x04\xda\x01\x0b\x19\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\xda\x01\x1a(\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xda\x01+,\n(\
    \n\x02\x04\x0f\x12\x06\xe1\x01\0\x9a\x03\x01\x1a\x1a*\n\x20Describes\x20\
    a\x20framework.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xe1\x01\x08\x15\n\xac\
    \x02\n\x04\x04\x0f\x02\0\x12\x04\xea\x01\x02\x1b\x1a\x9d\x02\x20Used\x20\
    to\x20determine\x20the\x20Unix\x20user\x20that\x20an\x20executor\x20or\
    \x20task\x20should\x20be\n\x20launched\x20as.\n\n\x20When\x20using\x20th\
    e\x20MesosSchedulerDriver,\x20if\x20the\x20field\x20is\x20set\x20to\x20a\
    n\n\x20empty\x20string,\x20it\x20will\x20automagically\x20set\x20it\x20t\
    o\x20the\x20current\x20user.\n\n\x20When\x20using\x20the\x20HTTP\x20Sche\
    duler\x20API,\x20the\x20user\x20has\x20to\x20be\x20set\n\x20explicitly.\
    \n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xea\x01\x02\n\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\xea\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \xea\x01\x12\x16\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xea\x01\x19\x1a\nH\
    \n\x04\x04\x0f\x02\x01\x12\x04\xed\x01\x02\x1b\x1a:\x20Name\x20of\x20the\
    \x20framework\x20that\x20shows\x20up\x20in\x20the\x20Mesos\x20Web\x20UI.\
    \n\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xed\x01\x02\n\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\xed\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xed\x01\x12\x16\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xed\x01\x19\
    \x1a\n\xff\x01\n\x04\x04\x0f\x02\x02\x12\x04\xf4\x01\x02\x1e\x1a\xf0\x01\
    \x20Note\x20that\x20'id'\x20is\x20only\x20available\x20after\x20a\x20fra\
    mework\x20has\n\x20registered,\x20however,\x20it\x20is\x20included\x20he\
    re\x20in\x20order\x20to\x20facilitate\n\x20scheduler\x20failover\x20(i.e\
    .,\x20if\x20it\x20is\x20set\x20then\x20the\n\x20MesosSchedulerDriver\x20\
    expects\x20the\x20scheduler\x20is\x20performing\n\x20failover).\n\n\r\n\
    \x05\x04\x0f\x02\x02\x04\x12\x04\xf4\x01\x02\n\n\r\n\x05\x04\x0f\x02\x02\
    \x06\x12\x04\xf4\x01\x0b\x16\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xf4\
    \x01\x17\x19\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xf4\x01\x1c\x1d\n\x9e\
    \x03\n\x04\x04\x0f\x02\x03\x12\x04\xfe\x01\x027\x1a\x8f\x03\x20The\x20am\
    ount\x20of\x20time\x20(in\x20seconds)\x20that\x20the\x20master\x20will\
    \x20wait\x20for\x20the\n\x20scheduler\x20to\x20failover\x20before\x20it\
    \x20tears\x20down\x20the\x20framework\x20by\n\x20killing\x20all\x20its\
    \x20tasks/executors.\x20This\x20should\x20be\x20non-zero\x20if\x20a\n\
    \x20framework\x20expects\x20to\x20reconnect\x20after\x20a\x20failure\x20\
    and\x20not\x20lose\x20its\n\x20tasks/executors.\n\n\x20NOTE:\x20To\x20av\
    oid\x20accidental\x20destruction\x20of\x20tasks,\x20production\n\x20fram\
    eworks\x20typically\x20set\x20this\x20to\x20a\x20large\x20value\x20(e.g.\
    ,\x201\x20week).\n\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\xfe\x01\x02\n\n\
    \r\n\x05\x04\x0f\x02\x03\x05\x12\x04\xfe\x01\x0b\x11\n\r\n\x05\x04\x0f\
    \x02\x03\x01\x12\x04\xfe\x01\x12\"\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\
    \xfe\x01%&\n\r\n\x05\x04\x0f\x02\x03\x08\x12\x04\xfe\x01'6\n\r\n\x05\x04\
    \x0f\x02\x03\x07\x12\x04\xfe\x0125\n\xc6\x03\n\x04\x04\x0f\x02\x04\x12\
    \x04\x87\x02\x021\x1a\xb7\x03\x20If\x20set,\x20agents\x20running\x20task\
    s\x20started\x20by\x20this\x20framework\x20will\x20write\n\x20the\x20fra\
    mework\x20pid,\x20executor\x20pids\x20and\x20status\x20updates\x20to\x20\
    disk.\x20If\n\x20the\x20agent\x20exits\x20(e.g.,\x20due\x20to\x20a\x20cr\
    ash\x20or\x20as\x20part\x20of\x20upgrading\n\x20Mesos),\x20this\x20check\
    pointed\x20data\x20allows\x20the\x20restarted\x20agent\x20to\n\x20reconn\
    ect\x20to\x20executors\x20that\x20were\x20started\x20by\x20the\x20old\
    \x20instance\x20of\n\x20the\x20agent.\x20Enabling\x20checkpointing\x20im\
    proves\x20fault\x20tolerance,\x20at\n\x20the\x20cost\x20of\x20a\x20(usua\
    lly\x20small)\x20increase\x20in\x20disk\x20I/O.\n\n\r\n\x05\x04\x0f\x02\
    \x04\x04\x12\x04\x87\x02\x02\n\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\x87\
    \x02\x0b\x0f\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\x87\x02\x10\x1a\n\r\n\
    \x05\x04\x0f\x02\x04\x03\x12\x04\x87\x02\x1d\x1e\n\r\n\x05\x04\x0f\x02\
    \x04\x08\x12\x04\x87\x02\x1f0\n\r\n\x05\x04\x0f\x02\x04\x07\x12\x04\x87\
    \x02*/\n\xa0\x03\n\x04\x04\x0f\x02\x05\x12\x04\x91\x02\x02<\x1a\x91\x03\
    \x20Roles\x20are\x20the\x20entities\x20to\x20which\x20allocations\x20are\
    \x20made.\n\x20The\x20framework\x20must\x20have\x20at\x20least\x20one\
    \x20role\x20in\x20order\x20to\n\x20be\x20offered\x20resources.\x20Note\
    \x20that\x20`role`\x20is\x20deprecated\n\x20in\x20favor\x20of\x20`roles`\
    \x20and\x20only\x20one\x20of\x20these\x20fields\x20must\n\x20be\x20used.\
    \x20Since\x20we\x20cannot\x20distinguish\x20between\x20empty\n\x20`roles\
    `\x20and\x20the\x20default\x20unset\x20`role`,\x20we\x20require\x20that\
    \n\x20frameworks\x20set\x20the\x20`MULTI_ROLE`\x20capability\x20if\n\x20\
    setting\x20the\x20`roles`\x20field.\n\n\r\n\x05\x04\x0f\x02\x05\x04\x12\
    \x04\x91\x02\x02\n\n\r\n\x05\x04\x0f\x02\x05\x05\x12\x04\x91\x02\x0b\x11\
    \n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\x91\x02\x12\x16\n\r\n\x05\x04\x0f\
    \x02\x05\x03\x12\x04\x91\x02\x19\x1a\n\r\n\x05\x04\x0f\x02\x05\x08\x12\
    \x04\x91\x02\x1b;\n\r\n\x05\x04\x0f\x02\x05\x07\x12\x04\x91\x02&)\n\x10\
    \n\x08\x04\x0f\x02\x05\x08\xe7\x07\0\x12\x04\x91\x02+:\n\x11\n\t\x04\x0f\
    \x02\x05\x08\xe7\x07\0\x02\x12\x04\x91\x02+5\n\x12\n\n\x04\x0f\x02\x05\
    \x08\xe7\x07\0\x02\0\x12\x04\x91\x02+5\n\x13\n\x0b\x04\x0f\x02\x05\x08\
    \xe7\x07\0\x02\0\x01\x12\x04\x91\x02+5\n\x11\n\t\x04\x0f\x02\x05\x08\xe7\
    \x07\0\x03\x12\x04\x91\x026:\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\x92\x02\
    \x02\x1d\n\r\n\x05\x04\x0f\x02\x06\x04\x12\x04\x92\x02\x02\n\n\r\n\x05\
    \x04\x0f\x02\x06\x05\x12\x04\x92\x02\x0b\x11\n\r\n\x05\x04\x0f\x02\x06\
    \x01\x12\x04\x92\x02\x12\x17\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\x92\
    \x02\x1a\x1c\n\xd8\x01\n\x04\x04\x0f\x02\x07\x12\x04\x98\x02\x02\x1f\x1a\
    \xc9\x01\x20Used\x20to\x20indicate\x20the\x20current\x20host\x20from\x20\
    which\x20the\x20scheduler\x20is\n\x20registered\x20in\x20the\x20Mesos\
    \x20Web\x20UI.\x20If\x20set\x20to\x20an\x20empty\x20string\x20Mesos\n\
    \x20will\x20automagically\x20set\x20it\x20to\x20the\x20current\x20hostna\
    me\x20if\x20one\x20is\n\x20available.\n\n\r\n\x05\x04\x0f\x02\x07\x04\
    \x12\x04\x98\x02\x02\n\n\r\n\x05\x04\x0f\x02\x07\x05\x12\x04\x98\x02\x0b\
    \x11\n\r\n\x05\x04\x0f\x02\x07\x01\x12\x04\x98\x02\x12\x1a\n\r\n\x05\x04\
    \x0f\x02\x07\x03\x12\x04\x98\x02\x1d\x1e\n\x90\x02\n\x04\x04\x0f\x02\x08\
    \x12\x04\x9e\x02\x02\x20\x1a\x81\x02\x20This\x20field\x20should\x20match\
    \x20the\x20credential's\x20principal\x20the\x20framework\n\x20uses\x20fo\
    r\x20authentication.\x20This\x20field\x20is\x20used\x20for\x20framework\
    \x20API\n\x20rate\x20limiting\x20and\x20dynamic\x20reservations.\x20It\
    \x20should\x20be\x20set\x20even\n\x20if\x20authentication\x20is\x20not\
    \x20enabled\x20if\x20these\x20features\x20are\x20desired.\n\n\r\n\x05\
    \x04\x0f\x02\x08\x04\x12\x04\x9e\x02\x02\n\n\r\n\x05\x04\x0f\x02\x08\x05\
    \x12\x04\x9e\x02\x0b\x11\n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\x9e\x02\
    \x12\x1b\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\x9e\x02\x1e\x1f\n\xc6\x01\
    \n\x04\x04\x0f\x02\t\x12\x04\xa3\x02\x02\x20\x1a\xb7\x01\x20This\x20fiel\
    d\x20allows\x20a\x20framework\x20to\x20advertise\x20its\x20web\x20UI,\
    \x20so\x20that\n\x20the\x20Mesos\x20web\x20UI\x20can\x20link\x20to\x20it\
    .\x20It\x20is\x20expected\x20to\x20be\x20a\x20full\x20URL,\n\x20for\x20e\
    xample\x20http://my-scheduler.example.com:8080/.\n\n\r\n\x05\x04\x0f\x02\
    \t\x04\x12\x04\xa3\x02\x02\n\n\r\n\x05\x04\x0f\x02\t\x05\x12\x04\xa3\x02\
    \x0b\x11\n\r\n\x05\x04\x0f\x02\t\x01\x12\x04\xa3\x02\x12\x1b\n\r\n\x05\
    \x04\x0f\x02\t\x03\x12\x04\xa3\x02\x1e\x1f\n\x0e\n\x04\x04\x0f\x03\0\x12\
    \x06\xa5\x02\x02\x8e\x03\x03\n\r\n\x05\x04\x0f\x03\0\x01\x12\x04\xa5\x02\
    \n\x14\n\x10\n\x06\x04\x0f\x03\0\x04\0\x12\x06\xa6\x02\x04\x8a\x03\x05\n\
    \x0f\n\x07\x04\x0f\x03\0\x04\0\x01\x12\x04\xa6\x02\t\r\n\xdf\x01\n\x08\
    \x04\x0f\x03\0\x04\0\x02\0\x12\x04\xab\x02\x06\x12\x1a\xcc\x01\x20This\
    \x20must\x20be\x20the\x20first\x20enum\x20value\x20in\x20this\x20list,\
    \x20to\n\x20ensure\x20that\x20if\x20'type'\x20is\x20not\x20set,\x20the\
    \x20default\x20value\n\x20is\x20UNKNOWN.\x20This\x20enables\x20enum\x20v\
    alues\x20to\x20be\x20added\n\x20in\x20a\x20backwards-compatible\x20way.\
    \x20See:\x20MESOS-4997.\n\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\0\x01\x12\
    \x04\xab\x02\x06\r\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\0\x02\x12\x04\xab\
    \x02\x10\x11\na\n\x08\x04\x0f\x03\0\x04\0\x02\x01\x12\x04\xaf\x02\x06\
    \x1e\x1aO\x20Receive\x20offers\x20with\x20revocable\x20resources.\x20See\
    \x20'Resource'\n\x20message\x20for\x20details.\n\n\x11\n\t\x04\x0f\x03\0\
    \x04\0\x02\x01\x01\x12\x04\xaf\x02\x06\x19\n\x11\n\t\x04\x0f\x03\0\x04\0\
    \x02\x01\x02\x12\x04\xaf\x02\x1c\x1d\n\xbe\x01\n\x08\x04\x0f\x03\0\x04\0\
    \x02\x02\x12\x04\xb4\x02\x06\x1d\x1a\xab\x01\x20Receive\x20the\x20TASK_K\
    ILLING\x20TaskState\x20when\x20a\x20task\x20is\x20being\n\x20killed\x20b\
    y\x20an\x20executor.\x20The\x20executor\x20will\x20examine\x20this\n\x20\
    capability\x20to\x20determine\x20whether\x20it\x20can\x20send\x20TASK_KI\
    LLING.\n\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x02\x01\x12\x04\xb4\x02\x06\
    \x18\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x02\x02\x12\x04\xb4\x02\x1b\x1c\n\
    \x91\x05\n\x08\x04\x0f\x03\0\x04\0\x02\x03\x12\x04\xc2\x02\x06\x18\x1a\
    \xfe\x04\x20Indicates\x20whether\x20the\x20framework\x20is\x20aware\x20o\
    f\x20GPU\x20resources.\n\x20Frameworks\x20that\x20are\x20aware\x20of\x20\
    GPU\x20resources\x20are\x20expected\x20to\n\x20avoid\x20placing\x20non-G\
    PU\x20workloads\x20on\x20GPU\x20agents,\x20in\x20order\n\x20to\x20avoid\
    \x20occupying\x20a\x20GPU\x20agent\x20and\x20preventing\x20GPU\x20worklo\
    ads\n\x20from\x20running!\x20Currently,\x20if\x20a\x20framework\x20is\
    \x20unaware\x20of\x20GPU\n\x20resources,\x20it\x20will\x20not\x20be\x20o\
    ffered\x20*any*\x20of\x20the\x20resources\x20on\n\x20an\x20agent\x20with\
    \x20GPUs.\x20This\x20restriction\x20is\x20in\x20place\x20because\x20we\n\
    \x20do\x20not\x20have\x20a\x20revocation\x20mechanism\x20that\x20ensures\
    \x20GPU\x20workloads\n\x20can\x20evict\x20GPU\x20agent\x20occupants\x20i\
    f\x20necessary.\n\n\x20TODO(bmahler):\x20As\x20we\x20add\x20revocation\
    \x20we\x20can\x20relax\x20the\n\x20restriction\x20here.\x20See\x20MESOS-\
    5634\x20for\x20more\x20information.\n\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\
    \x03\x01\x12\x04\xc2\x02\x06\x13\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x03\
    \x02\x12\x04\xc2\x02\x16\x17\nB\n\x08\x04\x0f\x03\0\x04\0\x02\x04\x12\
    \x04\xc5\x02\x06\x1b\x1a0\x20Receive\x20offers\x20with\x20resources\x20t\
    hat\x20are\x20shared.\n\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x04\x01\x12\
    \x04\xc5\x02\x06\x16\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x04\x02\x12\x04\
    \xc5\x02\x19\x1a\n\x9e\x07\n\x08\x04\x0f\x03\0\x04\0\x02\x05\x12\x04\xda\
    \x02\x06\x1a\x1a\x8b\x07\x20Indicates\x20that\x20(1)\x20the\x20framework\
    \x20is\x20prepared\x20to\x20handle\x20the\n\x20following\x20TaskStates:\
    \x20TASK_UNREACHABLE,\x20TASK_DROPPED,\n\x20TASK_GONE,\x20TASK_GONE_BY_O\
    PERATOR,\x20and\x20TASK_UNKNOWN,\x20and\x20(2)\n\x20the\x20framework\x20\
    will\x20assume\x20responsibility\x20for\x20managing\n\x20partitioned\x20\
    tasks\x20that\x20reregister\x20with\x20the\x20master.\n\n\x20Frameworks\
    \x20that\x20enable\x20this\x20capability\x20can\x20define\x20how\x20they\
    \n\x20would\x20like\x20to\x20handle\x20partitioned\x20tasks.\x20Framewor\
    ks\x20will\n\x20receive\x20TASK_UNREACHABLE\x20for\x20tasks\x20on\x20age\
    nts\x20that\x20are\n\x20partitioned\x20from\x20the\x20master.\n\n\x20Wit\
    hout\x20this\x20capability,\x20frameworks\x20will\x20receive\x20TASK_LOS\
    T\n\x20for\x20tasks\x20on\x20partitioned\x20agents.\n\x20NOTE:\x20Prior\
    \x20to\x20Mesos\x201.5,\x20such\x20tasks\x20will\x20be\x20killed\x20by\
    \x20Mesos\n\x20when\x20the\x20agent\x20reregisters\x20(unless\x20the\x20\
    master\x20has\x20failed\x20over).\n\x20However\x20due\x20to\x20the\x20la\
    ck\x20of\x20benefit\x20in\x20maintaining\x20different\n\x20behaviors\x20\
    depending\x20on\x20whether\x20the\x20master\x20has\x20failed\x20over\n\
    \x20(see\x20MESOS-7215),\x20as\x20of\x201.5,\x20Mesos\x20will\x20not\x20\
    kill\x20these\n\x20tasks\x20in\x20either\x20case.\n\n\x11\n\t\x04\x0f\
    \x03\0\x04\0\x02\x05\x01\x12\x04\xda\x02\x06\x15\n\x11\n\t\x04\x0f\x03\0\
    \x04\0\x02\x05\x02\x12\x04\xda\x02\x18\x19\n\xdd\x02\n\x08\x04\x0f\x03\0\
    \x04\0\x02\x06\x12\x04\xe3\x02\x06\x15\x1a\xca\x02\x20This\x20expresses\
    \x20the\x20ability\x20for\x20the\x20framework\x20to\x20be\n\x20\"multi-t\
    enant\"\x20via\x20using\x20the\x20newly\x20introduced\x20`roles`\n\x20fi\
    eld,\x20and\x20examining\x20`Offer.allocation_info`\x20to\x20determine\n\
    \x20which\x20role\x20the\x20offers\x20are\x20being\x20made\x20to.\x20We\
    \x20also\n\x20expect\x20that\x20\"single-tenant\"\x20schedulers\x20event\
    ually\n\x20provide\x20this\x20and\x20move\x20away\x20from\x20the\x20depr\
    ecated\n\x20`role`\x20field.\n\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x06\x01\
    \x12\x04\xe3\x02\x06\x10\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x06\x02\x12\
    \x04\xe3\x02\x13\x14\n\xa1\x08\n\x08\x04\x0f\x03\0\x04\0\x02\x07\x12\x04\
    \xfd\x02\x06!\x1a\xfd\x07\x20This\x20capability\x20has\x20two\x20effects\
    \x20for\x20a\x20framework.\n\n\x20(1)\x20The\x20framework\x20is\x20offer\
    ed\x20resources\x20in\x20a\x20new\x20format.\n\n\x20\x20\x20\x20\x20The\
    \x20offered\x20resources\x20have\x20the\x20`Resource.reservations`\x20fi\
    eld\x20set\n\x20\x20\x20\x20\x20rather\x20than\x20`Resource.role`\x20and\
    \x20`Resource.reservation`.\x20In\x20short,\n\x20\x20\x20\x20\x20an\x20e\
    mpty\x20`reservations`\x20field\x20denotes\x20unreserved\x20resources,\
    \x20and\n\x20\x20\x20\x20\x20each\x20`ReservationInfo`\x20in\x20the\x20`\
    reservations`\x20field\x20denotes\x20a\n\x20\x20\x20\x20\x20reservation\
    \x20that\x20refines\x20the\x20previous\x20one.\n\n\x20\x20\x20\x20\x20Se\
    e\x20the\x20'Resource\x20Format'\x20section\x20for\x20more\x20details.\n\
    \n\x20(2)\x20The\x20framework\x20can\x20create\x20refined\x20reservation\
    s.\n\n\x20\x20\x20\x20\x20A\x20framework\x20can\x20refine\x20an\x20exist\
    ing\x20reservation\x20via\x20the\n\x20\x20\x20\x20\x20`Resource.reservat\
    ions`\x20field.\x20For\x20example,\x20a\x20reservation\x20for\x20role\n\
    \x20\x20\x20\x20\x20`eng`\x20can\x20be\x20refined\x20to\x20`eng/front_en\
    d`.\n\n\x20\x20\x20\x20\x20See\x20`ReservationInfo.reservations`\x20for\
    \x20more\x20details.\n\n\x20NOTE:\x20Without\x20this\x20capability,\x20a\
    \x20framework\x20is\x20not\x20offered\x20resources\n\x20that\x20have\x20\
    refined\x20reservations.\x20A\x20resource\x20is\x20said\x20to\x20have\
    \x20refined\n\x20reservations\x20if\x20it\x20uses\x20the\x20`Resource.re\
    servations`\x20field,\x20and\n\x20`Resource.reservations_size()\x20>\x20\
    1`.\n\"\x0f\x20EXPERIMENTAL.\n\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x07\x01\
    \x12\x04\xfd\x02\x06\x1c\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x07\x02\x12\
    \x04\xfd\x02\x1f\x20\n\xd5\x04\n\x08\x04\x0f\x03\0\x04\0\x02\x08\x12\x04\
    \x89\x03\x06\x17\x1a\xc2\x04\x20Indicates\x20that\x20the\x20framework\
    \x20is\x20prepared\x20to\x20receive\x20offers\n\x20for\x20agents\x20whos\
    e\x20region\x20is\x20different\x20from\x20the\x20master's\n\x20region.\
    \x20Network\x20links\x20between\x20hosts\x20in\x20different\x20regions\n\
    \x20typically\x20have\x20higher\x20latency\x20and\x20lower\x20bandwidth\
    \x20than\n\x20network\x20links\x20within\x20a\x20region,\x20so\x20framew\
    orks\x20should\x20be\n\x20careful\x20to\x20only\x20place\x20suitable\x20\
    workloads\x20in\x20remote\x20regions.\n\x20Frameworks\x20that\x20are\x20\
    not\x20region-aware\x20will\x20never\x20receive\n\x20offers\x20for\x20re\
    mote\x20agents;\x20region-aware\x20frameworks\x20are\x20assumed\n\x20to\
    \x20implement\x20their\x20own\x20logic\x20to\x20decide\x20which\x20workl\
    oads\x20(if\n\x20any)\x20are\x20suitable\x20for\x20placement\x20on\x20re\
    mote\x20agents.\n\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x08\x01\x12\x04\x89\
    \x03\x06\x12\n\x11\n\t\x04\x0f\x03\0\x04\0\x02\x08\x02\x12\x04\x89\x03\
    \x15\x16\nB\n\x06\x04\x0f\x03\0\x02\0\x12\x04\x8d\x03\x04\x1b\x1a2\x20En\
    um\x20fields\x20should\x20be\x20optional,\x20see:\x20MESOS-4997.\n\n\x0f\
    \n\x07\x04\x0f\x03\0\x02\0\x04\x12\x04\x8d\x03\x04\x0c\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\0\x06\x12\x04\x8d\x03\r\x11\n\x0f\n\x07\x04\x0f\x03\0\x02\
    \0\x01\x12\x04\x8d\x03\x12\x16\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x03\x12\
    \x04\x8d\x03\x19\x1a\n\x90\x01\n\x04\x04\x0f\x02\n\x12\x04\x93\x03\x02(\
    \x1a\x81\x01\x20This\x20field\x20allows\x20a\x20framework\x20to\x20adver\
    tise\x20its\x20set\x20of\n\x20capabilities\x20(e.g.,\x20ability\x20to\
    \x20receive\x20offers\x20for\x20revocable\n\x20resources).\n\n\r\n\x05\
    \x04\x0f\x02\n\x04\x12\x04\x93\x03\x02\n\n\r\n\x05\x04\x0f\x02\n\x06\x12\
    \x04\x93\x03\x0b\x15\n\r\n\x05\x04\x0f\x02\n\x01\x12\x04\x93\x03\x16\"\n\
    \r\n\x05\x04\x0f\x02\n\x03\x12\x04\x93\x03%'\n\x8a\x02\n\x04\x04\x0f\x02\
    \x0b\x12\x04\x99\x03\x02\x1e\x1a\xfb\x01\x20Labels\x20are\x20free-form\
    \x20key\x20value\x20pairs\x20supplied\x20by\x20the\x20framework\n\x20sch\
    eduler\x20(e.g.,\x20to\x20describe\x20additional\x20functionality\x20off\
    ered\x20by\n\x20the\x20framework).\x20These\x20labels\x20are\x20not\x20i\
    nterpreted\x20by\x20Mesos\x20itself.\n\x20Labels\x20should\x20not\x20con\
    tain\x20duplicate\x20key-value\x20pairs.\n\n\r\n\x05\x04\x0f\x02\x0b\x04\
    \x12\x04\x99\x03\x02\n\n\r\n\x05\x04\x0f\x02\x0b\x06\x12\x04\x99\x03\x0b\
    \x11\n\r\n\x05\x04\x0f\x02\x0b\x01\x12\x04\x99\x03\x12\x18\n\r\n\x05\x04\
    \x0f\x02\x0b\x03\x12\x04\x99\x03\x1b\x1d\n\xb3\x02\n\x02\x04\x10\x12\x06\
    \xa5\x03\0\xef\x03\x01\x1a\xa4\x02*\n\x20Describes\x20a\x20general\x20no\
    n-interpreting\x20non-killing\x20check\x20for\x20a\x20task\x20or\n\x20ex\
    ecutor\x20(or\x20any\x20arbitrary\x20process/command).\x20A\x20type\x20i\
    s\x20picked\x20by\n\x20specifying\x20one\x20of\x20the\x20optional\x20fie\
    lds.\x20Specifying\x20more\x20than\x20one\x20type\n\x20is\x20an\x20error\
    .\n\n\x20NOTE:\x20This\x20API\x20is\x20unstable\x20and\x20the\x20related\
    \x20feature\x20is\x20experimental.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xa5\
    \x03\x08\x11\n\x0e\n\x04\x04\x10\x04\0\x12\x06\xa6\x03\x02\xaf\x03\x03\n\
    \r\n\x05\x04\x10\x04\0\x01\x12\x04\xa6\x03\x07\x0b\n\x0e\n\x06\x04\x10\
    \x04\0\x02\0\x12\x04\xa7\x03\x04\x10\n\x0f\n\x07\x04\x10\x04\0\x02\0\x01\
    \x12\x04\xa7\x03\x04\x0b\n\x0f\n\x07\x04\x10\x04\0\x02\0\x02\x12\x04\xa7\
    \x03\x0e\x0f\n\x0e\n\x06\x04\x10\x04\0\x02\x01\x12\x04\xa8\x03\x04\x10\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x01\x01\x12\x04\xa8\x03\x04\x0b\n\x0f\n\x07\
    \x04\x10\x04\0\x02\x01\x02\x12\x04\xa8\x03\x0e\x0f\n\x0e\n\x06\x04\x10\
    \x04\0\x02\x02\x12\x04\xa9\x03\x04\r\n\x0f\n\x07\x04\x10\x04\0\x02\x02\
    \x01\x12\x04\xa9\x03\x04\x08\n\x0f\n\x07\x04\x10\x04\0\x02\x02\x02\x12\
    \x04\xa9\x03\x0b\x0c\n\x0e\n\x06\x04\x10\x04\0\x02\x03\x12\x04\xaa\x03\
    \x04\x0c\n\x0f\n\x07\x04\x10\x04\0\x02\x03\x01\x12\x04\xaa\x03\x04\x07\n\
    \x0f\n\x07\x04\x10\x04\0\x02\x03\x02\x12\x04\xaa\x03\n\x0b\np\n\x04\x04\
    \x10\x03\0\x12\x06\xb3\x03\x02\xb5\x03\x03\x1a`\x20Describes\x20a\x20com\
    mand\x20check.\x20If\x20applicable,\x20enters\x20mount\x20and/or\x20netw\
    ork\n\x20namespaces\x20of\x20the\x20task.\n\n\r\n\x05\x04\x10\x03\0\x01\
    \x12\x04\xb3\x03\n\x11\n\x0e\n\x06\x04\x10\x03\0\x02\0\x12\x04\xb4\x03\
    \x04%\n\x0f\n\x07\x04\x10\x03\0\x02\0\x04\x12\x04\xb4\x03\x04\x0c\n\x0f\
    \n\x07\x04\x10\x03\0\x02\0\x06\x12\x04\xb4\x03\r\x18\n\x0f\n\x07\x04\x10\
    \x03\0\x02\0\x01\x12\x04\xb4\x03\x19\x20\n\x0f\n\x07\x04\x10\x03\0\x02\0\
    \x03\x12\x04\xb4\x03#$\n\xae\x01\n\x04\x04\x10\x03\x01\x12\x06\xba\x03\
    \x02\xc9\x03\x03\x1a\x9d\x01\x20Describes\x20an\x20HTTP\x20check.\x20Sen\
    ds\x20a\x20GET\x20request\x20to\n\x20http://<host>:port/path.\x20Note\
    \x20that\x20<host>\x20is\x20not\x20configurable\x20and\x20is\n\x20resolv\
    ed\x20automatically\x20to\x20127.0.0.1.\n\n\r\n\x05\x04\x10\x03\x01\x01\
    \x12\x04\xba\x03\n\x0e\n0\n\x06\x04\x10\x03\x01\x02\0\x12\x04\xbc\x03\
    \x04\x1d\x1a\x20\x20Port\x20to\x20send\x20the\x20HTTP\x20request.\n\n\
    \x0f\n\x07\x04\x10\x03\x01\x02\0\x04\x12\x04\xbc\x03\x04\x0c\n\x0f\n\x07\
    \x04\x10\x03\x01\x02\0\x05\x12\x04\xbc\x03\r\x13\n\x0f\n\x07\x04\x10\x03\
    \x01\x02\0\x01\x12\x04\xbc\x03\x14\x18\n\x0f\n\x07\x04\x10\x03\x01\x02\0\
    \x03\x12\x04\xbc\x03\x1b\x1c\n$\n\x06\x04\x10\x03\x01\x02\x01\x12\x04\
    \xbf\x03\x04\x1d\x1a\x14\x20HTTP\x20request\x20path.\n\n\x0f\n\x07\x04\
    \x10\x03\x01\x02\x01\x04\x12\x04\xbf\x03\x04\x0c\n\x0f\n\x07\x04\x10\x03\
    \x01\x02\x01\x05\x12\x04\xbf\x03\r\x13\n\x0f\n\x07\x04\x10\x03\x01\x02\
    \x01\x01\x12\x04\xbf\x03\x14\x18\n\x0f\n\x07\x04\x10\x03\x01\x02\x01\x03\
    \x12\x04\xbf\x03\x1b\x1c\n\xbf\x01\n\x04\x04\x10\x03\x02\x12\x06\xce\x03\
    \x02\xd0\x03\x03\x1a\xae\x01\x20Describes\x20a\x20TCP\x20check,\x20i.e.\
    \x20based\x20on\x20establishing\x20a\x20TCP\x20connection\x20to\n\x20the\
    \x20specified\x20port.\x20Note\x20that\x20<host>\x20is\x20not\x20configu\
    rable\x20and\x20is\x20resolved\n\x20automatically\x20to\x20127.0.0.1.\n\
    \n\r\n\x05\x04\x10\x03\x02\x01\x12\x04\xce\x03\n\r\n\x0e\n\x06\x04\x10\
    \x03\x02\x02\0\x12\x04\xcf\x03\x04\x1d\n\x0f\n\x07\x04\x10\x03\x02\x02\0\
    \x04\x12\x04\xcf\x03\x04\x0c\n\x0f\n\x07\x04\x10\x03\x02\x02\0\x05\x12\
    \x04\xcf\x03\r\x13\n\x0f\n\x07\x04\x10\x03\x02\x02\0\x01\x12\x04\xcf\x03\
    \x14\x18\n\x0f\n\x07\x04\x10\x03\x02\x02\0\x03\x12\x04\xcf\x03\x1b\x1c\n\
    &\n\x04\x04\x10\x02\0\x12\x04\xd3\x03\x02\x19\x1a\x18\x20The\x20type\x20\
    of\x20the\x20check.\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xd3\x03\x02\n\
    \n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xd3\x03\x0b\x0f\n\r\n\x05\x04\x10\
    \x02\0\x01\x12\x04\xd3\x03\x10\x14\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \xd3\x03\x17\x18\n\x1e\n\x04\x04\x10\x02\x01\x12\x04\xd6\x03\x02\x1f\x1a\
    \x10\x20Command\x20check.\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xd6\
    \x03\x02\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xd6\x03\x0b\x12\n\r\n\
    \x05\x04\x10\x02\x01\x01\x12\x04\xd6\x03\x13\x1a\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\xd6\x03\x1d\x1e\n\x1b\n\x04\x04\x10\x02\x02\x12\x04\xd9\
    \x03\x02\x19\x1a\r\x20HTTP\x20check.\n\n\r\n\x05\x04\x10\x02\x02\x04\x12\
    \x04\xd9\x03\x02\n\n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\xd9\x03\x0b\x0f\
    \n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xd9\x03\x10\x14\n\r\n\x05\x04\x10\
    \x02\x02\x03\x12\x04\xd9\x03\x17\x18\n\x1a\n\x04\x04\x10\x02\x03\x12\x04\
    \xdc\x03\x02\x17\x1a\x0c\x20TCP\x20check.\n\n\r\n\x05\x04\x10\x02\x03\
    \x04\x12\x04\xdc\x03\x02\n\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\xdc\x03\
    \x0b\x0e\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xdc\x03\x0f\x12\n\r\n\x05\
    \x04\x10\x02\x03\x03\x12\x04\xdc\x03\x15\x16\n\xa5\x01\n\x04\x04\x10\x02\
    \x04\x12\x04\xe1\x03\x025\x1a\x96\x01\x20Amount\x20of\x20time\x20to\x20w\
    ait\x20to\x20start\x20checking\x20the\x20task\x20after\x20it\n\x20transi\
    tions\x20to\x20`TASK_RUNNING`\x20or\x20`TASK_STARTING`\x20if\x20the\x20l\
    atter\n\x20is\x20used\x20by\x20the\x20executor.\n\n\r\n\x05\x04\x10\x02\
    \x04\x04\x12\x04\xe1\x03\x02\n\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xe1\
    \x03\x0b\x11\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xe1\x03\x12\x1f\n\r\n\
    \x05\x04\x10\x02\x04\x03\x12\x04\xe1\x03\"#\n\r\n\x05\x04\x10\x02\x04\
    \x08\x12\x04\xe1\x03$4\n\r\n\x05\x04\x10\x02\x04\x07\x12\x04\xe1\x03/3\n\
    \x97\x01\n\x04\x04\x10\x02\x05\x12\x04\xe5\x03\x028\x1a\x88\x01\x20Inter\
    val\x20between\x20check\x20attempts,\x20i.e.,\x20amount\x20of\x20time\
    \x20to\x20wait\x20after\n\x20the\x20previous\x20check\x20finished\x20or\
    \x20timed\x20out\x20to\x20start\x20the\x20next\x20check.\n\n\r\n\x05\x04\
    \x10\x02\x05\x04\x12\x04\xe5\x03\x02\n\n\r\n\x05\x04\x10\x02\x05\x05\x12\
    \x04\xe5\x03\x0b\x11\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xe5\x03\x12\"\
    \n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xe5\x03%&\n\r\n\x05\x04\x10\x02\
    \x05\x08\x12\x04\xe5\x03'7\n\r\n\x05\x04\x10\x02\x05\x07\x12\x04\xe5\x03\
    26\n\xde\x02\n\x04\x04\x10\x02\x06\x12\x04\xee\x03\x027\x1a\xcf\x02\x20A\
    mount\x20of\x20time\x20to\x20wait\x20for\x20the\x20check\x20to\x20comple\
    te.\x20Zero\x20means\x20infinite\n\x20timeout.\n\n\x20After\x20this\x20t\
    imeout,\x20the\x20check\x20attempt\x20is\x20aborted\x20and\x20no\x20resu\
    lt\x20is\n\x20reported.\x20Note\x20that\x20this\x20may\x20be\x20consider\
    ed\x20a\x20state\x20change\x20and\x20hence\n\x20may\x20trigger\x20a\x20c\
    heck\x20status\x20change\x20delivery\x20to\x20the\x20corresponding\n\x20\
    scheduler.\x20See\x20`CheckStatusInfo`\x20for\x20more\x20details.\n\n\r\
    \n\x05\x04\x10\x02\x06\x04\x12\x04\xee\x03\x02\n\n\r\n\x05\x04\x10\x02\
    \x06\x05\x12\x04\xee\x03\x0b\x11\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\
    \xee\x03\x12!\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\xee\x03$%\n\r\n\x05\
    \x04\x10\x02\x06\x08\x12\x04\xee\x03&6\n\r\n\x05\x04\x10\x02\x06\x07\x12\
    \x04\xee\x0315\n\xce\x01\n\x02\x04\x11\x12\x06\xf7\x03\0\xdb\x04\x01\x1a\
    \xbf\x01*\n\x20Describes\x20a\x20health\x20check\x20for\x20a\x20task\x20\
    or\x20executor\x20(or\x20any\x20arbitrary\n\x20process/command).\x20A\
    \x20type\x20is\x20picked\x20by\x20specifying\x20one\x20of\x20the\n\x20op\
    tional\x20fields.\x20Specifying\x20more\x20than\x20one\x20type\x20is\x20\
    an\x20error.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xf7\x03\x08\x13\n\x0e\n\
    \x04\x04\x11\x04\0\x12\x06\xf8\x03\x02\xfd\x03\x03\n\r\n\x05\x04\x11\x04\
    \0\x01\x12\x04\xf8\x03\x07\x0b\n\x0e\n\x06\x04\x11\x04\0\x02\0\x12\x04\
    \xf9\x03\x04\x10\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\x04\xf9\x03\x04\
    \x0b\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\xf9\x03\x0e\x0f\n\x0e\n\
    \x06\x04\x11\x04\0\x02\x01\x12\x04\xfa\x03\x04\x10\n\x0f\n\x07\x04\x11\
    \x04\0\x02\x01\x01\x12\x04\xfa\x03\x04\x0b\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x01\x02\x12\x04\xfa\x03\x0e\x0f\n\x0e\n\x06\x04\x11\x04\0\x02\x02\x12\
    \x04\xfb\x03\x04\r\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x01\x12\x04\xfb\x03\
    \x04\x08\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\x04\xfb\x03\x0b\x0c\n\
    \x0e\n\x06\x04\x11\x04\0\x02\x03\x12\x04\xfc\x03\x04\x0c\n\x0f\n\x07\x04\
    \x11\x04\0\x02\x03\x01\x12\x04\xfc\x03\x04\x07\n\x0f\n\x07\x04\x11\x04\0\
    \x02\x03\x02\x12\x04\xfc\x03\n\x0b\n\xe5\x02\n\x04\x04\x11\x03\0\x12\x06\
    \x84\x04\x02\xa5\x04\x03\x1a\xd4\x02\x20Describes\x20an\x20HTTP\x20healt\
    h\x20check.\x20Sends\x20a\x20GET\x20request\x20to\n\x20scheme://<host>:p\
    ort/path.\x20Note\x20that\x20<host>\x20is\x20not\x20configurable\x20and\
    \x20is\n\x20resolved\x20automatically,\x20in\x20most\x20cases\x20to\x201\
    27.0.0.1.\x20Default\x20executors\n\x20treat\x20return\x20codes\x20betwe\
    en\x20200\x20and\x20399\x20as\x20success;\x20custom\x20executors\n\x20ma\
    y\x20employ\x20a\x20different\x20strategy,\x20e.g.\x20leveraging\x20the\
    \x20`statuses`\x20field.\n\n\r\n\x05\x04\x11\x03\0\x01\x12\x04\x84\x04\n\
    \x17\n\x0e\n\x06\x04\x11\x03\0\x02\0\x12\x04\x85\x04\x04@\n\x0f\n\x07\
    \x04\x11\x03\0\x02\0\x04\x12\x04\x85\x04\x04\x0c\n\x0f\n\x07\x04\x11\x03\
    \0\x02\0\x06\x12\x04\x85\x04\r!\n\x0f\n\x07\x04\x11\x03\0\x02\0\x01\x12\
    \x04\x85\x04\"*\n\x0f\n\x07\x04\x11\x03\0\x02\0\x03\x12\x04\x85\x04-.\n\
    \x0f\n\x07\x04\x11\x03\0\x02\0\x08\x12\x04\x85\x04/?\n\x0f\n\x07\x04\x11\
    \x03\0\x02\0\x07\x12\x04\x85\x04:>\n=\n\x06\x04\x11\x03\0\x02\x01\x12\
    \x04\x88\x04\x04\x1f\x1a-\x20Currently\x20\"http\"\x20and\x20\"https\"\
    \x20are\x20supported.\n\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x04\x12\x04\
    \x88\x04\x04\x0c\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\x12\x04\x88\x04\r\
    \x13\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\x88\x04\x14\x1a\n\x0f\
    \n\x07\x04\x11\x03\0\x02\x01\x03\x12\x04\x88\x04\x1d\x1e\n0\n\x06\x04\
    \x11\x03\0\x02\x02\x12\x04\x8b\x04\x04\x1d\x1a\x20\x20Port\x20to\x20send\
    \x20the\x20HTTP\x20request.\n\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x04\x12\
    \x04\x8b\x04\x04\x0c\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x05\x12\x04\x8b\
    \x04\r\x13\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x01\x12\x04\x8b\x04\x14\x18\
    \n\x0f\n\x07\x04\x11\x03\0\x02\x02\x03\x12\x04\x8b\x04\x1b\x1c\n$\n\x06\
    \x04\x11\x03\0\x02\x03\x12\x04\x8e\x04\x04\x1d\x1a\x14\x20HTTP\x20reques\
    t\x20path.\n\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x04\x12\x04\x8e\x04\x04\
    \x0c\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x05\x12\x04\x8e\x04\r\x13\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x03\x01\x12\x04\x8e\x04\x14\x18\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x03\x03\x12\x04\x8e\x04\x1b\x1c\n\xa9\x04\n\x06\x04\x11\
    \x03\0\x02\x04\x12\x04\x9e\x04\x04!\x1a\xa3\x02\x20NOTE:\x20It\x20is\x20\
    up\x20to\x20the\x20custom\x20executor\x20to\x20interpret\x20and\x20act\
    \x20on\x20this\n\x20field.\x20Setting\x20this\x20field\x20has\x20no\x20e\
    ffect\x20on\x20the\x20default\x20executors.\n\n\x20TODO(haosdent):\x20De\
    precate\x20this\x20field\x20when\x20we\x20add\x20better\x20support\x20fo\
    r\n\x20success\x20and\x20possibly\x20failure\x20statuses,\x20e.g.\x20ran\
    ges\x20of\x20success\x20and\n\x20failure\x20statuses.\n2v\x20TODO(alexr)\
    :\x20Add\x20support\x20for\x20HTTP\x20method.\x20While\x20adding\x20POST\
    \n\x20and\x20PUT\x20is\x20simple,\x20supporting\x20payload\x20is\x20more\
    \x20involved.\n23\x20TODO(alexr):\x20Add\x20support\x20for\x20custom\x20\
    HTTP\x20headers.\n2F\x20TODO(alexr):\x20Add\x20support\x20for\x20success\
    \x20and\x20possibly\x20failure\n\x20statuses.\n\n\x0f\n\x07\x04\x11\x03\
    \0\x02\x04\x04\x12\x04\x9e\x04\x04\x0c\n\x0f\n\x07\x04\x11\x03\0\x02\x04\
    \x05\x12\x04\x9e\x04\r\x13\n\x0f\n\x07\x04\x11\x03\0\x02\x04\x01\x12\x04\
    \x9e\x04\x14\x1c\n\x0f\n\x07\x04\x11\x03\0\x02\x04\x03\x12\x04\x9e\x04\
    \x1f\x20\ns\n\x04\x04\x11\x03\x01\x12\x06\xa9\x04\x02\xae\x04\x03\x1ac\
    \x20Describes\x20a\x20TCP\x20health\x20check,\x20i.e.\x20based\x20on\x20\
    establishing\n\x20a\x20TCP\x20connection\x20to\x20the\x20specified\x20po\
    rt.\n\n\r\n\x05\x04\x11\x03\x01\x01\x12\x04\xa9\x04\n\x16\n\x0e\n\x06\
    \x04\x11\x03\x01\x02\0\x12\x04\xaa\x04\x04@\n\x0f\n\x07\x04\x11\x03\x01\
    \x02\0\x04\x12\x04\xaa\x04\x04\x0c\n\x0f\n\x07\x04\x11\x03\x01\x02\0\x06\
    \x12\x04\xaa\x04\r!\n\x0f\n\x07\x04\x11\x03\x01\x02\0\x01\x12\x04\xaa\
    \x04\"*\n\x0f\n\x07\x04\x11\x03\x01\x02\0\x03\x12\x04\xaa\x04-.\n\x0f\n\
    \x07\x04\x11\x03\x01\x02\0\x08\x12\x04\xaa\x04/?\n\x0f\n\x07\x04\x11\x03\
    \x01\x02\0\x07\x12\x04\xaa\x04:>\n+\n\x06\x04\x11\x03\x01\x02\x01\x12\
    \x04\xad\x04\x04\x1d\x1a\x1b\x20Port\x20expected\x20to\x20be\x20open.\n\
    \n\x0f\n\x07\x04\x11\x03\x01\x02\x01\x04\x12\x04\xad\x04\x04\x0c\n\x0f\n\
    \x07\x04\x11\x03\x01\x02\x01\x05\x12\x04\xad\x04\r\x13\n\x0f\n\x07\x04\
    \x11\x03\x01\x02\x01\x01\x12\x04\xad\x04\x14\x18\n\x0f\n\x07\x04\x11\x03\
    \x01\x02\x01\x03\x12\x04\xad\x04\x1b\x1c\n\xde\x02\n\x04\x04\x11\x02\0\
    \x12\x04\xb7\x04\x025\x1a\x9c\x01\x20Amount\x20of\x20time\x20to\x20wait\
    \x20to\x20start\x20health\x20checking\x20the\x20task\x20after\x20it\n\
    \x20transitions\x20to\x20`TASK_RUNNING`\x20or\x20`TASK_STATING`\x20if\
    \x20the\x20latter\x20is\n\x20used\x20by\x20the\x20executor.\n2\xb0\x01\
    \x20TODO(benh):\x20Consider\x20adding\x20a\x20URL\x20health\x20check\x20\
    strategy\x20which\n\x20allows\x20doing\x20something\x20similar\x20to\x20\
    the\x20HTTP\x20strategy\x20but\n\x20encapsulates\x20all\x20the\x20detail\
    s\x20in\x20a\x20single\x20string\x20field.\n\n\r\n\x05\x04\x11\x02\0\x04\
    \x12\x04\xb7\x04\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xb7\x04\x0b\
    \x11\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb7\x04\x12\x1f\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xb7\x04\"#\n\r\n\x05\x04\x11\x02\0\x08\x12\x04\
    \xb7\x04$4\n\r\n\x05\x04\x11\x02\0\x07\x12\x04\xb7\x04/3\n\xa5\x01\n\x04\
    \x04\x11\x02\x01\x12\x04\xbc\x04\x028\x1a\x96\x01\x20Interval\x20between\
    \x20health\x20checks,\x20i.e.,\x20amount\x20of\x20time\x20to\x20wait\x20\
    after\n\x20the\x20previous\x20health\x20check\x20finished\x20or\x20timed\
    \x20out\x20to\x20start\x20the\x20next\n\x20health\x20check.\n\n\r\n\x05\
    \x04\x11\x02\x01\x04\x12\x04\xbc\x04\x02\n\n\r\n\x05\x04\x11\x02\x01\x05\
    \x12\x04\xbc\x04\x0b\x11\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xbc\x04\
    \x12\"\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xbc\x04%&\n\r\n\x05\x04\x11\
    \x02\x01\x08\x12\x04\xbc\x04'7\n\r\n\x05\x04\x11\x02\x01\x07\x12\x04\xbc\
    \x0426\n\xb2\x01\n\x04\x04\x11\x02\x02\x12\x04\xc1\x04\x027\x1a\xa3\x01\
    \x20Amount\x20of\x20time\x20to\x20wait\x20for\x20the\x20health\x20check\
    \x20to\x20complete.\x20After\x20this\n\x20timeout,\x20the\x20health\x20c\
    heck\x20is\x20aborted\x20and\x20treated\x20as\x20a\x20failure.\x20Zero\n\
    \x20means\x20infinite\x20timeout.\n\n\r\n\x05\x04\x11\x02\x02\x04\x12\
    \x04\xc1\x04\x02\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xc1\x04\x0b\x11\
    \n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xc1\x04\x12!\n\r\n\x05\x04\x11\
    \x02\x02\x03\x12\x04\xc1\x04$%\n\r\n\x05\x04\x11\x02\x02\x08\x12\x04\xc1\
    \x04&6\n\r\n\x05\x04\x11\x02\x02\x07\x12\x04\xc1\x0415\nX\n\x04\x04\x11\
    \x02\x03\x12\x04\xc4\x04\x029\x1aJ\x20Number\x20of\x20consecutive\x20fai\
    lures\x20until\x20the\x20task\x20is\x20killed\x20by\x20the\x20executor.\
    \n\n\r\n\x05\x04\x11\x02\x03\x04\x12\x04\xc4\x04\x02\n\n\r\n\x05\x04\x11\
    \x02\x03\x05\x12\x04\xc4\x04\x0b\x11\n\r\n\x05\x04\x11\x02\x03\x01\x12\
    \x04\xc4\x04\x12&\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xc4\x04)*\n\r\n\
    \x05\x04\x11\x02\x03\x08\x12\x04\xc4\x04+8\n\r\n\x05\x04\x11\x02\x03\x07\
    \x12\x04\xc4\x0467\n\xae\x02\n\x04\x04\x11\x02\x04\x12\x04\xcb\x04\x02<\
    \x1a\x9f\x02\x20Amount\x20of\x20time\x20after\x20the\x20task\x20is\x20la\
    unched\x20during\x20which\x20health\x20check\n\x20failures\x20are\x20ign\
    ored.\x20Once\x20a\x20check\x20succeeds\x20for\x20the\x20first\x20time,\
    \n\x20the\x20grace\x20period\x20does\x20not\x20apply\x20anymore.\x20Note\
    \x20that\x20it\x20includes\n\x20`delay_seconds`,\x20i.e.,\x20setting\x20\
    `grace_period_seconds`\x20<\x20`delay_seconds`\n\x20has\x20no\x20effect.\
    \n\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\xcb\x04\x02\n\n\r\n\x05\x04\x11\
    \x02\x04\x05\x12\x04\xcb\x04\x0b\x11\n\r\n\x05\x04\x11\x02\x04\x01\x12\
    \x04\xcb\x04\x12&\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xcb\x04)*\n\r\n\
    \x05\x04\x11\x02\x04\x08\x12\x04\xcb\x04+;\n\r\n\x05\x04\x11\x02\x04\x07\
    \x12\x04\xcb\x046:\n\xa4\x01\n\x04\x04\x11\x02\x05\x12\x04\xd1\x04\x02\
    \x19\x1a\x1b\x20The\x20type\x20of\x20health\x20check.\n2y\x20TODO(alexr)\
    :\x20Add\x20an\x20optional\x20`KillPolicy`\x20that\x20should\x20be\x20us\
    ed\n\x20if\x20the\x20task\x20is\x20killed\x20because\x20of\x20a\x20healt\
    h\x20check\x20failure.\n\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xd1\x04\
    \x02\n\n\r\n\x05\x04\x11\x02\x05\x06\x12\x04\xd1\x04\x0b\x0f\n\r\n\x05\
    \x04\x11\x02\x05\x01\x12\x04\xd1\x04\x10\x14\n\r\n\x05\x04\x11\x02\x05\
    \x03\x12\x04\xd1\x04\x17\x18\n%\n\x04\x04\x11\x02\x06\x12\x04\xd4\x04\
    \x02#\x1a\x17\x20Command\x20health\x20check.\n\n\r\n\x05\x04\x11\x02\x06\
    \x04\x12\x04\xd4\x04\x02\n\n\r\n\x05\x04\x11\x02\x06\x06\x12\x04\xd4\x04\
    \x0b\x16\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xd4\x04\x17\x1e\n\r\n\x05\
    \x04\x11\x02\x06\x03\x12\x04\xd4\x04!\"\n\"\n\x04\x04\x11\x02\x07\x12\
    \x04\xd7\x04\x02\"\x1a\x14\x20HTTP\x20health\x20check.\n\n\r\n\x05\x04\
    \x11\x02\x07\x04\x12\x04\xd7\x04\x02\n\n\r\n\x05\x04\x11\x02\x07\x06\x12\
    \x04\xd7\x04\x0b\x18\n\r\n\x05\x04\x11\x02\x07\x01\x12\x04\xd7\x04\x19\
    \x1d\n\r\n\x05\x04\x11\x02\x07\x03\x12\x04\xd7\x04\x20!\n!\n\x04\x04\x11\
    \x02\x08\x12\x04\xda\x04\x02\x20\x1a\x13\x20TCP\x20health\x20check.\n\n\
    \r\n\x05\x04\x11\x02\x08\x04\x12\x04\xda\x04\x02\n\n\r\n\x05\x04\x11\x02\
    \x08\x06\x12\x04\xda\x04\x0b\x17\n\r\n\x05\x04\x11\x02\x08\x01\x12\x04\
    \xda\x04\x18\x1b\n\r\n\x05\x04\x11\x02\x08\x03\x12\x04\xda\x04\x1e\x1f\n\
    \x88\x05\n\x02\x04\x12\x12\x06\xee\x04\0\xf9\x04\x01\x1a\xf9\x04*\n\x20D\
    escribes\x20a\x20kill\x20policy\x20for\x20a\x20task.\x20Currently\x20doe\
    s\x20not\x20express\n\x20different\x20policies\x20(e.g.\x20hitting\x20HT\
    TP\x20endpoints),\x20only\x20controls\n\x20how\x20long\x20to\x20wait\x20\
    between\x20graceful\x20and\x20forcible\x20task\x20kill:\n\n\x20\x20\x20\
    \x20\x20graceful\x20kill\x20-------------->\x20forcible\x20kill\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20grace_period\n\n\x20Kill\x20policies\x20are\x20best-effort,\x20becau\
    se\x20machine\x20failures\x20/\x20forcible\n\x20terminations\x20may\x20o\
    ccur.\n\n\x20NOTE:\x20For\x20executor-less\x20command-based\x20tasks,\
    \x20the\x20kill\x20is\x20performed\n\x20via\x20sending\x20a\x20signal\
    \x20to\x20the\x20task\x20process:\x20SIGTERM\x20for\x20the\x20graceful\n\
    \x20kill\x20and\x20SIGKILL\x20for\x20the\x20forcible\x20kill.\x20For\x20\
    the\x20docker\x20executor-less\n\x20tasks\x20the\x20grace\x20period\x20i\
    s\x20passed\x20to\x20'docker\x20stop\x20--time'.\n\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\xee\x04\x08\x12\n\x8d\x04\n\x04\x04\x12\x02\0\x12\x04\xf8\
    \x04\x02)\x1a\xfe\x03\x20The\x20grace\x20period\x20specifies\x20how\x20l\
    ong\x20to\x20wait\x20before\x20forcibly\n\x20killing\x20the\x20task.\x20\
    It\x20is\x20recommended\x20to\x20attempt\x20to\x20gracefully\n\x20kill\
    \x20the\x20task\x20(and\x20send\x20TASK_KILLING)\x20to\x20indicate\x20th\
    at\x20the\n\x20graceful\x20kill\x20is\x20in\x20progress.\x20Once\x20the\
    \x20grace\x20period\x20elapses,\n\x20if\x20the\x20task\x20has\x20not\x20\
    terminated,\x20a\x20forcible\x20kill\x20should\x20occur.\n\x20The\x20tas\
    k\x20should\x20not\x20assume\x20that\x20it\x20will\x20always\x20be\x20al\
    lotted\n\x20the\x20full\x20grace\x20period.\x20For\x20example,\x20the\
    \x20executor\x20may\x20be\n\x20shutdown\x20more\x20quickly\x20by\x20the\
    \x20agent,\x20or\x20failures\x20/\x20forcible\n\x20terminations\x20may\
    \x20occur.\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xf8\x04\x02\n\n\r\n\x05\
    \x04\x12\x02\0\x06\x12\x04\xf8\x04\x0b\x17\n\r\n\x05\x04\x12\x02\0\x01\
    \x12\x04\xf8\x04\x18$\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xf8\x04'(\n\
    \xd5\x04\n\x02\x04\x13\x12\x06\x86\x05\0\xbe\x05\x01\x1a\xc6\x04*\n\x20D\
    escribes\x20a\x20command,\x20executed\x20via:\x20'/bin/sh\x20-c\x20value\
    '.\x20Any\x20URIs\x20specified\n\x20are\x20fetched\x20before\x20executin\
    g\x20the\x20command.\x20\x20If\x20the\x20executable\x20field\x20for\x20a\
    n\n\x20uri\x20is\x20set,\x20executable\x20file\x20permission\x20is\x20se\
    t\x20on\x20the\x20downloaded\x20file.\n\x20Otherwise,\x20if\x20the\x20do\
    wnloaded\x20file\x20has\x20a\x20recognized\x20archive\x20extension\n\x20\
    (currently\x20[compressed]\x20tar\x20and\x20zip)\x20it\x20is\x20extracte\
    d\x20into\x20the\x20executor's\n\x20working\x20directory.\x20This\x20ext\
    raction\x20can\x20be\x20disabled\x20by\x20setting\x20`extract`\x20to\n\
    \x20false.\x20In\x20addition,\x20any\x20environment\x20variables\x20are\
    \x20set\x20before\x20executing\n\x20the\x20command\x20(so\x20they\x20can\
    \x20be\x20used\x20to\x20\"parameterize\"\x20your\x20command).\n\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\x86\x05\x08\x13\n\x0e\n\x04\x04\x13\x03\0\x12\
    \x06\x87\x05\x02\xa3\x05\x03\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\x87\x05\
    \n\r\n\x0e\n\x06\x04\x13\x03\0\x02\0\x12\x04\x88\x05\x04\x1e\n\x0f\n\x07\
    \x04\x13\x03\0\x02\0\x04\x12\x04\x88\x05\x04\x0c\n\x0f\n\x07\x04\x13\x03\
    \0\x02\0\x05\x12\x04\x88\x05\r\x13\n\x0f\n\x07\x04\x13\x03\0\x02\0\x01\
    \x12\x04\x88\x05\x14\x19\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\x88\
    \x05\x1c\x1d\n\x0e\n\x06\x04\x13\x03\0\x02\x01\x12\x04\x89\x05\x04!\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x01\x04\x12\x04\x89\x05\x04\x0c\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x01\x05\x12\x04\x89\x05\r\x11\n\x0f\n\x07\x04\x13\x03\
    \0\x02\x01\x01\x12\x04\x89\x05\x12\x1c\n\x0f\n\x07\x04\x13\x03\0\x02\x01\
    \x03\x12\x04\x89\x05\x1f\x20\n\xf5\x01\n\x06\x04\x13\x03\0\x02\x02\x12\
    \x04\x8f\x05\x04/\x1a\xe4\x01\x20In\x20case\x20the\x20fetched\x20file\
    \x20is\x20recognized\x20as\x20an\x20archive,\x20extract\n\x20its\x20cont\
    ents\x20into\x20the\x20sandbox.\x20Note\x20that\x20a\x20cached\x20archiv\
    e\x20is\n\x20not\x20copied\x20from\x20the\x20cache\x20to\x20the\x20sandb\
    ox\x20in\x20case\x20extraction\n\x20originates\x20from\x20an\x20archive\
    \x20in\x20the\x20cache.\n\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x04\x12\x04\
    \x8f\x05\x04\x0c\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x05\x12\x04\x8f\x05\r\
    \x11\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x01\x12\x04\x8f\x05\x12\x19\n\x0f\
    \n\x07\x04\x13\x03\0\x02\x02\x03\x12\x04\x8f\x05\x1c\x1d\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x02\x08\x12\x04\x8f\x05\x1e.\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x02\x07\x12\x04\x8f\x05)-\n\xe0\x04\n\x06\x04\x13\x03\0\x02\x03\x12\
    \x04\x9b\x05\x04\x1c\x1a\xcf\x04\x20If\x20this\x20field\x20is\x20\"true\
    \",\x20the\x20fetcher\x20cache\x20will\x20be\x20used.\x20If\x20not,\n\
    \x20fetching\x20bypasses\x20the\x20cache\x20and\x20downloads\x20directly\
    \x20into\x20the\n\x20sandbox\x20directory,\x20no\x20matter\x20whether\
    \x20a\x20suitable\x20cache\x20file\x20is\n\x20available\x20or\x20not.\
    \x20The\x20former\x20directs\x20the\x20fetcher\x20to\x20download\x20to\n\
    \x20the\x20file\x20cache,\x20then\x20copy\x20from\x20there\x20to\x20the\
    \x20sandbox.\x20Subsequent\n\x20fetch\x20attempts\x20with\x20the\x20same\
    \x20URI\x20will\x20omit\x20downloading\x20and\x20copy\n\x20from\x20the\
    \x20cache\x20as\x20long\x20as\x20the\x20file\x20is\x20resident\x20there.\
    \x20Cache\x20files\n\x20may\x20get\x20evicted\x20at\x20any\x20time,\x20w\
    hich\x20then\x20leads\x20to\x20renewed\n\x20downloading.\x20See\x20also\
    \x20\"docs/fetcher.md\"\x20and\n\x20\"docs/fetcher-cache-internals.md\".\
    \n\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x04\x12\x04\x9b\x05\x04\x0c\n\x0f\n\
    \x07\x04\x13\x03\0\x02\x03\x05\x12\x04\x9b\x05\r\x11\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x03\x01\x12\x04\x9b\x05\x12\x17\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x03\x03\x12\x04\x9b\x05\x1a\x1b\n\xcb\x02\n\x06\x04\x13\x03\0\x02\x04\
    \x12\x04\xa2\x05\x04$\x1a\xba\x02\x20The\x20fetcher's\x20default\x20beha\
    vior\x20is\x20to\x20use\x20the\x20URI\x20string's\x20basename\x20to\n\
    \x20name\x20the\x20local\x20copy.\x20If\x20this\x20field\x20is\x20provid\
    ed,\x20the\x20local\x20copy\x20will\x20be\n\x20named\x20with\x20its\x20v\
    alue\x20instead.\x20If\x20there\x20is\x20a\x20directory\x20component\x20\
    (which\n\x20must\x20be\x20a\x20relative\x20path),\x20the\x20local\x20cop\
    y\x20will\x20be\x20stored\x20in\x20that\n\x20subdirectory\x20inside\x20t\
    he\x20sandbox.\n\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x04\x12\x04\xa2\x05\
    \x04\x0c\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x05\x12\x04\xa2\x05\r\x13\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x04\x01\x12\x04\xa2\x05\x14\x1f\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x04\x03\x12\x04\xa2\x05\"#\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xa5\x05\x02\x18\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xa5\x05\x02\
    \n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xa5\x05\x0b\x0e\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xa5\x05\x0f\x13\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xa5\x05\x16\x17\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xa7\x05\x02'\n\r\n\
    \x05\x04\x13\x02\x01\x04\x12\x04\xa7\x05\x02\n\n\r\n\x05\x04\x13\x02\x01\
    \x06\x12\x04\xa7\x05\x0b\x16\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xa7\
    \x05\x17\"\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xa7\x05%&\n\xfb\x05\n\
    \x04\x04\x13\x02\x02\x12\x04\xb6\x05\x02+\x1a\xec\x05\x20There\x20are\
    \x20two\x20ways\x20to\x20specify\x20the\x20command:\n\x201)\x20If\x20'sh\
    ell\x20==\x20true',\x20the\x20command\x20will\x20be\x20launched\x20via\
    \x20shell\n\t\t(i.e.,\x20/bin/sh\x20-c\x20'value').\x20The\x20'value'\
    \x20specified\x20will\x20be\n\t\ttreated\x20as\x20the\x20shell\x20comman\
    d.\x20The\x20'arguments'\x20will\x20be\x20ignored.\n\x202)\x20If\x20'she\
    ll\x20==\x20false',\x20the\x20command\x20will\x20be\x20launched\x20by\
    \x20passing\n\t\targuments\x20to\x20an\x20executable.\x20The\x20'value'\
    \x20specified\x20will\x20be\n\t\ttreated\x20as\x20the\x20filename\x20of\
    \x20the\x20executable.\x20The\x20'arguments'\n\t\twill\x20be\x20treated\
    \x20as\x20the\x20arguments\x20to\x20the\x20executable.\x20This\x20is\n\t\
    \tsimilar\x20to\x20how\x20POSIX\x20exec\x20families\x20launch\x20process\
    es\x20(i.e.,\n\t\texeclp(value,\x20arguments(0),\x20arguments(1),\x20...\
    )).\n\x20NOTE:\x20The\x20field\x20'value'\x20is\x20changed\x20from\x20'r\
    equired'\x20to\x20'optional'\n\x20in\x200.20.0.\x20It\x20will\x20only\
    \x20cause\x20issues\x20if\x20a\x20new\x20framework\x20is\n\x20connecting\
    \x20to\x20an\x20old\x20master.\n\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\
    \xb6\x05\x02\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xb6\x05\x0b\x0f\n\r\
    \n\x05\x04\x13\x02\x02\x01\x12\x04\xb6\x05\x10\x15\n\r\n\x05\x04\x13\x02\
    \x02\x03\x12\x04\xb6\x05\x18\x19\n\r\n\x05\x04\x13\x02\x02\x08\x12\x04\
    \xb6\x05\x1a*\n\r\n\x05\x04\x13\x02\x02\x07\x12\x04\xb6\x05%)\n\x0c\n\
    \x04\x04\x13\x02\x03\x12\x04\xb7\x05\x02\x1c\n\r\n\x05\x04\x13\x02\x03\
    \x04\x12\x04\xb7\x05\x02\n\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\xb7\x05\
    \x0b\x11\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xb7\x05\x12\x17\n\r\n\x05\
    \x04\x13\x02\x03\x03\x12\x04\xb7\x05\x1a\x1b\n\x0c\n\x04\x04\x13\x02\x04\
    \x12\x04\xb8\x05\x02\x20\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\xb8\x05\
    \x02\n\n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\xb8\x05\x0b\x11\n\r\n\x05\
    \x04\x13\x02\x04\x01\x12\x04\xb8\x05\x12\x1b\n\r\n\x05\x04\x13\x02\x04\
    \x03\x12\x04\xb8\x05\x1e\x1f\n\xb2\x01\n\x04\x04\x13\x02\x05\x12\x04\xbd\
    \x05\x02\x1b\x1a\xa3\x01\x20Enables\x20executor\x20and\x20tasks\x20to\
    \x20run\x20as\x20a\x20specific\x20user.\x20If\x20the\x20user\n\x20field\
    \x20is\x20present\x20both\x20in\x20FrameworkInfo\x20and\x20here,\x20the\
    \x20CommandInfo\n\x20user\x20value\x20takes\x20precedence.\n\n\r\n\x05\
    \x04\x13\x02\x05\x04\x12\x04\xbd\x05\x02\n\n\r\n\x05\x04\x13\x02\x05\x05\
    \x12\x04\xbd\x05\x0b\x11\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xbd\x05\
    \x12\x16\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xbd\x05\x19\x1a\n:\n\x02\
    \x04\x14\x12\x06\xc4\x05\0\x95\x06\x01\x1a,*\n\x20Describes\x20informati\
    on\x20about\x20an\x20executor.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xc4\x05\
    \x08\x14\n\x0e\n\x04\x04\x14\x04\0\x12\x06\xc5\x05\x02\xda\x05\x03\n\r\n\
    \x05\x04\x14\x04\0\x01\x12\x04\xc5\x05\x07\x0b\n\x0e\n\x06\x04\x14\x04\0\
    \x02\0\x12\x04\xc6\x05\x04\x10\n\x0f\n\x07\x04\x14\x04\0\x02\0\x01\x12\
    \x04\xc6\x05\x04\x0b\n\x0f\n\x07\x04\x14\x04\0\x02\0\x02\x12\x04\xc6\x05\
    \x0e\x0f\n\x95\x03\n\x06\x04\x14\x04\0\x02\x01\x12\x04\xd4\x05\x04\x10\
    \x1a\x84\x03\x20Mesos\x20provides\x20a\x20simple\x20built-in\x20default\
    \x20executor\x20that\x20frameworks\x20can\n\x20leverage\x20to\x20run\x20\
    shell\x20commands\x20and\x20containers.\n\n\x20NOTES:\n\n\x201)\x20`comm\
    and`\x20must\x20not\x20be\x20set\x20when\x20using\x20a\x20default\x20exe\
    cutor.\n\n\x202)\x20Default\x20executor\x20only\x20accepts\x20a\x20*sing\
    le*\x20`LAUNCH`\x20or\x20`LAUNCH_GROUP`\n\x20\x20\x20\x20operation.\n\n\
    \x203)\x20If\x20`container`\x20is\x20set,\x20`container.type`\x20must\
    \x20be\x20`MESOS`\n\x20\x20\x20\x20and\x20`container.mesos.image`\x20mus\
    t\x20not\x20be\x20set.\n\n\x0f\n\x07\x04\x14\x04\0\x02\x01\x01\x12\x04\
    \xd4\x05\x04\x0b\n\x0f\n\x07\x04\x14\x04\0\x02\x01\x02\x12\x04\xd4\x05\
    \x0e\x0f\n\xb1\x01\n\x06\x04\x14\x04\0\x02\x02\x12\x04\xd9\x05\x04\x0f\
    \x1a\xa0\x01\x20For\x20frameworks\x20that\x20need\x20custom\x20functiona\
    lity\x20to\x20run\x20tasks,\x20a\x20`CUSTOM`\n\x20executor\x20can\x20be\
    \x20used.\x20Note\x20that\x20`command`\x20must\x20be\x20set\x20when\x20u\
    sing\x20a\n\x20`CUSTOM`\x20executor.\n\n\x0f\n\x07\x04\x14\x04\0\x02\x02\
    \x01\x12\x04\xd9\x05\x04\n\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x02\x12\x04\
    \xd9\x05\r\x0e\n\xd9\x02\n\x04\x04\x14\x02\0\x12\x04\xe3\x05\x02\x1a\x1a\
    \xca\x02\x20For\x20backwards\x20compatibility,\x20if\x20this\x20field\
    \x20is\x20not\x20set\x20when\x20using\x20`LAUNCH`\n\x20operation,\x20Mes\
    os\x20will\x20infer\x20the\x20type\x20by\x20checking\x20if\x20`command`\
    \x20is\x20set\n\x20(`CUSTOM`)\x20or\x20unset\x20(`DEFAULT`).\x20`type`\
    \x20must\x20be\x20set\x20when\x20using\n\x20`LAUNCH_GROUP`\x20operation.\
    \n\n\x20TODO(vinod):\x20Add\x20support\x20for\x20explicitly\x20setting\
    \x20`type`\x20to\x20`DEFAULT`\x20in\n\x20`LAUNCH`\x20operation.\n\n\r\n\
    \x05\x04\x14\x02\0\x04\x12\x04\xe3\x05\x02\n\n\r\n\x05\x04\x14\x02\0\x06\
    \x12\x04\xe3\x05\x0b\x0f\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xe3\x05\x10\
    \x14\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xe3\x05\x17\x19\n\x0c\n\x04\x04\
    \x14\x02\x01\x12\x04\xe5\x05\x02&\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\
    \xe5\x05\x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xe5\x05\x0b\x15\n\r\
    \n\x05\x04\x14\x02\x01\x01\x12\x04\xe5\x05\x16!\n\r\n\x05\x04\x14\x02\
    \x01\x03\x12\x04\xe5\x05$%\n/\n\x04\x04\x14\x02\x02\x12\x04\xe6\x05\x02(\
    \"!\x20TODO(benh):\x20Make\x20this\x20required.\n\n\r\n\x05\x04\x14\x02\
    \x02\x04\x12\x04\xe6\x05\x02\n\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xe6\
    \x05\x0b\x16\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xe6\x05\x17#\n\r\n\
    \x05\x04\x14\x02\x02\x03\x12\x04\xe6\x05&'\n\x0c\n\x04\x04\x14\x02\x03\
    \x12\x04\xe7\x05\x02#\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xe7\x05\x02\
    \n\n\r\n\x05\x04\x14\x02\x03\x06\x12\x04\xe7\x05\x0b\x16\n\r\n\x05\x04\
    \x14\x02\x03\x01\x12\x04\xe7\x05\x17\x1e\n\r\n\x05\x04\x14\x02\x03\x03\
    \x12\x04\xe7\x05!\"\n\xa7\x01\n\x04\x04\x14\x02\x04\x12\x04\xec\x05\x02(\
    \x1a\x98\x01\x20Executor\x20provided\x20with\x20a\x20container\x20will\
    \x20launch\x20the\x20container\n\x20with\x20the\x20executor's\x20Command\
    Info\x20and\x20we\x20expect\x20the\x20container\x20to\n\x20act\x20as\x20\
    a\x20Mesos\x20executor.\n\n\r\n\x05\x04\x14\x02\x04\x04\x12\x04\xec\x05\
    \x02\n\n\r\n\x05\x04\x14\x02\x04\x06\x12\x04\xec\x05\x0b\x18\n\r\n\x05\
    \x04\x14\x02\x04\x01\x12\x04\xec\x05\x19\"\n\r\n\x05\x04\x14\x02\x04\x03\
    \x12\x04\xec\x05%'\n\x0c\n\x04\x04\x14\x02\x05\x12\x04\xee\x05\x02\"\n\r\
    \n\x05\x04\x14\x02\x05\x04\x12\x04\xee\x05\x02\n\n\r\n\x05\x04\x14\x02\
    \x05\x06\x12\x04\xee\x05\x0b\x13\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\
    \xee\x05\x14\x1d\n\r\n\x05\x04\x14\x02\x05\x03\x12\x04\xee\x05\x20!\n\
    \x0c\n\x04\x04\x14\x02\x06\x12\x04\xef\x05\x02\x1b\n\r\n\x05\x04\x14\x02\
    \x06\x04\x12\x04\xef\x05\x02\n\n\r\n\x05\x04\x14\x02\x06\x05\x12\x04\xef\
    \x05\x0b\x11\n\r\n\x05\x04\x14\x02\x06\x01\x12\x04\xef\x05\x12\x16\n\r\n\
    \x05\x04\x14\x02\x06\x03\x12\x04\xef\x05\x19\x1a\n\xec\x03\n\x04\x04\x14\
    \x02\x07\x12\x04\xfb\x05\x022\x1a\xcf\x03\x20'source'\x20is\x20an\x20ide\
    ntifier\x20style\x20string\x20used\x20by\x20frameworks\x20to\n\x20track\
    \x20the\x20source\x20of\x20an\x20executor.\x20This\x20is\x20useful\x20wh\
    en\x20it's\n\x20possible\x20for\x20different\x20executor\x20ids\x20to\
    \x20be\x20related\x20semantically.\n\n\x20NOTE:\x20'source'\x20is\x20exp\
    osed\x20alongside\x20the\x20resource\x20usage\x20of\x20the\n\x20executor\
    \x20via\x20JSON\x20on\x20the\x20agent.\x20This\x20allows\x20users\x20to\
    \x20import\x20usage\n\x20information\x20into\x20a\x20time\x20series\x20d\
    atabase\x20for\x20monitoring.\n\n\x20This\x20field\x20is\x20deprecated\
    \x20since\x201.0.\x20Please\x20use\x20labels\x20for\n\x20free-form\x20me\
    tadata\x20instead.\n\"\x0c\x20Since\x201.0.\n\n\r\n\x05\x04\x14\x02\x07\
    \x04\x12\x04\xfb\x05\x02\n\n\r\n\x05\x04\x14\x02\x07\x05\x12\x04\xfb\x05\
    \x0b\x11\n\r\n\x05\x04\x14\x02\x07\x01\x12\x04\xfb\x05\x12\x18\n\r\n\x05\
    \x04\x14\x02\x07\x03\x12\x04\xfb\x05\x1b\x1d\n\r\n\x05\x04\x14\x02\x07\
    \x08\x12\x04\xfb\x05\x1e1\n\x10\n\x08\x04\x14\x02\x07\x08\xe7\x07\0\x12\
    \x04\xfb\x05\x1f0\n\x11\n\t\x04\x14\x02\x07\x08\xe7\x07\0\x02\x12\x04\
    \xfb\x05\x1f)\n\x12\n\n\x04\x14\x02\x07\x08\xe7\x07\0\x02\0\x12\x04\xfb\
    \x05\x1f)\n\x13\n\x0b\x04\x14\x02\x07\x08\xe7\x07\0\x02\0\x01\x12\x04\
    \xfb\x05\x1f)\n\x11\n\t\x04\x14\x02\x07\x08\xe7\x07\0\x03\x12\x04\xfb\
    \x05,0\nN\n\x04\x04\x14\x02\x08\x12\x04\xfe\x05\x02\x1a\x1a@\x20This\x20\
    field\x20can\x20be\x20used\x20to\x20pass\x20arbitrary\x20bytes\x20to\x20\
    an\x20executor.\n\n\r\n\x05\x04\x14\x02\x08\x04\x12\x04\xfe\x05\x02\n\n\
    \r\n\x05\x04\x14\x02\x08\x05\x12\x04\xfe\x05\x0b\x10\n\r\n\x05\x04\x14\
    \x02\x08\x01\x12\x04\xfe\x05\x11\x15\n\r\n\x05\x04\x14\x02\x08\x03\x12\
    \x04\xfe\x05\x18\x19\n\xf9\x01\n\x04\x04\x14\x02\t\x12\x04\x84\x06\x02(\
    \x1a\xea\x01\x20Service\x20discovery\x20information\x20for\x20the\x20exe\
    cutor.\x20It\x20is\x20not\n\x20interpreted\x20or\x20acted\x20upon\x20by\
    \x20Mesos.\x20It\x20is\x20up\x20to\x20a\x20service\n\x20discovery\x20sys\
    tem\x20to\x20use\x20this\x20information\x20as\x20needed\x20and\x20to\x20\
    handle\n\x20executors\x20without\x20service\x20discovery\x20information.\
    \n\n\r\n\x05\x04\x14\x02\t\x04\x12\x04\x84\x06\x02\n\n\r\n\x05\x04\x14\
    \x02\t\x06\x12\x04\x84\x06\x0b\x18\n\r\n\x05\x04\x14\x02\t\x01\x12\x04\
    \x84\x06\x19\"\n\r\n\x05\x04\x14\x02\t\x03\x12\x04\x84\x06%'\n\xe4\x02\n\
    \x04\x04\x14\x02\n\x12\x04\x8c\x06\x023\x1a\xd5\x02\x20When\x20shutting\
    \x20down\x20an\x20executor\x20the\x20agent\x20will\x20wait\x20in\x20a\n\
    \x20best-effort\x20manner\x20for\x20the\x20grace\x20period\x20specified\
    \x20here\n\x20before\x20forcibly\x20destroying\x20the\x20container.\x20T\
    he\x20executor\n\x20must\x20not\x20assume\x20that\x20it\x20will\x20alway\
    s\x20be\x20allotted\x20the\x20full\n\x20grace\x20period,\x20as\x20the\
    \x20agent\x20may\x20decide\x20to\x20allot\x20a\x20shorter\n\x20period\
    \x20and\x20failures\x20/\x20forcible\x20terminations\x20may\x20occur.\n\
    \n\r\n\x05\x04\x14\x02\n\x04\x12\x04\x8c\x06\x02\n\n\r\n\x05\x04\x14\x02\
    \n\x06\x12\x04\x8c\x06\x0b\x17\n\r\n\x05\x04\x14\x02\n\x01\x12\x04\x8c\
    \x06\x18-\n\r\n\x05\x04\x14\x02\n\x03\x12\x04\x8c\x0602\n\x8b\x03\n\x04\
    \x04\x14\x02\x0b\x12\x04\x94\x06\x02\x1e\x1a\xfc\x02\x20Labels\x20are\
    \x20free-form\x20key\x20value\x20pairs\x20which\x20are\x20exposed\x20thr\
    ough\n\x20master\x20and\x20agent\x20endpoints.\x20Labels\x20will\x20not\
    \x20be\x20interpreted\x20or\n\x20acted\x20upon\x20by\x20Mesos\x20itself.\
    \x20As\x20opposed\x20to\x20the\x20data\x20field,\x20labels\n\x20will\x20\
    be\x20kept\x20in\x20memory\x20on\x20master\x20and\x20agent\x20processes.\
    \x20Therefore,\n\x20labels\x20should\x20be\x20used\x20to\x20tag\x20execu\
    tors\x20with\x20lightweight\x20metadata.\n\x20Labels\x20should\x20not\
    \x20contain\x20duplicate\x20key-value\x20pairs.\n\n\r\n\x05\x04\x14\x02\
    \x0b\x04\x12\x04\x94\x06\x02\n\n\r\n\x05\x04\x14\x02\x0b\x06\x12\x04\x94\
    \x06\x0b\x11\n\r\n\x05\x04\x14\x02\x0b\x01\x12\x04\x94\x06\x12\x18\n\r\n\
    \x05\x04\x14\x02\x0b\x03\x12\x04\x94\x06\x1b\x1d\n\xa5\x0e\n\x02\x04\x15\
    \x12\x06\xbc\x06\0\xcb\x06\x01\x1a\x96\x0e*\n\x20Describes\x20a\x20domai\
    n.\x20A\x20domain\x20is\x20a\x20collection\x20of\x20hosts\x20that\x20hav\
    e\n\x20similar\x20characteristics.\x20Mesos\x20currently\x20only\x20supp\
    orts\x20\"fault\n\x20domains\",\x20which\x20identify\x20groups\x20of\x20\
    hosts\x20with\x20similar\x20failure\n\x20characteristics.\n\n\x20Framewo\
    rks\x20can\x20generally\x20assume\x20that\x20network\x20links\x20between\
    \x20hosts\x20in\n\x20the\x20same\x20fault\x20domain\x20have\x20lower\x20\
    latency,\x20higher\x20bandwidth,\x20and\x20better\n\x20availability\x20t\
    han\x20network\x20links\x20between\x20hosts\x20in\x20different\x20domain\
    s.\n\x20Schedulers\x20may\x20prefer\x20to\x20place\x20network-intensive\
    \x20workloads\x20in\x20the\n\x20same\x20domain,\x20as\x20this\x20may\x20\
    improve\x20performance.\x20Conversely,\x20a\x20single\n\x20failure\x20th\
    at\x20affects\x20a\x20host\x20in\x20a\x20domain\x20may\x20be\x20more\x20\
    likely\x20to\n\x20affect\x20other\x20hosts\x20in\x20the\x20same\x20domai\
    n;\x20hence,\x20schedulers\x20may\x20prefer\n\x20to\x20place\x20workload\
    s\x20that\x20require\x20high\x20availability\x20in\x20multiple\n\x20doma\
    ins.\x20(For\x20example,\x20all\x20the\x20hosts\x20in\x20a\x20single\x20\
    rack\x20might\x20lose\n\x20power\x20or\x20network\x20connectivity\x20sim\
    ultaneously.)\n\n\x20There\x20are\x20two\x20kinds\x20of\x20fault\x20doma\
    ins:\x20regions\x20and\x20zones.\x20Regions\n\x20offer\x20the\x20highest\
    \x20degree\x20of\x20fault\x20isolation,\x20but\x20network\x20latency\n\
    \x20between\x20regions\x20is\x20typically\x20high\x20(typically\x20>50\
    \x20ms).\x20Zones\x20offer\x20a\n\x20modest\x20degree\x20of\x20fault\x20\
    isolation\x20along\x20with\x20reasonably\x20low\x20network\n\x20latency\
    \x20(typically\x20<10\x20ms).\n\n\x20The\x20mapping\x20from\x20fault\x20\
    domains\x20to\x20physical\x20infrastructure\x20is\x20up\x20to\n\x20the\
    \x20operator\x20to\x20configure.\x20In\x20cloud\x20environments,\x20regi\
    ons\x20and\x20zones\n\x20can\x20be\x20mapped\x20to\x20the\x20\"region\"\
    \x20and\x20\"availability\x20zone\"\x20concepts\n\x20exposed\x20by\x20mo\
    st\x20cloud\x20providers,\x20respectively.\x20In\x20on-premise\n\x20depl\
    oyments,\x20regions\x20and\x20zones\x20can\x20be\x20mapped\x20to\x20data\
    \x20centers\x20and\n\x20racks,\x20respectively.\n\n\x20Both\x20masters\
    \x20and\x20agents\x20can\x20be\x20configured\x20with\x20domains.\x20Fram\
    eworks\n\x20can\x20compare\x20the\x20domains\x20of\x20two\x20hosts\x20to\
    \x20determine\x20if\x20the\x20hosts\x20are\n\x20in\x20the\x20same\x20zon\
    e,\x20in\x20different\x20zones\x20in\x20the\x20same\x20region,\x20or\x20\
    in\n\x20different\x20regions.\x20Note\x20that\x20all\x20masters\x20in\
    \x20a\x20given\x20Mesos\x20cluster\n\x20must\x20be\x20in\x20the\x20same\
    \x20region.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xbc\x06\x08\x12\n\x0e\n\
    \x04\x04\x15\x03\0\x12\x06\xbd\x06\x02\xc8\x06\x03\n\r\n\x05\x04\x15\x03\
    \0\x01\x12\x04\xbd\x06\n\x15\n\x10\n\x06\x04\x15\x03\0\x03\0\x12\x06\xbe\
    \x06\x04\xc0\x06\x05\n\x0f\n\x07\x04\x15\x03\0\x03\0\x01\x12\x04\xbe\x06\
    \x0c\x16\n\x10\n\x08\x04\x15\x03\0\x03\0\x02\0\x12\x04\xbf\x06\x06\x1f\n\
    \x11\n\t\x04\x15\x03\0\x03\0\x02\0\x04\x12\x04\xbf\x06\x06\x0e\n\x11\n\t\
    \x04\x15\x03\0\x03\0\x02\0\x05\x12\x04\xbf\x06\x0f\x15\n\x11\n\t\x04\x15\
    \x03\0\x03\0\x02\0\x01\x12\x04\xbf\x06\x16\x1a\n\x11\n\t\x04\x15\x03\0\
    \x03\0\x02\0\x03\x12\x04\xbf\x06\x1d\x1e\n\x10\n\x06\x04\x15\x03\0\x03\
    \x01\x12\x06\xc2\x06\x04\xc4\x06\x05\n\x0f\n\x07\x04\x15\x03\0\x03\x01\
    \x01\x12\x04\xc2\x06\x0c\x14\n\x10\n\x08\x04\x15\x03\0\x03\x01\x02\0\x12\
    \x04\xc3\x06\x06\x1f\n\x11\n\t\x04\x15\x03\0\x03\x01\x02\0\x04\x12\x04\
    \xc3\x06\x06\x0e\n\x11\n\t\x04\x15\x03\0\x03\x01\x02\0\x05\x12\x04\xc3\
    \x06\x0f\x15\n\x11\n\t\x04\x15\x03\0\x03\x01\x02\0\x01\x12\x04\xc3\x06\
    \x16\x1a\n\x11\n\t\x04\x15\x03\0\x03\x01\x02\0\x03\x12\x04\xc3\x06\x1d\
    \x1e\n\x0e\n\x06\x04\x15\x03\0\x02\0\x12\x04\xc6\x06\x04#\n\x0f\n\x07\
    \x04\x15\x03\0\x02\0\x04\x12\x04\xc6\x06\x04\x0c\n\x0f\n\x07\x04\x15\x03\
    \0\x02\0\x06\x12\x04\xc6\x06\r\x17\n\x0f\n\x07\x04\x15\x03\0\x02\0\x01\
    \x12\x04\xc6\x06\x18\x1e\n\x0f\n\x07\x04\x15\x03\0\x02\0\x03\x12\x04\xc6\
    \x06!\"\n\x0e\n\x06\x04\x15\x03\0\x02\x01\x12\x04\xc7\x06\x04\x1f\n\x0f\
    \n\x07\x04\x15\x03\0\x02\x01\x04\x12\x04\xc7\x06\x04\x0c\n\x0f\n\x07\x04\
    \x15\x03\0\x02\x01\x06\x12\x04\xc7\x06\r\x15\n\x0f\n\x07\x04\x15\x03\0\
    \x02\x01\x01\x12\x04\xc7\x06\x16\x1a\n\x0f\n\x07\x04\x15\x03\0\x02\x01\
    \x03\x12\x04\xc7\x06\x1d\x1e\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xca\x06\
    \x02(\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xca\x06\x02\n\n\r\n\x05\x04\
    \x15\x02\0\x06\x12\x04\xca\x06\x0b\x16\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xca\x06\x17#\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xca\x06&'\n\xa9\
    \x01\n\x02\x04\x16\x12\x06\xd3\x06\0\x83\x07\x01\x1a\x9a\x01*\n\x20Descr\
    ibes\x20a\x20master.\x20This\x20will\x20probably\x20have\x20more\x20fiel\
    ds\x20in\x20the\n\x20future\x20which\x20might\x20be\x20used,\x20for\x20e\
    xample,\x20to\x20link\x20a\x20framework\x20webui\n\x20to\x20a\x20master\
    \x20webui.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xd3\x06\x08\x12\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\xd4\x06\x02\x19\n\r\n\x05\x04\x16\x02\0\x04\x12\
    \x04\xd4\x06\x02\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xd4\x06\x0b\x11\n\
    \r\n\x05\x04\x16\x02\0\x01\x12\x04\xd4\x06\x12\x14\n\r\n\x05\x04\x16\x02\
    \0\x03\x12\x04\xd4\x06\x17\x18\n\x88\x01\n\x04\x04\x16\x02\x01\x12\x04\
    \xd8\x06\x02\x19\x1az\x20The\x20IP\x20address\x20(only\x20IPv4)\x20as\
    \x20a\x20packed\x204-bytes\x20integer,\n\x20stored\x20in\x20network\x20o\
    rder.\x20\x20Deprecated,\x20use\x20`address.ip`\x20instead.\n\n\r\n\x05\
    \x04\x16\x02\x01\x04\x12\x04\xd8\x06\x02\n\n\r\n\x05\x04\x16\x02\x01\x05\
    \x12\x04\xd8\x06\x0b\x11\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xd8\x06\
    \x12\x14\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xd8\x06\x17\x18\n|\n\x04\
    \x04\x16\x02\x02\x12\x04\xdc\x06\x02,\x1an\x20The\x20TCP\x20port\x20the\
    \x20Master\x20is\x20listening\x20on\x20for\x20incoming\n\x20HTTP\x20requ\
    ests;\x20deprecated,\x20use\x20`address.port`\x20instead.\n\n\r\n\x05\
    \x04\x16\x02\x02\x04\x12\x04\xdc\x06\x02\n\n\r\n\x05\x04\x16\x02\x02\x05\
    \x12\x04\xdc\x06\x0b\x11\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xdc\x06\
    \x12\x16\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xdc\x06\x19\x1a\n\r\n\x05\
    \x04\x16\x02\x02\x08\x12\x04\xdc\x06\x1b+\n\r\n\x05\x04\x16\x02\x02\x07\
    \x12\x04\xdc\x06&*\n\xfa\x01\n\x04\x04\x16\x02\x03\x12\x04\xe2\x06\x02\
    \x1a\x1a\xeb\x01\x20In\x20the\x20default\x20implementation,\x20this\x20w\
    ill\x20contain\x20information\n\x20about\x20both\x20the\x20IP\x20address\
    ,\x20port\x20and\x20Master\x20name;\x20it\x20should\x20really\n\x20not\
    \x20be\x20relied\x20upon\x20by\x20external\x20tooling/frameworks\x20and\
    \x20be\n\x20considered\x20an\x20\"internal\"\x20implementation\x20field.\
    \n\n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\xe2\x06\x02\n\n\r\n\x05\x04\x16\
    \x02\x03\x05\x12\x04\xe2\x06\x0b\x11\n\r\n\x05\x04\x16\x02\x03\x01\x12\
    \x04\xe2\x06\x12\x15\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xe2\x06\x18\
    \x19\n\xec\x01\n\x04\x04\x16\x02\x04\x12\x04\xe8\x06\x02\x1f\x1a\xdd\x01\
    \x20The\x20server's\x20hostname,\x20if\x20available;\x20it\x20may\x20be\
    \x20unreliable\n\x20in\x20environments\x20where\x20the\x20DNS\x20configu\
    ration\x20does\x20not\x20resolve\n\x20internal\x20hostnames\x20(eg,\x20s\
    ome\x20public\x20cloud\x20providers).\n\x20Deprecated,\x20use\x20`addres\
    s.hostname`\x20instead.\n\n\r\n\x05\x04\x16\x02\x04\x04\x12\x04\xe8\x06\
    \x02\n\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\xe8\x06\x0b\x11\n\r\n\x05\
    \x04\x16\x02\x04\x01\x12\x04\xe8\x06\x12\x1a\n\r\n\x05\x04\x16\x02\x04\
    \x03\x12\x04\xe8\x06\x1d\x1e\nh\n\x04\x04\x16\x02\x05\x12\x04\xec\x06\
    \x02\x1e\x1aZ\x20The\x20running\x20Master\x20version,\x20as\x20a\x20stri\
    ng;\x20taken\x20from\x20the\n\x20generated\x20\"master/version.hpp\".\n\
    \n\r\n\x05\x04\x16\x02\x05\x04\x12\x04\xec\x06\x02\n\n\r\n\x05\x04\x16\
    \x02\x05\x05\x12\x04\xec\x06\x0b\x11\n\r\n\x05\x04\x16\x02\x05\x01\x12\
    \x04\xec\x06\x12\x19\n\r\n\x05\x04\x16\x02\x05\x03\x12\x04\xec\x06\x1c\
    \x1d\n\x95\x01\n\x04\x04\x16\x02\x06\x12\x04\xf1\x06\x02\x1f\x1a\x86\x01\
    \x20The\x20full\x20IP\x20address\x20(supports\x20both\x20IPv4\x20and\x20\
    IPv6\x20formats)\n\x20and\x20supersedes\x20the\x20use\x20of\x20`ip`,\x20\
    `port`\x20and\x20`hostname`.\n\x20Since\x20Mesos\x200.24.\n\n\r\n\x05\
    \x04\x16\x02\x06\x04\x12\x04\xf1\x06\x02\n\n\r\n\x05\x04\x16\x02\x06\x06\
    \x12\x04\xf1\x06\x0b\x12\n\r\n\x05\x04\x16\x02\x06\x01\x12\x04\xf1\x06\
    \x13\x1a\n\r\n\x05\x04\x16\x02\x06\x03\x12\x04\xf1\x06\x1d\x1e\ny\n\x04\
    \x04\x16\x02\x07\x12\x04\xf5\x06\x02!\x1ak\x20The\x20domain\x20that\x20t\
    his\x20master\x20belongs\x20to.\x20All\x20masters\x20in\x20a\x20Mesos\n\
    \x20cluster\x20should\x20belong\x20to\x20the\x20same\x20region.\n\n\r\n\
    \x05\x04\x16\x02\x07\x04\x12\x04\xf5\x06\x02\n\n\r\n\x05\x04\x16\x02\x07\
    \x06\x12\x04\xf5\x06\x0b\x15\n\r\n\x05\x04\x16\x02\x07\x01\x12\x04\xf5\
    \x06\x16\x1c\n\r\n\x05\x04\x16\x02\x07\x03\x12\x04\xf5\x06\x1f\x20\n\x0e\
    \n\x04\x04\x16\x03\0\x12\x06\xf7\x06\x02\x80\x07\x03\n\r\n\x05\x04\x16\
    \x03\0\x01\x12\x04\xf7\x06\n\x14\n\x10\n\x06\x04\x16\x03\0\x04\0\x12\x06\
    \xf8\x06\x04\xfe\x06\x05\n\x0f\n\x07\x04\x16\x03\0\x04\0\x01\x12\x04\xf8\
    \x06\t\r\n\x10\n\x08\x04\x16\x03\0\x04\0\x02\0\x12\x04\xf9\x06\x06\x12\n\
    \x11\n\t\x04\x16\x03\0\x04\0\x02\0\x01\x12\x04\xf9\x06\x06\r\n\x11\n\t\
    \x04\x16\x03\0\x04\0\x02\0\x02\x12\x04\xf9\x06\x10\x11\n[\n\x08\x04\x16\
    \x03\0\x04\0\x02\x01\x12\x04\xfd\x06\x06\x17\x1aI\x20The\x20master\x20ca\
    n\x20handle\x20slaves\x20whose\x20state\n\x20changes\x20after\x20re-regi\
    stering.\n\n\x11\n\t\x04\x16\x03\0\x04\0\x02\x01\x01\x12\x04\xfd\x06\x06\
    \x12\n\x11\n\t\x04\x16\x03\0\x04\0\x02\x01\x02\x12\x04\xfd\x06\x15\x16\n\
    \x0e\n\x06\x04\x16\x03\0\x02\0\x12\x04\xff\x06\x04\x1b\n\x0f\n\x07\x04\
    \x16\x03\0\x02\0\x04\x12\x04\xff\x06\x04\x0c\n\x0f\n\x07\x04\x16\x03\0\
    \x02\0\x06\x12\x04\xff\x06\r\x11\n\x0f\n\x07\x04\x16\x03\0\x02\0\x01\x12\
    \x04\xff\x06\x12\x16\n\x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\xff\x06\
    \x19\x1a\n\x0c\n\x04\x04\x16\x02\x08\x12\x04\x82\x07\x02'\n\r\n\x05\x04\
    \x16\x02\x08\x04\x12\x04\x82\x07\x02\n\n\r\n\x05\x04\x16\x02\x08\x06\x12\
    \x04\x82\x07\x0b\x15\n\r\n\x05\x04\x16\x02\x08\x01\x12\x04\x82\x07\x16\"\
    \n\r\n\x05\x04\x16\x02\x08\x03\x12\x04\x82\x07%&\n\xbb\x01\n\x02\x04\x17\
    \x12\x06\x8b\x07\0\xe0\x07\x01\x1a\xac\x01*\n\x20Describes\x20an\x20agen\
    t.\x20Note\x20that\x20the\x20'id'\x20field\x20is\x20only\x20available\n\
    \x20after\x20an\x20agent\x20is\x20registered\x20with\x20the\x20master,\
    \x20and\x20is\x20made\x20available\n\x20here\x20to\x20facilitate\x20re-r\
    egistration.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\x8b\x07\x08\x11\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\x8c\x07\x02\x1f\n\r\n\x05\x04\x17\x02\0\x04\
    \x12\x04\x8c\x07\x02\n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x8c\x07\x0b\
    \x11\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x8c\x07\x12\x1a\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\x8c\x07\x1d\x1e\n\x0c\n\x04\x04\x17\x02\x01\x12\
    \x04\x8d\x07\x02+\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\x8d\x07\x02\n\n\
    \r\n\x05\x04\x17\x02\x01\x05\x12\x04\x8d\x07\x0b\x10\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\x8d\x07\x11\x15\n\r\n\x05\x04\x17\x02\x01\x03\x12\
    \x04\x8d\x07\x18\x19\n\r\n\x05\x04\x17\x02\x01\x08\x12\x04\x8d\x07\x1a*\
    \n\r\n\x05\x04\x17\x02\x01\x07\x12\x04\x8d\x07%)\n\xa5\x01\n\x04\x04\x17\
    \x02\x02\x12\x04\x92\x07\x02\"\x1a\x96\x01\x20The\x20configured\x20resou\
    rces\x20at\x20the\x20agent.\x20This\x20does\x20not\x20include\x20any\n\
    \x20dynamic\x20reservations\x20or\x20persistent\x20volumes\x20that\x20ma\
    y\x20currently\n\x20exist\x20at\x20the\x20agent.\n\n\r\n\x05\x04\x17\x02\
    \x02\x04\x12\x04\x92\x07\x02\n\n\r\n\x05\x04\x17\x02\x02\x06\x12\x04\x92\
    \x07\x0b\x13\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\x92\x07\x14\x1d\n\r\n\
    \x05\x04\x17\x02\x02\x03\x12\x04\x92\x07\x20!\n\x0c\n\x04\x04\x17\x02\
    \x03\x12\x04\x94\x07\x02$\n\r\n\x05\x04\x17\x02\x03\x04\x12\x04\x94\x07\
    \x02\n\n\r\n\x05\x04\x17\x02\x03\x06\x12\x04\x94\x07\x0b\x14\n\r\n\x05\
    \x04\x17\x02\x03\x01\x12\x04\x94\x07\x15\x1f\n\r\n\x05\x04\x17\x02\x03\
    \x03\x12\x04\x94\x07\"#\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\x95\x07\x02\
    \x1a\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\x95\x07\x02\n\n\r\n\x05\x04\
    \x17\x02\x04\x06\x12\x04\x95\x07\x0b\x12\n\r\n\x05\x04\x17\x02\x04\x01\
    \x12\x04\x95\x07\x13\x15\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\x95\x07\
    \x18\x19\n\xd9\x01\n\x04\x04\x17\x02\x05\x12\x04\x9b\x07\x02\"\x1a\xca\
    \x01\x20The\x20domain\x20that\x20this\x20agent\x20belongs\x20to.\x20If\
    \x20the\x20agent's\x20region\n\x20differs\x20from\x20the\x20master's\x20\
    region,\x20it\x20will\x20not\x20appear\x20in\x20resource\n\x20offers\x20\
    to\x20frameworks\x20that\x20have\x20not\x20enabled\x20the\x20REGION_AWAR\
    E\n\x20capability.\n\n\r\n\x05\x04\x17\x02\x05\x04\x12\x04\x9b\x07\x02\n\
    \n\r\n\x05\x04\x17\x02\x05\x06\x12\x04\x9b\x07\x0b\x15\n\r\n\x05\x04\x17\
    \x02\x05\x01\x12\x04\x9b\x07\x16\x1c\n\r\n\x05\x04\x17\x02\x05\x03\x12\
    \x04\x9b\x07\x1f!\n\x0e\n\x04\x04\x17\x03\0\x12\x06\x9d\x07\x02\xdf\x07\
    \x03\n\r\n\x05\x04\x17\x03\0\x01\x12\x04\x9d\x07\n\x14\n\x10\n\x06\x04\
    \x17\x03\0\x04\0\x12\x06\x9e\x07\x04\xdb\x07\x05\n\x0f\n\x07\x04\x17\x03\
    \0\x04\0\x01\x12\x04\x9e\x07\t\r\n\xdf\x01\n\x08\x04\x17\x03\0\x04\0\x02\
    \0\x12\x04\xa3\x07\x06\x12\x1a\xcc\x01\x20This\x20must\x20be\x20the\x20f\
    irst\x20enum\x20value\x20in\x20this\x20list,\x20to\n\x20ensure\x20that\
    \x20if\x20'type'\x20is\x20not\x20set,\x20the\x20default\x20value\n\x20is\
    \x20UNKNOWN.\x20This\x20enables\x20enum\x20values\x20to\x20be\x20added\n\
    \x20in\x20a\x20backwards-compatible\x20way.\x20See:\x20MESOS-4997.\n\n\
    \x11\n\t\x04\x17\x03\0\x04\0\x02\0\x01\x12\x04\xa3\x07\x06\r\n\x11\n\t\
    \x04\x17\x03\0\x04\0\x02\0\x02\x12\x04\xa3\x07\x10\x11\nu\n\x08\x04\x17\
    \x03\0\x04\0\x02\x01\x12\x04\xa7\x07\x06\x15\x1ac\x20This\x20expresses\
    \x20the\x20ability\x20for\x20the\x20agent\x20to\x20be\x20able\n\x20to\
    \x20launch\x20tasks\x20of\x20a\x20'multi-role'\x20framework.\n\n\x11\n\t\
    \x04\x17\x03\0\x04\0\x02\x01\x01\x12\x04\xa7\x07\x06\x10\n\x11\n\t\x04\
    \x17\x03\0\x04\0\x02\x01\x02\x12\x04\xa7\x07\x13\x14\n\x8a\x03\n\x08\x04\
    \x17\x03\0\x04\0\x02\x02\x12\x04\xb0\x07\x06\x1c\x1a\xf7\x02\x20This\x20\
    expresses\x20the\x20ability\x20for\x20the\x20agent\x20to\x20be\x20able\
    \x20to\x20launch\n\x20tasks,\x20reserve\x20resources,\x20and\x20create\
    \x20volumes\x20using\x20resources\n\x20allocated\x20to\x20a\x20'hierarch\
    ical-role'.\n\x20NOTE:\x20This\x20capability\x20is\x20required\x20specif\
    ically\x20for\x20creating\n\x20volumes\x20because\x20a\x20hierchical\x20\
    role\x20includes\x20'/'\x20(slashes)\x20in\x20them.\n\x20Agents\x20with\
    \x20this\x20capability\x20know\x20to\x20transform\x20the\x20'/'\x20(slas\
    hes)\n\x20into\x20'\x20'\x20(spaces).\n\n\x11\n\t\x04\x17\x03\0\x04\0\
    \x02\x02\x01\x12\x04\xb0\x07\x06\x17\n\x11\n\t\x04\x17\x03\0\x04\0\x02\
    \x02\x02\x12\x04\xb0\x07\x1a\x1b\n\x88\x0b\n\x08\x04\x17\x03\0\x04\0\x02\
    \x03\x12\x04\xd1\x07\x06!\x1a\xf5\n\x20This\x20capability\x20has\x20thre\
    e\x20effects\x20for\x20an\x20agent.\n\n\x20(1)\x20The\x20format\x20of\
    \x20the\x20checkpointed\x20resources,\x20and\n\x20\x20\x20\x20\x20the\
    \x20resources\x20reported\x20to\x20master.\n\n\x20\x20\x20\x20\x20These\
    \x20resources\x20are\x20reported\x20in\x20the\x20\"pre-reservation-refin\
    ement\"\n\x20\x20\x20\x20\x20format\x20if\x20none\x20of\x20the\x20resour\
    ces\x20have\x20refined\x20reservations.\x20If\x20any\n\x20\x20\x20\x20\
    \x20of\x20the\x20resources\x20have\x20refined\x20reservations,\x20they\
    \x20are\x20reported\x20in\n\x20\x20\x20\x20\x20the\x20\"post-reservation\
    -refinement\"\x20format.\x20The\x20purpose\x20is\x20to\x20allow\n\x20\
    \x20\x20\x20\x20downgrading\x20of\x20an\x20agent\x20as\x20well\x20as\x20\
    communication\x20with\x20a\x20pre-1.4.0\n\x20\x20\x20\x20\x20master\x20u\
    ntil\x20the\x20reservation\x20refinement\x20feature\x20is\x20actually\
    \x20used.\n\n\x20\x20\x20\x20\x20See\x20the\x20'Resource\x20Format'\x20s\
    ection\x20for\x20more\x20details.\n\n\x20(2)\x20The\x20format\x20of\x20t\
    he\x20resources\x20reported\x20by\x20the\x20HTTP\x20endpoints.\n\n\x20\
    \x20\x20\x20\x20For\x20resources\x20reported\x20by\x20agent\x20endpoints\
    ,\x20the\n\x20\x20\x20\x20\x20\"pre-reservation-refinement\"\x20format\
    \x20is\x20\"injected\"\x20if\x20possible.\n\x20\x20\x20\x20\x20That\x20i\
    s,\x20resources\x20without\x20refined\x20reservations\x20will\x20have\
    \x20the\n\x20\x20\x20\x20\x20`Resource.role`\x20and\x20`Resource.reserva\
    tion`\x20set,\x20whereas\n\x20\x20\x20\x20\x20resources\x20with\x20refin\
    ed\x20reservations\x20will\x20not.\n\n\x20\x20\x20\x20\x20See\x20the\x20\
    'Resource\x20Format'\x20section\x20for\x20more\x20details.\n\n\x20(3)\
    \x20The\x20ability\x20for\x20the\x20agent\x20to\x20launch\x20tasks,\x20r\
    eserve\x20resources,\x20and\n\x20\x20\x20\x20\x20create\x20volumes\x20us\
    ing\x20resources\x20that\x20have\x20refined\x20reservations.\n\n\x20\x20\
    \x20\x20\x20See\x20`ReservationInfo.reservations`\x20section\x20for\x20m\
    ore\x20details.\n\n\x20NOTE:\x20Resources\x20are\x20said\x20to\x20have\
    \x20refined\x20reservations\x20if\x20it\x20uses\x20the\n\x20`Resource.re\
    servations`\x20field,\x20and\x20`Resource.reservations_size()\x20>\x201`\
    .\n\n\x11\n\t\x04\x17\x03\0\x04\0\x02\x03\x01\x12\x04\xd1\x07\x06\x1c\n\
    \x11\n\t\x04\x17\x03\0\x04\0\x02\x03\x02\x12\x04\xd1\x07\x1f\x20\n\xbd\
    \x02\n\x08\x04\x17\x03\0\x04\0\x02\x04\x12\x04\xda\x07\x06\x1c\x1a\xaa\
    \x02\x20This\x20expresses\x20the\x20ability\x20for\x20the\x20agent\x20to\
    \x20handle\x20resource\n\x20provider\x20related\x20operations.\x20This\
    \x20includes\x20the\x20following:\n\n\x20(1)\x20The\x20ability\x20to\x20\
    report\x20resources\x20that\x20are\x20provided\x20by\x20some\n\x20\x20\
    \x20\x20\x20local\x20resource\x20providers\x20through\x20the\x20resource\
    \x20provider\x20API.\n\n\x20(2)\x20The\x20ability\x20to\x20provide\x20op\
    eration\x20feedback.\n\n\x11\n\t\x04\x17\x03\0\x04\0\x02\x04\x01\x12\x04\
    \xda\x07\x06\x17\n\x11\n\t\x04\x17\x03\0\x04\0\x02\x04\x02\x12\x04\xda\
    \x07\x1a\x1b\nB\n\x06\x04\x17\x03\0\x02\0\x12\x04\xde\x07\x04\x1b\x1a2\
    \x20Enum\x20fields\x20should\x20be\x20optional,\x20see:\x20MESOS-4997.\n\
    \n\x0f\n\x07\x04\x17\x03\0\x02\0\x04\x12\x04\xde\x07\x04\x0c\n\x0f\n\x07\
    \x04\x17\x03\0\x02\0\x06\x12\x04\xde\x07\r\x11\n\x0f\n\x07\x04\x17\x03\0\
    \x02\0\x01\x12\x04\xde\x07\x12\x16\n\x0f\n\x07\x04\x17\x03\0\x02\0\x03\
    \x12\x04\xde\x07\x19\x1a\nV\n\x02\x04\x18\x12\x06\xe6\x07\0\xf1\x07\x01\
    \x1aH*\n\x20Describes\x20the\x20container\x20configuration\x20to\x20run\
    \x20a\x20CSI\x20plugin\x20component.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xe6\x07\x08\x1e\n\x0e\n\x04\x04\x18\x04\0\x12\x06\xe7\x07\x02\xeb\x07\
    \x03\n\r\n\x05\x04\x18\x04\0\x01\x12\x04\xe7\x07\x07\x0e\n\x0e\n\x06\x04\
    \x18\x04\0\x02\0\x12\x04\xe8\x07\x04\x10\n\x0f\n\x07\x04\x18\x04\0\x02\0\
    \x01\x12\x04\xe8\x07\x04\x0b\n\x0f\n\x07\x04\x18\x04\0\x02\0\x02\x12\x04\
    \xe8\x07\x0e\x0f\n\x0e\n\x06\x04\x18\x04\0\x02\x01\x12\x04\xe9\x07\x04\
    \x1b\n\x0f\n\x07\x04\x18\x04\0\x02\x01\x01\x12\x04\xe9\x07\x04\x16\n\x0f\
    \n\x07\x04\x18\x04\0\x02\x01\x02\x12\x04\xe9\x07\x19\x1a\n\x0e\n\x06\x04\
    \x18\x04\0\x02\x02\x12\x04\xea\x07\x04\x15\n\x0f\n\x07\x04\x18\x04\0\x02\
    \x02\x01\x12\x04\xea\x07\x04\x10\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x02\
    \x12\x04\xea\x07\x13\x14\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xed\x07\x02\
    \x20\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xed\x07\x02\n\n\r\n\x05\x04\x18\
    \x02\0\x06\x12\x04\xed\x07\x0b\x12\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xed\x07\x13\x1b\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xed\x07\x1e\x1f\n\
    \x0c\n\x04\x04\x18\x02\x01\x12\x04\xee\x07\x02#\n\r\n\x05\x04\x18\x02\
    \x01\x04\x12\x04\xee\x07\x02\n\n\r\n\x05\x04\x18\x02\x01\x06\x12\x04\xee\
    \x07\x0b\x16\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xee\x07\x17\x1e\n\r\n\
    \x05\x04\x18\x02\x01\x03\x12\x04\xee\x07!\"\n\x0c\n\x04\x04\x18\x02\x02\
    \x12\x04\xef\x07\x02\"\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xef\x07\x02\
    \n\n\r\n\x05\x04\x18\x02\x02\x06\x12\x04\xef\x07\x0b\x13\n\r\n\x05\x04\
    \x18\x02\x02\x01\x12\x04\xef\x07\x14\x1d\n\r\n\x05\x04\x18\x02\x02\x03\
    \x12\x04\xef\x07\x20!\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xf0\x07\x02'\n\
    \r\n\x05\x04\x18\x02\x03\x04\x12\x04\xf0\x07\x02\n\n\r\n\x05\x04\x18\x02\
    \x03\x06\x12\x04\xf0\x07\x0b\x18\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\
    \xf0\x07\x19\"\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xf0\x07%&\n)\n\x02\
    \x04\x19\x12\x06\xf7\x07\0\x8d\x08\x01\x1a\x1b*\n\x20Describes\x20a\x20C\
    SI\x20plugin.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xf7\x07\x08\x15\n\xa8\
    \x02\n\x04\x04\x19\x02\0\x12\x04\xff\x07\x02\x1b\x1a\x99\x02\x20The\x20t\
    ype\x20of\x20the\x20CSI\x20service.\x20This\x20uniquely\x20identifies\
    \x20a\x20CSI\n\x20implementation.\x20For\x20instance:\n\x20\x20\x20\x20\
    \x20org.apache.mesos.csi.test\n\n\x20Please\x20follow\x20to\x20Java\x20p\
    ackage\x20naming\x20convention\n\x20(https://en.wikipedia.org/wiki/Java_\
    package#Package_naming_conventions)\n\x20to\x20avoid\x20conflicts\x20on\
    \x20type\x20names.\n\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xff\x07\x02\n\n\
    \r\n\x05\x04\x19\x02\0\x05\x12\x04\xff\x07\x0b\x11\n\r\n\x05\x04\x19\x02\
    \0\x01\x12\x04\xff\x07\x12\x16\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xff\
    \x07\x19\x1a\n\xca\x02\n\x04\x04\x19\x02\x01\x12\x04\x86\x08\x02\x1b\x1a\
    \xbb\x02\x20The\x20name\x20of\x20the\x20CSI\x20service.\x20There\x20coul\
    d\x20be\x20mutliple\x20instances\x20of\x20a\n\x20type\x20of\x20CSI\x20se\
    rvice.\x20The\x20name\x20field\x20is\x20used\x20to\x20distinguish\x20the\
    se\n\x20instances.\x20It\x20should\x20be\x20a\x20legal\x20Java\x20identi\
    fier\n\x20(https://docs.oracle.com/javase/tutorial/java/nutsandbolts/var\
    iables.html)\n\x20to\x20avoid\x20conflicts\x20on\x20concatenation\x20of\
    \x20type\x20and\x20name.\n\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\x86\x08\
    \x02\n\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\x86\x08\x0b\x11\n\r\n\x05\
    \x04\x19\x02\x01\x01\x12\x04\x86\x08\x12\x16\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\x86\x08\x19\x1a\n\x96\x02\n\x04\x04\x19\x02\x02\x12\x04\x8c\
    \x08\x021\x1a\x87\x02\x20A\x20list\x20of\x20container\x20configurations\
    \x20to\x20run\x20CSI\x20plugin\x20components.\n\x20The\x20controller\x20\
    service\x20will\x20be\x20served\x20by\x20the\x20first\x20configuration\n\
    \x20that\x20contains\x20`CONTROLLER_SERVICE`,\x20and\x20the\x20node\x20s\
    ervice\x20will\x20be\n\x20served\x20by\x20the\x20first\x20configuration\
    \x20that\x20contains\x20`NODE_SERVICE`.\n\n\r\n\x05\x04\x19\x02\x02\x04\
    \x12\x04\x8c\x08\x02\n\n\r\n\x05\x04\x19\x02\x02\x06\x12\x04\x8c\x08\x0b\
    !\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\x8c\x08\",\n\r\n\x05\x04\x19\x02\
    \x02\x03\x12\x04\x8c\x08/0\n\xd1\x01\n\x02\x04\x1a\x12\x06\x95\x08\0\xba\
    \x08\x01\x1a\xc2\x01*\n\x20Describes\x20a\x20resource\x20provider.\x20No\
    te\x20that\x20the\x20'id'\x20field\x20is\x20only\x20available\n\x20after\
    \x20a\x20resource\x20provider\x20is\x20registered\x20with\x20the\x20mast\
    er,\x20and\x20is\x20made\n\x20available\x20here\x20to\x20facilitate\x20r\
    e-registration.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\x95\x08\x08\x1c\n\x0c\
    \n\x04\x04\x1a\x02\0\x12\x04\x96\x08\x02%\n\r\n\x05\x04\x1a\x02\0\x04\
    \x12\x04\x96\x08\x02\n\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\x96\x08\x0b\
    \x1d\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x96\x08\x1e\x20\n\r\n\x05\x04\
    \x1a\x02\0\x03\x12\x04\x96\x08#$\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\x97\
    \x08\x02$\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\x97\x08\x02\n\n\r\n\x05\
    \x04\x1a\x02\x01\x06\x12\x04\x97\x08\x0b\x14\n\r\n\x05\x04\x1a\x02\x01\
    \x01\x12\x04\x97\x08\x15\x1f\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\x97\
    \x08\"#\n\xc4\x02\n\x04\x04\x1a\x02\x02\x12\x04\xa0\x08\x02\x1b\x1a\xb5\
    \x02\x20The\x20type\x20of\x20the\x20resource\x20provider.\x20This\x20uni\
    quely\x20identifies\x20a\n\x20resource\x20provider\x20implementation.\
    \x20For\x20instance:\n\x20\x20\x20\x20\x20org.apache.mesos.rp.local.stor\
    age\n\n\x20Please\x20follow\x20to\x20Java\x20package\x20naming\x20conven\
    tion\n\x20(https://en.wikipedia.org/wiki/Java_package#Package_naming_con\
    ventions)\n\x20to\x20avoid\x20conflicts\x20on\x20type\x20names.\n\n\r\n\
    \x05\x04\x1a\x02\x02\x04\x12\x04\xa0\x08\x02\n\n\r\n\x05\x04\x1a\x02\x02\
    \x05\x12\x04\xa0\x08\x0b\x11\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xa0\
    \x08\x12\x16\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xa0\x08\x19\x1a\n\xd6\
    \x02\n\x04\x04\x1a\x02\x03\x12\x04\xa7\x08\x02\x1b\x1a\xc7\x02\x20The\
    \x20name\x20of\x20the\x20resource\x20provider.\x20There\x20could\x20be\
    \x20multiple\n\x20instances\x20of\x20a\x20type\x20of\x20resource\x20prov\
    ider.\x20The\x20name\x20field\x20is\x20used\n\x20to\x20distinguish\x20th\
    ese\x20instances.\x20It\x20should\x20be\x20a\x20legal\x20Java\x20identif\
    ier\n\x20(https://docs.oracle.com/javase/tutorial/java/nutsandbolts/vari\
    ables.html)\n\x20to\x20avoid\x20conflicts\x20on\x20concatenation\x20of\
    \x20type\x20and\x20name.\n\n\r\n\x05\x04\x1a\x02\x03\x04\x12\x04\xa7\x08\
    \x02\n\n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\xa7\x08\x0b\x11\n\r\n\x05\
    \x04\x1a\x02\x03\x01\x12\x04\xa7\x08\x12\x16\n\r\n\x05\x04\x1a\x02\x03\
    \x03\x12\x04\xa7\x08\x19\x1a\n\xe0\x04\n\x04\x04\x1a\x02\x04\x12\x04\xb2\
    \x08\x02=\x1a\xc0\x04\x20The\x20stack\x20of\x20default\x20reservations.\
    \x20If\x20this\x20field\x20is\x20not\x20empty,\x20it\n\x20indicates\x20t\
    hat\x20resources\x20from\x20this\x20resource\x20provider\x20are\x20reser\
    ved\n\x20by\x20default,\x20except\x20for\x20the\x20resources\x20that\x20\
    have\x20been\x20reserved\x20or\n\x20unreserved\x20through\x20operations.\
    \x20The\x20first\x20`ReservationInfo`\n\x20may\x20have\x20type\x20`STATI\
    C`\x20or\x20`DYNAMIC`,\x20but\x20the\x20rest\x20must\x20have\n\x20`DYNAM\
    IC`.\x20One\x20can\x20create\x20a\x20new\x20reservation\x20on\x20top\x20\
    of\x20an\x20existing\n\x20one\x20by\x20pushing\x20a\x20new\x20`Reservati\
    onInfo`\x20to\x20the\x20back.\x20The\x20last\n\x20`ReservationInfo`\x20i\
    n\x20this\x20stack\x20is\x20the\x20\"current\"\x20reservation.\x20The\n\
    \x20new\x20reservation's\x20role\x20must\x20be\x20a\x20child\x20of\x20th\
    e\x20current\x20one.\n\"\x0f\x20EXPERIMENTAL.\n\n\r\n\x05\x04\x1a\x02\
    \x04\x04\x12\x04\xb2\x08\x02\n\n\r\n\x05\x04\x1a\x02\x04\x06\x12\x04\xb2\
    \x08\x0b#\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xb2\x08$8\n\r\n\x05\x04\
    \x1a\x02\x04\x03\x12\x04\xb2\x08;<\n@\n\x04\x04\x1a\x03\0\x12\x06\xb5\
    \x08\x02\xb7\x08\x03\x1a0\x20Storage\x20resource\x20provider\x20related\
    \x20information.\n\n\r\n\x05\x04\x1a\x03\0\x01\x12\x04\xb5\x08\n\x11\n\
    \x0e\n\x06\x04\x1a\x03\0\x02\0\x12\x04\xb6\x08\x04&\n\x0f\n\x07\x04\x1a\
    \x03\0\x02\0\x04\x12\x04\xb6\x08\x04\x0c\n\x0f\n\x07\x04\x1a\x03\0\x02\0\
    \x06\x12\x04\xb6\x08\r\x1a\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x01\x12\x04\
    \xb6\x08\x1b!\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x03\x12\x04\xb6\x08$%\n\
    \x1d\n\x04\x04\x1a\x02\x05\x12\x04\xb9\x08\x02\x1f\"\x0f\x20EXPERIMENTAL\
    .\n\n\r\n\x05\x04\x1a\x02\x05\x04\x12\x04\xb9\x08\x02\n\n\r\n\x05\x04\
    \x1a\x02\x05\x06\x12\x04\xb9\x08\x0b\x12\n\r\n\x05\x04\x1a\x02\x05\x01\
    \x12\x04\xb9\x08\x13\x1a\n\r\n\x05\x04\x1a\x02\x05\x03\x12\x04\xb9\x08\
    \x1d\x1e\n\x85\x01\n\x02\x04\x1b\x12\x06\xc1\x08\0\xeb\x08\x01\x1aw*\n\
    \x20Describes\x20an\x20Attribute\x20or\x20Resource\x20\"value\".\x20A\
    \x20value\x20is\x20described\n\x20using\x20the\x20standard\x20protocol\
    \x20buffer\x20\"union\"\x20trick.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xc1\
    \x08\x08\r\n\x0e\n\x04\x04\x1b\x04\0\x12\x06\xc2\x08\x02\xc7\x08\x03\n\r\
    \n\x05\x04\x1b\x04\0\x01\x12\x04\xc2\x08\x07\x0b\n\x0e\n\x06\x04\x1b\x04\
    \0\x02\0\x12\x04\xc3\x08\x04\x0f\n\x0f\n\x07\x04\x1b\x04\0\x02\0\x01\x12\
    \x04\xc3\x08\x04\n\n\x0f\n\x07\x04\x1b\x04\0\x02\0\x02\x12\x04\xc3\x08\r\
    \x0e\n\x0e\n\x06\x04\x1b\x04\0\x02\x01\x12\x04\xc4\x08\x04\x0f\n\x0f\n\
    \x07\x04\x1b\x04\0\x02\x01\x01\x12\x04\xc4\x08\x04\n\n\x0f\n\x07\x04\x1b\
    \x04\0\x02\x01\x02\x12\x04\xc4\x08\r\x0e\n\x0e\n\x06\x04\x1b\x04\0\x02\
    \x02\x12\x04\xc5\x08\x04\x0c\n\x0f\n\x07\x04\x1b\x04\0\x02\x02\x01\x12\
    \x04\xc5\x08\x04\x07\n\x0f\n\x07\x04\x1b\x04\0\x02\x02\x02\x12\x04\xc5\
    \x08\n\x0b\n\x0e\n\x06\x04\x1b\x04\0\x02\x03\x12\x04\xc6\x08\x04\r\n\x0f\
    \n\x07\x04\x1b\x04\0\x02\x03\x01\x12\x04\xc6\x08\x04\x08\n\x0f\n\x07\x04\
    \x1b\x04\0\x02\x03\x02\x12\x04\xc6\x08\x0b\x0c\n\x0e\n\x04\x04\x1b\x03\0\
    \x12\x06\xc9\x08\x02\xd3\x08\x03\n\r\n\x05\x04\x1b\x03\0\x01\x12\x04\xc9\
    \x08\n\x10\n\xef\x03\n\x06\x04\x1b\x03\0\x02\0\x12\x04\xd2\x08\x04\x1e\
    \x1a\xde\x03\x20Scalar\x20values\x20are\x20represented\x20using\x20float\
    ing\x20point.\x20To\x20reduce\n\x20the\x20chance\x20of\x20unpredictable\
    \x20floating\x20point\x20behavior\x20due\x20to\n\x20roundoff\x20error,\
    \x20Mesos\x20only\x20supports\x20three\x20decimal\x20digits\x20of\n\x20p\
    recision\x20for\x20scalar\x20resource\x20values.\x20That\x20is,\x20float\
    ing\x20point\n\x20values\x20are\x20converted\x20to\x20a\x20fixed\x20poin\
    t\x20format\x20that\x20supports\n\x20three\x20decimal\x20digits\x20of\
    \x20precision,\x20and\x20then\x20converted\x20back\x20to\n\x20floating\
    \x20point\x20on\x20output.\x20Any\x20additional\x20precision\x20in\x20sc\
    alar\n\x20resource\x20values\x20is\x20discarded\x20(via\x20rounding).\n\
    \n\x0f\n\x07\x04\x1b\x03\0\x02\0\x04\x12\x04\xd2\x08\x04\x0c\n\x0f\n\x07\
    \x04\x1b\x03\0\x02\0\x05\x12\x04\xd2\x08\r\x13\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\0\x01\x12\x04\xd2\x08\x14\x19\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x03\
    \x12\x04\xd2\x08\x1c\x1d\n\x0e\n\x04\x04\x1b\x03\x01\x12\x06\xd5\x08\x02\
    \xd8\x08\x03\n\r\n\x05\x04\x1b\x03\x01\x01\x12\x04\xd5\x08\n\x0f\n\x0e\n\
    \x06\x04\x1b\x03\x01\x02\0\x12\x04\xd6\x08\x04\x1e\n\x0f\n\x07\x04\x1b\
    \x03\x01\x02\0\x04\x12\x04\xd6\x08\x04\x0c\n\x0f\n\x07\x04\x1b\x03\x01\
    \x02\0\x05\x12\x04\xd6\x08\r\x13\n\x0f\n\x07\x04\x1b\x03\x01\x02\0\x01\
    \x12\x04\xd6\x08\x14\x19\n\x0f\n\x07\x04\x1b\x03\x01\x02\0\x03\x12\x04\
    \xd6\x08\x1c\x1d\n\x0e\n\x06\x04\x1b\x03\x01\x02\x01\x12\x04\xd7\x08\x04\
    \x1c\n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\x04\x12\x04\xd7\x08\x04\x0c\n\
    \x0f\n\x07\x04\x1b\x03\x01\x02\x01\x05\x12\x04\xd7\x08\r\x13\n\x0f\n\x07\
    \x04\x1b\x03\x01\x02\x01\x01\x12\x04\xd7\x08\x14\x17\n\x0f\n\x07\x04\x1b\
    \x03\x01\x02\x01\x03\x12\x04\xd7\x08\x1a\x1b\n\x0e\n\x04\x04\x1b\x03\x02\
    \x12\x06\xda\x08\x02\xdc\x08\x03\n\r\n\x05\x04\x1b\x03\x02\x01\x12\x04\
    \xda\x08\n\x10\n\x0e\n\x06\x04\x1b\x03\x02\x02\0\x12\x04\xdb\x08\x04\x1d\
    \n\x0f\n\x07\x04\x1b\x03\x02\x02\0\x04\x12\x04\xdb\x08\x04\x0c\n\x0f\n\
    \x07\x04\x1b\x03\x02\x02\0\x06\x12\x04\xdb\x08\r\x12\n\x0f\n\x07\x04\x1b\
    \x03\x02\x02\0\x01\x12\x04\xdb\x08\x13\x18\n\x0f\n\x07\x04\x1b\x03\x02\
    \x02\0\x03\x12\x04\xdb\x08\x1b\x1c\n\x0e\n\x04\x04\x1b\x03\x03\x12\x06\
    \xde\x08\x02\xe0\x08\x03\n\r\n\x05\x04\x1b\x03\x03\x01\x12\x04\xde\x08\n\
    \r\n\x0e\n\x06\x04\x1b\x03\x03\x02\0\x12\x04\xdf\x08\x04\x1d\n\x0f\n\x07\
    \x04\x1b\x03\x03\x02\0\x04\x12\x04\xdf\x08\x04\x0c\n\x0f\n\x07\x04\x1b\
    \x03\x03\x02\0\x05\x12\x04\xdf\x08\r\x13\n\x0f\n\x07\x04\x1b\x03\x03\x02\
    \0\x01\x12\x04\xdf\x08\x14\x18\n\x0f\n\x07\x04\x1b\x03\x03\x02\0\x03\x12\
    \x04\xdf\x08\x1b\x1c\n\x0e\n\x04\x04\x1b\x03\x04\x12\x06\xe2\x08\x02\xe4\
    \x08\x03\n\r\n\x05\x04\x1b\x03\x04\x01\x12\x04\xe2\x08\n\x0e\n\x0e\n\x06\
    \x04\x1b\x03\x04\x02\0\x12\x04\xe3\x08\x04\x1e\n\x0f\n\x07\x04\x1b\x03\
    \x04\x02\0\x04\x12\x04\xe3\x08\x04\x0c\n\x0f\n\x07\x04\x1b\x03\x04\x02\0\
    \x05\x12\x04\xe3\x08\r\x13\n\x0f\n\x07\x04\x1b\x03\x04\x02\0\x01\x12\x04\
    \xe3\x08\x14\x19\n\x0f\n\x07\x04\x1b\x03\x04\x02\0\x03\x12\x04\xe3\x08\
    \x1c\x1d\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xe6\x08\x02\x19\n\r\n\x05\x04\
    \x1b\x02\0\x04\x12\x04\xe6\x08\x02\n\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\
    \xe6\x08\x0b\x0f\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xe6\x08\x10\x14\n\r\
    \n\x05\x04\x1b\x02\0\x03\x12\x04\xe6\x08\x17\x18\n\x0c\n\x04\x04\x1b\x02\
    \x01\x12\x04\xe7\x08\x02\x1d\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xe7\
    \x08\x02\n\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xe7\x08\x0b\x11\n\r\n\
    \x05\x04\x1b\x02\x01\x01\x12\x04\xe7\x08\x12\x18\n\r\n\x05\x04\x1b\x02\
    \x01\x03\x12\x04\xe7\x08\x1b\x1c\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xe8\
    \x08\x02\x1d\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\xe8\x08\x02\n\n\r\n\
    \x05\x04\x1b\x02\x02\x06\x12\x04\xe8\x08\x0b\x11\n\r\n\x05\x04\x1b\x02\
    \x02\x01\x12\x04\xe8\x08\x12\x18\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\
    \xe8\x08\x1b\x1c\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xe9\x08\x02\x17\n\r\
    \n\x05\x04\x1b\x02\x03\x04\x12\x04\xe9\x08\x02\n\n\r\n\x05\x04\x1b\x02\
    \x03\x06\x12\x04\xe9\x08\x0b\x0e\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\
    \xe9\x08\x0f\x12\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xe9\x08\x15\x16\n\
    \x0c\n\x04\x04\x1b\x02\x04\x12\x04\xea\x08\x02\x19\n\r\n\x05\x04\x1b\x02\
    \x04\x04\x12\x04\xea\x08\x02\n\n\r\n\x05\x04\x1b\x02\x04\x06\x12\x04\xea\
    \x08\x0b\x0f\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xea\x08\x10\x14\n\r\n\
    \x05\x04\x1b\x02\x04\x03\x12\x04\xea\x08\x17\x18\n\xd3\x01\n\x02\x04\x1c\
    \x12\x06\xf3\x08\0\xfa\x08\x01\x1a\xc4\x01*\n\x20Describes\x20an\x20attr\
    ibute\x20that\x20can\x20be\x20set\x20on\x20a\x20machine.\x20For\x20now,\
    \n\x20attributes\x20and\x20resources\x20share\x20the\x20same\x20\"value\
    \"\x20type,\x20but\x20this\x20may\n\x20change\x20in\x20the\x20future\x20\
    and\x20attributes\x20may\x20only\x20be\x20string\x20based.\n\n\x0b\n\x03\
    \x04\x1c\x01\x12\x04\xf3\x08\x08\x11\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\
    \xf4\x08\x02\x1b\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xf4\x08\x02\n\n\r\n\
    \x05\x04\x1c\x02\0\x05\x12\x04\xf4\x08\x0b\x11\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\xf4\x08\x12\x16\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xf4\x08\
    \x19\x1a\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xf5\x08\x02\x1f\n\r\n\x05\
    \x04\x1c\x02\x01\x04\x12\x04\xf5\x08\x02\n\n\r\n\x05\x04\x1c\x02\x01\x06\
    \x12\x04\xf5\x08\x0b\x15\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xf5\x08\
    \x16\x1a\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xf5\x08\x1d\x1e\n\x0c\n\
    \x04\x04\x1c\x02\x02\x12\x04\xf6\x08\x02#\n\r\n\x05\x04\x1c\x02\x02\x04\
    \x12\x04\xf6\x08\x02\n\n\r\n\x05\x04\x1c\x02\x02\x06\x12\x04\xf6\x08\x0b\
    \x17\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xf6\x08\x18\x1e\n\r\n\x05\x04\
    \x1c\x02\x02\x03\x12\x04\xf6\x08!\"\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\
    \xf7\x08\x02#\n\r\n\x05\x04\x1c\x02\x03\x04\x12\x04\xf7\x08\x02\n\n\r\n\
    \x05\x04\x1c\x02\x03\x06\x12\x04\xf7\x08\x0b\x17\n\r\n\x05\x04\x1c\x02\
    \x03\x01\x12\x04\xf7\x08\x18\x1e\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\
    \xf7\x08!\"\n\x0c\n\x04\x04\x1c\x02\x04\x12\x04\xf8\x08\x02\x1d\n\r\n\
    \x05\x04\x1c\x02\x04\x04\x12\x04\xf8\x08\x02\n\n\r\n\x05\x04\x1c\x02\x04\
    \x06\x12\x04\xf8\x08\x0b\x14\n\r\n\x05\x04\x1c\x02\x04\x01\x12\x04\xf8\
    \x08\x15\x18\n\r\n\x05\x04\x1c\x02\x04\x03\x12\x04\xf8\x08\x1b\x1c\n\x0c\
    \n\x04\x04\x1c\x02\x05\x12\x04\xf9\x08\x02\x1f\n\r\n\x05\x04\x1c\x02\x05\
    \x04\x12\x04\xf9\x08\x02\n\n\r\n\x05\x04\x1c\x02\x05\x06\x12\x04\xf9\x08\
    \x0b\x15\n\r\n\x05\x04\x1c\x02\x05\x01\x12\x04\xf9\x08\x16\x1a\n\r\n\x05\
    \x04\x1c\x02\x05\x03\x12\x04\xf9\x08\x1d\x1e\n\xf1\x04\n\x02\x04\x1d\x12\
    \x06\x8a\t\0\xcb\x0b\x01\x1a\xe2\x04*\n\x20Describes\x20a\x20resource\
    \x20from\x20a\x20resource\x20provider.\x20The\x20`name`\x20field\x20is\n\
    \x20a\x20string\x20like\x20\"cpus\"\x20or\x20\"mem\"\x20that\x20indicate\
    s\x20which\x20kind\x20of\x20resource\n\x20this\x20is;\x20the\x20rest\x20\
    of\x20the\x20fields\x20describe\x20the\x20properties\x20of\x20the\n\x20r\
    esource.\x20A\x20resource\x20can\x20take\x20on\x20one\x20of\x20three\x20\
    types:\x20scalar\n\x20(double),\x20a\x20list\x20of\x20finite\x20and\x20d\
    iscrete\x20ranges\x20(e.g.,\x20[1-10,\n\x2020-30]),\x20or\x20a\x20set\
    \x20of\x20items.\x20A\x20resource\x20is\x20described\x20using\x20the\n\
    \x20standard\x20protocol\x20buffer\x20\"union\"\x20trick.\n\n\x20Note\
    \x20that\x20\"disk\"\x20and\x20\"mem\"\x20resources\x20are\x20scalar\x20\
    values\x20expressed\x20in\n\x20megabytes.\x20Fractional\x20\"cpus\"\x20v\
    alues\x20are\x20allowed\x20(e.g.,\x20\"0.5\"),\n\x20which\x20correspond\
    \x20to\x20partial\x20shares\x20of\x20a\x20CPU.\n\n\x0b\n\x03\x04\x1d\x01\
    \x12\x04\x8a\t\x08\x10\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\x8b\t\x02/\n\r\
    \n\x05\x04\x1d\x02\0\x04\x12\x04\x8b\t\x02\n\n\r\n\x05\x04\x1d\x02\0\x06\
    \x12\x04\x8b\t\x0b\x1d\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x8b\t\x1e)\n\
    \r\n\x05\x04\x1d\x02\0\x03\x12\x04\x8b\t,.\n\x0c\n\x04\x04\x1d\x02\x01\
    \x12\x04\x8d\t\x02\x1b\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\x8d\t\x02\n\
    \n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\x8d\t\x0b\x11\n\r\n\x05\x04\x1d\
    \x02\x01\x01\x12\x04\x8d\t\x12\x16\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\
    \x8d\t\x19\x1a\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\x8e\t\x02\x1f\n\r\n\
    \x05\x04\x1d\x02\x02\x04\x12\x04\x8e\t\x02\n\n\r\n\x05\x04\x1d\x02\x02\
    \x06\x12\x04\x8e\t\x0b\x15\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\x8e\t\
    \x16\x1a\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x8e\t\x1d\x1e\n\x0c\n\x04\
    \x04\x1d\x02\x03\x12\x04\x8f\t\x02#\n\r\n\x05\x04\x1d\x02\x03\x04\x12\
    \x04\x8f\t\x02\n\n\r\n\x05\x04\x1d\x02\x03\x06\x12\x04\x8f\t\x0b\x17\n\r\
    \n\x05\x04\x1d\x02\x03\x01\x12\x04\x8f\t\x18\x1e\n\r\n\x05\x04\x1d\x02\
    \x03\x03\x12\x04\x8f\t!\"\n\x0c\n\x04\x04\x1d\x02\x04\x12\x04\x90\t\x02#\
    \n\r\n\x05\x04\x1d\x02\x04\x04\x12\x04\x90\t\x02\n\n\r\n\x05\x04\x1d\x02\
    \x04\x06\x12\x04\x90\t\x0b\x17\n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\x90\
    \t\x18\x1e\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\x90\t!\"\n\x0c\n\x04\
    \x04\x1d\x02\x05\x12\x04\x91\t\x02\x1d\n\r\n\x05\x04\x1d\x02\x05\x04\x12\
    \x04\x91\t\x02\n\n\r\n\x05\x04\x1d\x02\x05\x06\x12\x04\x91\t\x0b\x14\n\r\
    \n\x05\x04\x1d\x02\x05\x01\x12\x04\x91\t\x15\x18\n\r\n\x05\x04\x1d\x02\
    \x05\x03\x12\x04\x91\t\x1b\x1c\n\x94\x03\n\x04\x04\x1d\x02\x06\x12\x04\
    \x9b\t\x02<\x1a\x85\x03\x20The\x20role\x20that\x20this\x20resource\x20is\
    \x20reserved\x20for.\x20If\x20\"*\",\x20this\x20indicates\n\x20that\x20t\
    he\x20resource\x20is\x20unreserved.\x20Otherwise,\x20the\x20resource\x20\
    will\x20only\n\x20be\x20offered\x20to\x20frameworks\x20that\x20belong\
    \x20to\x20this\x20role.\n\n\x20NOTE:\x20Frameworks\x20must\x20not\x20set\
    \x20this\x20field\x20if\x20`reservations`\x20is\x20set.\n\x20\x20\x20\
    \x20\x20\x20\x20See\x20the\x20'Resource\x20Format'\x20section\x20for\x20\
    more\x20details.\n\n\x20TODO(mpark):\x20Deprecate\x20once\x20`reservatio\
    ns`\x20is\x20no\x20longer\x20experimental.\n\n\r\n\x05\x04\x1d\x02\x06\
    \x04\x12\x04\x9b\t\x02\n\n\r\n\x05\x04\x1d\x02\x06\x05\x12\x04\x9b\t\x0b\
    \x11\n\r\n\x05\x04\x1d\x02\x06\x01\x12\x04\x9b\t\x12\x16\n\r\n\x05\x04\
    \x1d\x02\x06\x03\x12\x04\x9b\t\x19\x1a\n\r\n\x05\x04\x1d\x02\x06\x08\x12\
    \x04\x9b\t\x1b;\n\r\n\x05\x04\x1d\x02\x06\x07\x12\x04\x9b\t&)\n\x10\n\
    \x08\x04\x1d\x02\x06\x08\xe7\x07\0\x12\x04\x9b\t+:\n\x11\n\t\x04\x1d\x02\
    \x06\x08\xe7\x07\0\x02\x12\x04\x9b\t+5\n\x12\n\n\x04\x1d\x02\x06\x08\xe7\
    \x07\0\x02\0\x12\x04\x9b\t+5\n\x13\n\x0b\x04\x1d\x02\x06\x08\xe7\x07\0\
    \x02\0\x01\x12\x04\x9b\t+5\n\x11\n\t\x04\x1d\x02\x06\x08\xe7\x07\0\x03\
    \x12\x04\x9b\t6:\n\xd7\x01\n\x04\x04\x1d\x03\0\x12\x06\xa1\t\x02\xa9\t\
    \x03\x1a\xc6\x01\x20This\x20was\x20initially\x20introduced\x20to\x20supp\
    ort\x20MULTI_ROLE\x20capable\n\x20frameworks.\x20Frameworks\x20that\x20a\
    re\x20not\x20MULTI_ROLE\x20capable\x20can\n\x20continue\x20to\x20assume\
    \x20that\x20the\x20offered\x20resources\x20are\x20allocated\n\x20to\x20t\
    heir\x20role.\n\n\r\n\x05\x04\x1d\x03\0\x01\x12\x04\xa1\t\n\x18\n\xb6\
    \x01\n\x06\x04\x1d\x03\0\x02\0\x12\x04\xa5\t\x04\x1d\x1a\xa5\x01\x20If\
    \x20set,\x20this\x20resource\x20is\x20allocated\x20to\x20a\x20role.\x20N\
    ote\x20that\x20in\x20the\n\x20future,\x20this\x20may\x20be\x20unset\x20a\
    nd\x20the\x20scheduler\x20may\x20be\x20responsible\n\x20for\x20allocatin\
    g\x20to\x20one\x20of\x20its\x20roles.\n\n\x0f\n\x07\x04\x1d\x03\0\x02\0\
    \x04\x12\x04\xa5\t\x04\x0c\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\
    \xa5\t\r\x13\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x01\x12\x04\xa5\t\x14\x18\n\
    \x0f\n\x07\x04\x1d\x03\0\x02\0\x03\x12\x04\xa5\t\x1b\x1c\n\x0c\n\x04\x04\
    \x1d\x02\x07\x12\x04\xab\t\x02/\n\r\n\x05\x04\x1d\x02\x07\x04\x12\x04\
    \xab\t\x02\n\n\r\n\x05\x04\x1d\x02\x07\x06\x12\x04\xab\t\x0b\x19\n\r\n\
    \x05\x04\x1d\x02\x07\x01\x12\x04\xab\t\x1a)\n\r\n\x05\x04\x1d\x02\x07\
    \x03\x12\x04\xab\t,.\n\xd09\n\x04\x04\x1d\x03\x01\x12\x06\x95\n\x02\xc0\
    \n\x03\"\x92\x03\x20Describes\x20a\x20reservation.\x20A\x20static\x20res\
    ervation\x20is\x20set\x20by\x20the\x20operator\x20on\n\x20the\x20command\
    -line\x20and\x20they\x20are\x20immutable\x20without\x20agent\x20restart.\
    \x20A\x20dynamic\n\x20reservation\x20is\x20made\x20by\x20an\x20operator\
    \x20via\x20the\x20'/reserve'\x20HTTP\x20endpoint\n\x20or\x20by\x20a\x20f\
    ramework\x20via\x20the\x20offer\x20cycle\x20by\x20sending\x20back\x20an\
    \n\x20'Offer::Operation::Reserve'\x20message.\n\n\x20NOTE:\x20We\x20curr\
    ently\x20do\x20not\x20allow\x20frameworks\x20with\x20role\x20\"*\"\x20to\
    \x20make\x20dynamic\n\x20reservations.\n2\xaa6\x20Resource\x20Format:\n\
    \n\x20Frameworks\x20receive\x20resource\x20offers\x20in\x20one\x20of\x20\
    two\x20formats,\x20depending\x20on\n\x20whether\x20the\x20RESERVATION_RE\
    FINEMENT\x20capability\x20is\x20enabled.\n\n\x20__WITHOUT__\x20the\x20RE\
    SERVATION_REFINEMENT\x20capability,\x20the\x20framework\x20is\x20offered\
    \n\x20resources\x20in\x20the\x20\"pre-reservation-refinement\"\x20format\
    .\x20In\x20this\x20format,\x20the\n\x20`Resource.role`\x20and\x20`Resour\
    ce.reservation`\x20fields\x20are\x20used\x20in\x20conjunction\n\x20to\
    \x20describe\x20the\x20reservation\x20state\x20of\x20a\x20`Resource`\x20\
    message.\n\n\x20The\x20following\x20is\x20an\x20overview\x20of\x20the\
    \x20possible\x20reservation\x20states:\n\n\x20+------------+------------\
    ------------------------------------------------+\n\x20|\x20unreserved\
    \x20|\x20{\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\x20\x20\x20role:\x20\"*\",\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\
    \x20\x20\x20reservation:\x20<not\x20set>,\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20reservations:\x20<unused>\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20}\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20+\
    ------------+-----------------------------------------------------------\
    -+\n\x20|\x20static\x20\x20\x20\x20\x20|\x20{\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20role:\x20\"\
    eng\",\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20reservation:\x20<not\x20set>,\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20reservation\
    s:\x20<unused>\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\
    \x20}\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20|\n\x20+------------+---------------------------\
    ---------------------------------+\n\x20|\x20dynamic\x20\x20\x20\x20|\
    \x20{\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20|\x20\x20\x20role:\x20\"eng\",\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\
    \x20reservation:\x20{\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20type:\x20<unuse\
    d>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20role:\x20<unused>,\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20princip\
    al:\x20<optional>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\
    \x20\x20\x20\x20labels:\x20<optional>\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20},\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20reservations:\x20<unused>\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20}\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\n\x20+------------+-----------------------------------------------\
    -------------+\n\n\x20__WITH__\x20the\x20RESERVATION_REFINEMENT\x20capab\
    ility,\x20the\x20framework\x20is\x20offered\n\x20resources\x20in\x20the\
    \x20\"post-reservation-refinement\"\x20format.\x20In\x20this\x20format,\
    \x20the\n\x20reservation\x20state\x20of\x20a\x20`Resource`\x20message\
    \x20is\x20expressed\x20solely\x20in\n\x20`Resource.reservations`\x20fiel\
    d.\n\n\x20The\x20following\x20is\x20an\x20overview\x20of\x20the\x20possi\
    ble\x20reservation\x20states:\n\n\x20+------------+---------------------\
    ---------------------------------------+\n\x20|\x20unreserved\x20|\x20{\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\x20\x20\x20role:\x20<unused>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20reservation:\x20<un\
    used>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\
    \x20reservations:\x20[]\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20}\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20+------------\
    +------------------------------------------------------------+\n\x20|\
    \x20static\x20\x20\x20\x20\x20|\x20{\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20role:\x20<unused>,\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20reservation:\x20<unused>,\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20|\x20\x20\x20reservations:\x20[\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\
    \x20\x20\x20\x20{\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20\x20\x20type:\x20STATIC,\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\
    \x20\x20\x20role:\x20\"eng\",\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20princip\
    al:\x20<optional>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\
    \x20\x20\x20\x20labels:\x20<optional>\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20}\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20]\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20}\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20+----\
    --------+------------------------------------------------------------+\n\
    \x20|\x20dynamic\x20\x20\x20\x20|\x20{\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20role:\x20<unused>,\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20|\x20\x20\x20reservation:\x20<unused>,\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20reservations:\x20[\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\
    \x20\x20\x20\x20\x20{\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20|\x20\x20\x20\x20\x20\x20\x20type:\x20DYNAMIC,\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\
    \x20\x20\x20role:\x20\"eng\",\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20princip\
    al:\x20<optional>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\
    \x20\x20\x20\x20labels:\x20<optional>\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20}\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20]\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20}\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20+----\
    --------+------------------------------------------------------------+\n\
    \n\x20We\x20can\x20also\x20__refine__\x20reservations\x20with\x20this\
    \x20capability\x20like\x20so:\n\n\x20+------------+---------------------\
    ---------------------------------------+\n\x20|\x20refined\x20\x20\x20\
    \x20|\x20{\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\x20\x20\x20role:\x20<unused>,\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20reserv\
    ation:\x20<unused>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\x20\x20\x20reservations:\x20[\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20{\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\
    \x20\x20type:\x20STATIC\x20or\x20DYNAMIC,\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\x20\x20\x20\x20\x20\x20\x20role:\x20\"eng\",\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\
    \x20\x20\x20principal:\x20<optional>,\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20\x20\x20labels:\x20<optional>\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20},\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20{\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\
    \x20\x20type:\x20DYNAMIC,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20role:\x20\"eng/fron\
    t_end\",\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20principal:\x20<optional>,\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\n\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\
    \x20\x20\x20\x20\x20\x20\x20labels:\x20<optional>\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20}\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20]\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20|\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20}\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\n\x20+------------+---------------------------------------------------\
    ---------+\n\n\x20NOTE:\x20Each\x20`ReservationInfo`\x20in\x20the\x20`re\
    servations`\x20field\x20denotes\n\x20\x20\x20\x20\x20\x20\x20a\x20reserv\
    ation\x20that\x20refines\x20the\x20previous\x20`ReservationInfo`.\n\n\r\
    \n\x05\x04\x1d\x03\x01\x01\x12\x04\x95\n\n\x19\n\x10\n\x06\x04\x1d\x03\
    \x01\x04\0\x12\x06\x9f\n\x04\xa3\n\x05\n\x0f\n\x07\x04\x1d\x03\x01\x04\0\
    \x01\x12\x04\x9f\n\t\r\n\x10\n\x08\x04\x1d\x03\x01\x04\0\x02\0\x12\x04\
    \xa0\n\x06\x12\n\x11\n\t\x04\x1d\x03\x01\x04\0\x02\0\x01\x12\x04\xa0\n\
    \x06\r\n\x11\n\t\x04\x1d\x03\x01\x04\0\x02\0\x02\x12\x04\xa0\n\x10\x11\n\
    \x10\n\x08\x04\x1d\x03\x01\x04\0\x02\x01\x12\x04\xa1\n\x06\x11\n\x11\n\t\
    \x04\x1d\x03\x01\x04\0\x02\x01\x01\x12\x04\xa1\n\x06\x0c\n\x11\n\t\x04\
    \x1d\x03\x01\x04\0\x02\x01\x02\x12\x04\xa1\n\x0f\x10\n\x10\n\x08\x04\x1d\
    \x03\x01\x04\0\x02\x02\x12\x04\xa2\n\x06\x12\n\x11\n\t\x04\x1d\x03\x01\
    \x04\0\x02\x02\x01\x12\x04\xa2\n\x06\r\n\x11\n\t\x04\x1d\x03\x01\x04\0\
    \x02\x02\x02\x12\x04\xa2\n\x10\x11\n\xaa\x01\n\x06\x04\x1d\x03\x01\x02\0\
    \x12\x04\xa9\n\x04\x1b\x1a\x99\x01\x20The\x20type\x20of\x20this\x20reser\
    vation.\n\n\x20NOTE:\x20This\x20field\x20must\x20not\x20be\x20set\x20for\
    \x20`Resource.reservation`.\n\x20\x20\x20\x20\x20\x20\x20See\x20the\x20'\
    Resource\x20Format'\x20section\x20for\x20more\x20details.\n\n\x0f\n\x07\
    \x04\x1d\x03\x01\x02\0\x04\x12\x04\xa9\n\x04\x0c\n\x0f\n\x07\x04\x1d\x03\
    \x01\x02\0\x06\x12\x04\xa9\n\r\x11\n\x0f\n\x07\x04\x1d\x03\x01\x02\0\x01\
    \x12\x04\xa9\n\x12\x16\n\x0f\n\x07\x04\x1d\x03\x01\x02\0\x03\x12\x04\xa9\
    \n\x19\x1a\n\xbc\x01\n\x06\x04\x1d\x03\x01\x02\x01\x12\x04\xaf\n\x04\x1d\
    \x1a\xab\x01\x20The\x20role\x20to\x20which\x20this\x20reservation\x20is\
    \x20made\x20for.\n\n\x20NOTE:\x20This\x20field\x20must\x20not\x20be\x20s\
    et\x20for\x20`Resource.reservation`.\n\x20\x20\x20\x20\x20\x20\x20See\
    \x20the\x20'Resource\x20Format'\x20section\x20for\x20more\x20details.\n\
    \n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x04\x12\x04\xaf\n\x04\x0c\n\x0f\n\
    \x07\x04\x1d\x03\x01\x02\x01\x05\x12\x04\xaf\n\r\x13\n\x0f\n\x07\x04\x1d\
    \x03\x01\x02\x01\x01\x12\x04\xaf\n\x14\x18\n\x0f\n\x07\x04\x1d\x03\x01\
    \x02\x01\x03\x12\x04\xaf\n\x1b\x1c\n\xdd\x02\n\x06\x04\x1d\x03\x01\x02\
    \x02\x12\x04\xb7\n\x04\"\x1a\xcc\x02\x20Indicates\x20the\x20principal,\
    \x20if\x20any,\x20of\x20the\x20framework\x20or\x20operator\n\x20that\x20\
    reserved\x20this\x20resource.\x20If\x20reserved\x20by\x20a\x20framework,\
    \x20the\n\x20field\x20should\x20match\x20the\x20`FrameworkInfo.principal\
    `.\x20It\x20is\x20used\x20in\n\x20conjunction\x20with\x20the\x20`Unreser\
    veResources`\x20ACL\x20to\x20determine\n\x20whether\x20the\x20entity\x20\
    attempting\x20to\x20unreserve\x20this\x20resource\x20is\n\x20permitted\
    \x20to\x20do\x20so.\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x04\x12\x04\
    \xb7\n\x04\x0c\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x05\x12\x04\xb7\n\r\
    \x13\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x01\x12\x04\xb7\n\x14\x1d\n\x0f\
    \n\x07\x04\x1d\x03\x01\x02\x02\x03\x12\x04\xb7\n\x20!\n\xd1\x02\n\x06\
    \x04\x1d\x03\x01\x02\x03\x12\x04\xbf\n\x04\x1f\x1a\xc0\x02\x20Labels\x20\
    are\x20free-form\x20key\x20value\x20pairs\x20that\x20can\x20be\x20used\
    \x20to\n\x20associate\x20arbitrary\x20metadata\x20with\x20a\x20reserved\
    \x20resource.\x20\x20For\n\x20example,\x20frameworks\x20can\x20use\x20la\
    bels\x20to\x20identify\x20the\x20intended\n\x20purpose\x20for\x20a\x20po\
    rtion\x20of\x20the\x20resources\x20the\x20framework\x20has\n\x20reserved\
    \x20at\x20a\x20given\x20agent.\x20Labels\x20should\x20not\x20contain\x20\
    duplicate\n\x20key-value\x20pairs.\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\x03\
    \x04\x12\x04\xbf\n\x04\x0c\n\x0f\n\x07\x04\x1d\x03\x01\x02\x03\x06\x12\
    \x04\xbf\n\r\x13\n\x0f\n\x07\x04\x1d\x03\x01\x02\x03\x01\x12\x04\xbf\n\
    \x14\x1a\n\x0f\n\x07\x04\x1d\x03\x01\x02\x03\x03\x12\x04\xbf\n\x1d\x1e\n\
    \x9e\x03\n\x04\x04\x1d\x02\x08\x12\x04\xca\n\x02+\x1a\x8f\x03\x20If\x20t\
    his\x20is\x20set,\x20this\x20resource\x20was\x20dynamically\x20reserved\
    \x20by\x20an\n\x20operator\x20or\x20a\x20framework.\x20Otherwise,\x20thi\
    s\x20resource\x20is\x20either\x20unreserved\n\x20or\x20statically\x20res\
    erved\x20by\x20an\x20operator\x20via\x20the\x20--resources\x20flag.\n\n\
    \x20NOTE:\x20Frameworks\x20must\x20not\x20set\x20this\x20field\x20if\x20\
    `reservations`\x20is\x20set.\n\x20\x20\x20\x20\x20\x20\x20See\x20the\x20\
    'Resource\x20Format'\x20section\x20for\x20more\x20details.\n\n\x20TODO(m\
    park):\x20Deprecate\x20once\x20`reservations`\x20is\x20no\x20longer\x20e\
    xperimental.\n\n\r\n\x05\x04\x1d\x02\x08\x04\x12\x04\xca\n\x02\n\n\r\n\
    \x05\x04\x1d\x02\x08\x06\x12\x04\xca\n\x0b\x1a\n\r\n\x05\x04\x1d\x02\x08\
    \x01\x12\x04\xca\n\x1b&\n\r\n\x05\x04\x1d\x02\x08\x03\x12\x04\xca\n)*\n\
    \xd7\x05\n\x04\x04\x1d\x02\t\x12\x04\xd8\n\x02-\x1a\xb7\x05\x20The\x20st\
    ack\x20of\x20reservations.\x20If\x20this\x20field\x20is\x20empty,\x20it\
    \x20indicates\x20that\x20this\n\x20resource\x20is\x20unreserved.\x20Othe\
    rwise,\x20the\x20resource\x20is\x20reserved.\x20The\x20first\n\x20`Reser\
    vationInfo`\x20may\x20have\x20type\x20`STATIC`\x20or\x20`DYNAMIC`,\x20bu\
    t\x20the\x20rest\x20must\n\x20have\x20`DYNAMIC`.\x20One\x20can\x20create\
    \x20a\x20new\x20reservation\x20on\x20top\x20of\x20an\x20existing\n\x20on\
    e\x20by\x20pushing\x20a\x20new\x20`ReservationInfo`\x20to\x20the\x20back\
    .\x20The\x20last\n\x20`ReservationInfo`\x20in\x20this\x20stack\x20is\x20\
    the\x20\"current\"\x20reservation.\x20The\x20new\n\x20reservation's\x20r\
    ole\x20must\x20be\x20a\x20child\x20of\x20the\x20current\x20reservation's\
    \x20role.\n\n\x20NOTE:\x20Frameworks\x20must\x20not\x20set\x20this\x20fi\
    eld\x20if\x20`reservation`\x20is\x20set.\n\x20\x20\x20\x20\x20\x20\x20Se\
    e\x20the\x20'Resource\x20Format'\x20section\x20for\x20more\x20details.\n\
    \n\x20TODO(mpark):\x20Deprecate\x20`role`\x20and\x20`reservation`\x20onc\
    e\x20this\x20is\x20stable.\n\"\x0f\x20EXPERIMENTAL.\n\n\r\n\x05\x04\x1d\
    \x02\t\x04\x12\x04\xd8\n\x02\n\n\r\n\x05\x04\x1d\x02\t\x06\x12\x04\xd8\n\
    \x0b\x1a\n\r\n\x05\x04\x1d\x02\t\x01\x12\x04\xd8\n\x1b'\n\r\n\x05\x04\
    \x1d\x02\t\x03\x12\x04\xd8\n*,\n\x0e\n\x04\x04\x1d\x03\x02\x12\x06\xda\n\
    \x02\xb5\x0b\x03\n\r\n\x05\x04\x1d\x03\x02\x01\x12\x04\xda\n\n\x12\n\xdc\
    \x02\n\x06\x04\x1d\x03\x02\x03\0\x12\x06\xe3\n\x04\xf3\n\x05\x1a\xc9\x02\
    \x20Describes\x20a\x20persistent\x20disk\x20volume.\n\n\x20A\x20persiste\
    nt\x20disk\x20volume\x20will\x20not\x20be\x20automatically\x20garbage\n\
    \x20collected\x20if\x20the\x20task/executor/agent\x20terminates,\x20but\
    \x20will\x20be\n\x20re-offered\x20to\x20the\x20framework(s)\x20belonging\
    \x20to\x20the\x20'role'.\n\n\x20NOTE:\x20Currently,\x20we\x20do\x20not\
    \x20allow\x20persistent\x20disk\x20volumes\n\x20without\x20a\x20reservat\
    ion\x20(i.e.,\x20'role'\x20cannot\x20be\x20'*').\n\n\x0f\n\x07\x04\x1d\
    \x03\x02\x03\0\x01\x12\x04\xe3\n\x0c\x17\n\xa2\x02\n\x08\x04\x1d\x03\x02\
    \x03\0\x02\0\x12\x04\xe9\n\x06\x1d\x1a\x8f\x02\x20A\x20unique\x20ID\x20f\
    or\x20the\x20persistent\x20disk\x20volume.\x20This\x20ID\x20must\x20be\n\
    \x20unique\x20per\x20role\x20on\x20each\x20agent.\x20Although\x20it\x20i\
    s\x20possible\x20to\x20use\n\x20the\x20same\x20ID\x20on\x20different\x20\
    agents\x20in\x20the\x20cluster\x20and\x20to\x20reuse\n\x20IDs\x20after\
    \x20a\x20volume\x20with\x20that\x20ID\x20has\x20been\x20destroyed,\x20bo\
    th\n\x20practices\x20are\x20discouraged.\n\n\x11\n\t\x04\x1d\x03\x02\x03\
    \0\x02\0\x04\x12\x04\xe9\n\x06\x0e\n\x11\n\t\x04\x1d\x03\x02\x03\0\x02\0\
    \x05\x12\x04\xe9\n\x0f\x15\n\x11\n\t\x04\x1d\x03\x02\x03\0\x02\0\x01\x12\
    \x04\xe9\n\x16\x18\n\x11\n\t\x04\x1d\x03\x02\x03\0\x02\0\x03\x12\x04\xe9\
    \n\x1b\x1c\n\xe0\x02\n\x08\x04\x1d\x03\x02\x03\0\x02\x01\x12\x04\xf2\n\
    \x06$\x1a\xcd\x02\x20This\x20field\x20indicates\x20the\x20principal\x20o\
    f\x20the\x20operator\x20or\n\x20framework\x20that\x20created\x20this\x20\
    volume.\x20It\x20is\x20used\x20in\x20conjunction\n\x20with\x20the\x20\"d\
    estroy\"\x20ACL\x20to\x20determine\x20whether\x20an\x20entity\n\x20attem\
    pting\x20to\x20destroy\x20the\x20volume\x20is\x20permitted\x20to\x20do\
    \x20so.\n\n\x20NOTE:\x20This\x20field\x20should\x20match\x20the\x20Frame\
    workInfo.principal\x20of\n\x20the\x20framework\x20that\x20created\x20the\
    \x20volume.\n\n\x11\n\t\x04\x1d\x03\x02\x03\0\x02\x01\x04\x12\x04\xf2\n\
    \x06\x0e\n\x11\n\t\x04\x1d\x03\x02\x03\0\x02\x01\x05\x12\x04\xf2\n\x0f\
    \x15\n\x11\n\t\x04\x1d\x03\x02\x03\0\x02\x01\x01\x12\x04\xf2\n\x16\x1f\n\
    \x11\n\t\x04\x1d\x03\x02\x03\0\x02\x01\x03\x12\x04\xf2\n\"#\n\x0e\n\x06\
    \x04\x1d\x03\x02\x02\0\x12\x04\xf5\n\x04)\n\x0f\n\x07\x04\x1d\x03\x02\
    \x02\0\x04\x12\x04\xf5\n\x04\x0c\n\x0f\n\x07\x04\x1d\x03\x02\x02\0\x06\
    \x12\x04\xf5\n\r\x18\n\x0f\n\x07\x04\x1d\x03\x02\x02\0\x01\x12\x04\xf5\n\
    \x19$\n\x0f\n\x07\x04\x1d\x03\x02\x02\0\x03\x12\x04\xf5\n'(\n\xd9\x03\n\
    \x06\x04\x1d\x03\x02\x02\x01\x12\x04\x80\x0b\x04\x1f\x1a\xc8\x03\x20Desc\
    ribes\x20how\x20this\x20disk\x20resource\x20will\x20be\x20mounted\x20in\
    \x20the\n\x20container.\x20If\x20not\x20set,\x20the\x20disk\x20resource\
    \x20will\x20be\x20used\x20as\x20the\n\x20sandbox.\x20Otherwise,\x20it\
    \x20will\x20be\x20mounted\x20according\x20to\x20the\n\x20'container_path\
    '\x20inside\x20'volume'.\x20The\x20'host_path'\x20inside\n\x20'volume'\
    \x20is\x20ignored.\n\x20NOTE:\x20If\x20'volume'\x20is\x20set\x20but\x20'\
    persistence'\x20is\x20not\x20set,\x20the\n\x20volume\x20will\x20be\x20au\
    tomatically\x20garbage\x20collected\x20after\n\x20task/executor\x20termi\
    nates.\x20Currently,\x20if\x20'persistence'\x20is\x20set,\n\x20'volume'\
    \x20must\x20be\x20set.\n\n\x0f\n\x07\x04\x1d\x03\x02\x02\x01\x04\x12\x04\
    \x80\x0b\x04\x0c\n\x0f\n\x07\x04\x1d\x03\x02\x02\x01\x06\x12\x04\x80\x0b\
    \r\x13\n\x0f\n\x07\x04\x1d\x03\x02\x02\x01\x01\x12\x04\x80\x0b\x14\x1a\n\
    \x0f\n\x07\x04\x1d\x03\x02\x02\x01\x03\x12\x04\x80\x0b\x1d\x1e\n;\n\x06\
    \x04\x1d\x03\x02\x03\x01\x12\x06\x83\x0b\x04\xb2\x0b\x05\x1a)\x20Describ\
    es\x20where\x20a\x20disk\x20originates\x20from.\n\n\x0f\n\x07\x04\x1d\
    \x03\x02\x03\x01\x01\x12\x04\x83\x0b\x0c\x12\n\x12\n\x08\x04\x1d\x03\x02\
    \x03\x01\x04\0\x12\x06\x84\x0b\x06\x8a\x0b\x07\n\x11\n\t\x04\x1d\x03\x02\
    \x03\x01\x04\0\x01\x12\x04\x84\x0b\x0b\x0f\n\x12\n\n\x04\x1d\x03\x02\x03\
    \x01\x04\0\x02\0\x12\x04\x85\x0b\x08\x14\n\x13\n\x0b\x04\x1d\x03\x02\x03\
    \x01\x04\0\x02\0\x01\x12\x04\x85\x0b\x08\x0f\n\x13\n\x0b\x04\x1d\x03\x02\
    \x03\x01\x04\0\x02\0\x02\x12\x04\x85\x0b\x12\x13\n\x12\n\n\x04\x1d\x03\
    \x02\x03\x01\x04\0\x02\x01\x12\x04\x86\x0b\x08\x11\n\x13\n\x0b\x04\x1d\
    \x03\x02\x03\x01\x04\0\x02\x01\x01\x12\x04\x86\x0b\x08\x0c\n\x13\n\x0b\
    \x04\x1d\x03\x02\x03\x01\x04\0\x02\x01\x02\x12\x04\x86\x0b\x0f\x10\n\x12\
    \n\n\x04\x1d\x03\x02\x03\x01\x04\0\x02\x02\x12\x04\x87\x0b\x08\x12\n\x13\
    \n\x0b\x04\x1d\x03\x02\x03\x01\x04\0\x02\x02\x01\x12\x04\x87\x0b\x08\r\n\
    \x13\n\x0b\x04\x1d\x03\x02\x03\x01\x04\0\x02\x02\x02\x12\x04\x87\x0b\x10\
    \x11\n\x12\n\n\x04\x1d\x03\x02\x03\x01\x04\0\x02\x03\x12\x04\x88\x0b\x08\
    \x12\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\x04\0\x02\x03\x01\x12\x04\x88\
    \x0b\x08\r\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\x04\0\x02\x03\x02\x12\x04\
    \x88\x0b\x10\x11\n\x12\n\n\x04\x1d\x03\x02\x03\x01\x04\0\x02\x04\x12\x04\
    \x89\x0b\x08\x10\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\x04\0\x02\x04\x01\
    \x12\x04\x89\x0b\x08\x0b\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\x04\0\x02\
    \x04\x02\x12\x04\x89\x0b\x0e\x0f\n\x90\x01\n\x08\x04\x1d\x03\x02\x03\x01\
    \x03\0\x12\x06\x8e\x0b\x06\x92\x0b\x07\x1a|\x20A\x20folder\x20that\x20ca\
    n\x20be\x20located\x20on\x20a\x20separate\x20disk\x20device.\x20This\n\
    \x20can\x20be\x20shared\x20and\x20carved\x20up\x20as\x20necessary\x20bet\
    ween\x20frameworks.\n\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x03\0\x01\x12\
    \x04\x8e\x0b\x0e\x12\n\x8e\x01\n\n\x04\x1d\x03\x02\x03\x01\x03\0\x02\0\
    \x12\x04\x91\x0b\x08!\x1az\x20Path\x20to\x20the\x20folder\x20(e.g.,\x20/\
    mnt/raid/disk0).\x20If\x20the\x20path\x20is\x20a\n\x20relative\x20path,\
    \x20it\x20is\x20relative\x20to\x20the\x20agent\x20work\x20directory.\n\n\
    \x13\n\x0b\x04\x1d\x03\x02\x03\x01\x03\0\x02\0\x04\x12\x04\x91\x0b\x08\
    \x10\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\x03\0\x02\0\x05\x12\x04\x91\x0b\
    \x11\x17\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\x03\0\x02\0\x01\x12\x04\x91\
    \x0b\x18\x1c\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\x03\0\x02\0\x03\x12\x04\
    \x91\x0b\x1f\x20\n\xad\x01\n\x08\x04\x1d\x03\x02\x03\x01\x03\x01\x12\x06\
    \x97\x0b\x06\x9b\x0b\x07\x1a\x98\x01\x20A\x20mounted\x20file-system\x20s\
    et\x20up\x20by\x20the\x20Agent\x20administrator.\x20This\n\x20can\x20onl\
    y\x20be\x20used\x20exclusively:\x20a\x20framework\x20cannot\x20accept\
    \x20a\n\x20partial\x20amount\x20of\x20this\x20disk.\n\n\x11\n\t\x04\x1d\
    \x03\x02\x03\x01\x03\x01\x01\x12\x04\x97\x0b\x0e\x13\n\x8f\x01\n\n\x04\
    \x1d\x03\x02\x03\x01\x03\x01\x02\0\x12\x04\x9a\x0b\x08!\x1a{\x20Path\x20\
    to\x20mount\x20point\x20(e.g.,\x20/mnt/raid/disk0).\x20If\x20the\x20path\
    \x20is\x20a\n\x20relative\x20path,\x20it\x20is\x20relative\x20to\x20the\
    \x20agent\x20work\x20directory.\n\n\x13\n\x0b\x04\x1d\x03\x02\x03\x01\
    \x03\x01\x02\0\x04\x12\x04\x9a\x0b\x08\x10\n\x13\n\x0b\x04\x1d\x03\x02\
    \x03\x01\x03\x01\x02\0\x05\x12\x04\x9a\x0b\x11\x17\n\x13\n\x0b\x04\x1d\
    \x03\x02\x03\x01\x03\x01\x02\0\x01\x12\x04\x9a\x0b\x18\x1c\n\x13\n\x0b\
    \x04\x1d\x03\x02\x03\x01\x03\x01\x02\0\x03\x12\x04\x9a\x0b\x1f\x20\n\x10\
    \n\x08\x04\x1d\x03\x02\x03\x01\x02\0\x12\x04\x9d\x0b\x06\x1d\n\x11\n\t\
    \x04\x1d\x03\x02\x03\x01\x02\0\x04\x12\x04\x9d\x0b\x06\x0e\n\x11\n\t\x04\
    \x1d\x03\x02\x03\x01\x02\0\x06\x12\x04\x9d\x0b\x0f\x13\n\x11\n\t\x04\x1d\
    \x03\x02\x03\x01\x02\0\x01\x12\x04\x9d\x0b\x14\x18\n\x11\n\t\x04\x1d\x03\
    \x02\x03\x01\x02\0\x03\x12\x04\x9d\x0b\x1b\x1c\n\x10\n\x08\x04\x1d\x03\
    \x02\x03\x01\x02\x01\x12\x04\x9e\x0b\x06\x1d\n\x11\n\t\x04\x1d\x03\x02\
    \x03\x01\x02\x01\x04\x12\x04\x9e\x0b\x06\x0e\n\x11\n\t\x04\x1d\x03\x02\
    \x03\x01\x02\x01\x06\x12\x04\x9e\x0b\x0f\x13\n\x11\n\t\x04\x1d\x03\x02\
    \x03\x01\x02\x01\x01\x12\x04\x9e\x0b\x14\x18\n\x11\n\t\x04\x1d\x03\x02\
    \x03\x01\x02\x01\x03\x12\x04\x9e\x0b\x1b\x1c\n\x10\n\x08\x04\x1d\x03\x02\
    \x03\x01\x02\x02\x12\x04\x9f\x0b\x06\x1f\n\x11\n\t\x04\x1d\x03\x02\x03\
    \x01\x02\x02\x04\x12\x04\x9f\x0b\x06\x0e\n\x11\n\t\x04\x1d\x03\x02\x03\
    \x01\x02\x02\x06\x12\x04\x9f\x0b\x0f\x14\n\x11\n\t\x04\x1d\x03\x02\x03\
    \x01\x02\x02\x01\x12\x04\x9f\x0b\x15\x1a\n\x11\n\t\x04\x1d\x03\x02\x03\
    \x01\x02\x02\x03\x12\x04\x9f\x0b\x1d\x1e\n\x95\x01\n\x08\x04\x1d\x03\x02\
    \x03\x01\x02\x03\x12\x04\xa3\x0b\x06\x1d\x1ar\x20An\x20identifier\x20for\
    \x20this\x20source.\x20This\x20field\x20maps\x20onto\x20CSI\n\x20volume\
    \x20IDs\x20and\x20is\x20not\x20expected\x20to\x20be\x20set\x20by\x20fram\
    eworks.\n\"\x0f\x20EXPERIMENTAL.\n\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x03\x04\x12\x04\xa3\x0b\x06\x0e\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x03\x05\x12\x04\xa3\x0b\x0f\x15\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x03\x01\x12\x04\xa3\x0b\x16\x18\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x03\x03\x12\x04\xa3\x0b\x1b\x1c\n\xa0\x01\n\x08\x04\x1d\x03\x02\x03\x01\
    \x02\x04\x12\x04\xa7\x0b\x06#\x1a}\x20Additional\x20metadata\x20for\x20t\
    his\x20source.\x20This\x20field\x20maps\x20onto\x20CSI\n\x20volume\x20me\
    tadata\x20and\x20is\x20not\x20expected\x20to\x20be\x20set\x20by\x20frame\
    works.\n\"\x0f\x20EXPERIMENTAL.\n\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x04\x04\x12\x04\xa7\x0b\x06\x0e\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x04\x06\x12\x04\xa7\x0b\x0f\x15\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x04\x01\x12\x04\xa7\x0b\x16\x1e\n\x11\n\t\x04\x1d\x03\x02\x03\x01\x02\
    \x04\x03\x12\x04\xa7\x0b!\"\n\xa2\x03\n\x08\x04\x1d\x03\x02\x03\x01\x02\
    \x05\x12\x04\xb1\x0b\x06\"\x1a\xfe\x02\x20This\x20field\x20serves\x20as\
    \x20an\x20indirection\x20to\x20a\x20set\x20of\x20storage\n\x20vendor\x20\
    specific\x20disk\x20parameters\x20which\x20describe\x20the\x20properties\
    \n\x20of\x20the\x20disk.\x20The\x20operator\x20will\x20setup\x20mappings\
    \x20between\x20a\n\x20profile\x20name\x20to\x20a\x20set\x20of\x20vendor\
    \x20specific\x20disk\x20parameters.\x20And\n\x20the\x20framework\x20will\
    \x20do\x20disk\x20selection\x20based\x20on\x20profile\x20names,\n\x20ins\
    tead\x20of\x20vendor\x20specific\x20disk\x20parameters.\n\n\x20Also\x20s\
    ee\x20the\x20DiskProfile\x20module.\n\"\x0f\x20EXPERIMENTAL.\n\n\x11\n\t\
    \x04\x1d\x03\x02\x03\x01\x02\x05\x04\x12\x04\xb1\x0b\x06\x0e\n\x11\n\t\
    \x04\x1d\x03\x02\x03\x01\x02\x05\x05\x12\x04\xb1\x0b\x0f\x15\n\x11\n\t\
    \x04\x1d\x03\x02\x03\x01\x02\x05\x01\x12\x04\xb1\x0b\x16\x1d\n\x11\n\t\
    \x04\x1d\x03\x02\x03\x01\x02\x05\x03\x12\x04\xb1\x0b\x20!\n\x0e\n\x06\
    \x04\x1d\x03\x02\x02\x02\x12\x04\xb4\x0b\x04\x1f\n\x0f\n\x07\x04\x1d\x03\
    \x02\x02\x02\x04\x12\x04\xb4\x0b\x04\x0c\n\x0f\n\x07\x04\x1d\x03\x02\x02\
    \x02\x06\x12\x04\xb4\x0b\r\x13\n\x0f\n\x07\x04\x1d\x03\x02\x02\x02\x01\
    \x12\x04\xb4\x0b\x14\x1a\n\x0f\n\x07\x04\x1d\x03\x02\x02\x02\x03\x12\x04\
    \xb4\x0b\x1d\x1e\n\x0c\n\x04\x04\x1d\x02\n\x12\x04\xb7\x0b\x02\x1d\n\r\n\
    \x05\x04\x1d\x02\n\x04\x12\x04\xb7\x0b\x02\n\n\r\n\x05\x04\x1d\x02\n\x06\
    \x12\x04\xb7\x0b\x0b\x13\n\r\n\x05\x04\x1d\x02\n\x01\x12\x04\xb7\x0b\x14\
    \x18\n\r\n\x05\x04\x1d\x02\n\x03\x12\x04\xb7\x0b\x1b\x1c\n\x0c\n\x04\x04\
    \x1d\x03\x03\x12\x04\xb9\x0b\x02\x1a\n\r\n\x05\x04\x1d\x03\x03\x01\x12\
    \x04\xb9\x0b\n\x17\n\xe1\x02\n\x04\x04\x1d\x02\x0b\x12\x04\xc1\x0b\x02'\
    \x1a\xd2\x02\x20If\x20this\x20is\x20set,\x20the\x20resources\x20are\x20r\
    evocable,\x20i.e.,\x20any\x20tasks\x20or\n\x20executors\x20launched\x20u\
    sing\x20these\x20resources\x20could\x20get\x20preempted\x20or\n\x20throt\
    tled\x20at\x20any\x20time.\x20This\x20could\x20be\x20used\x20by\x20frame\
    works\x20to\x20run\n\x20best\x20effort\x20tasks\x20that\x20do\x20not\x20\
    need\x20strict\x20uptime\x20or\x20performance\n\x20guarantees.\x20Note\
    \x20that\x20if\x20this\x20is\x20set,\x20'disk'\x20or\x20'reservation'\n\
    \x20cannot\x20be\x20set.\n\n\r\n\x05\x04\x1d\x02\x0b\x04\x12\x04\xc1\x0b\
    \x02\n\n\r\n\x05\x04\x1d\x02\x0b\x06\x12\x04\xc1\x0b\x0b\x18\n\r\n\x05\
    \x04\x1d\x02\x0b\x01\x12\x04\xc1\x0b\x19\"\n\r\n\x05\x04\x1d\x02\x0b\x03\
    \x12\x04\xc1\x0b%&\n=\n\x04\x04\x1d\x03\x04\x12\x04\xc4\x0b\x02\x17\x1a/\
    \x20Allow\x20the\x20resource\x20to\x20be\x20shared\x20across\x20tasks.\n\
    \n\r\n\x05\x04\x1d\x03\x04\x01\x12\x04\xc4\x0b\n\x14\n\xfa\x01\n\x04\x04\
    \x1d\x02\x0c\x12\x04\xca\x0b\x02\"\x1a\xeb\x01\x20If\x20this\x20is\x20se\
    t,\x20the\x20resources\x20are\x20shared,\x20i.e.\x20multiple\x20tasks\n\
    \x20can\x20be\x20launched\x20using\x20this\x20resource\x20and\x20all\x20\
    of\x20them\x20shall\x20refer\n\x20to\x20the\x20same\x20physical\x20resou\
    rce\x20on\x20the\x20cluster.\x20Note\x20that\x20only\n\x20persistent\x20\
    volumes\x20can\x20be\x20shared\x20currently.\n\n\r\n\x05\x04\x1d\x02\x0c\
    \x04\x12\x04\xca\x0b\x02\n\n\r\n\x05\x04\x1d\x02\x0c\x06\x12\x04\xca\x0b\
    \x0b\x15\n\r\n\x05\x04\x1d\x02\x0c\x01\x12\x04\xca\x0b\x16\x1c\n\r\n\x05\
    \x04\x1d\x02\x0c\x03\x12\x04\xca\x0b\x1f!\n\x80\t\n\x02\x04\x1e\x12\x06\
    \xe7\x0b\0\xf2\x0b\x01\x1a\xf1\x08*\n\x20When\x20the\x20network\x20bandw\
    idth\x20caps\x20are\x20enabled\x20and\x20the\x20container\n\x20is\x20ove\
    r\x20its\x20limit,\x20outbound\x20packets\x20may\x20be\x20either\x20dela\
    yed\x20or\n\x20dropped\x20completely\x20either\x20because\x20it\x20excee\
    ds\x20the\x20maximum\x20bandwidth\n\x20allocation\x20for\x20a\x20single\
    \x20container\x20(the\x20cap)\x20or\x20because\x20the\x20combined\n\x20n\
    etwork\x20traffic\x20of\x20multiple\x20containers\x20on\x20the\x20host\
    \x20exceeds\x20the\n\x20transmit\x20capacity\x20of\x20the\x20host\x20(th\
    e\x20share).\x20We\x20can\x20report\x20the\n\x20following\x20statistics\
    \x20for\x20each\x20of\x20these\x20conditions\x20exported\x20directly\n\
    \x20from\x20the\x20Linux\x20Traffic\x20Control\x20Queueing\x20Discipline\
    .\n\n\x20id\x20\x20\x20\x20\x20\x20\x20\x20\x20:\x20name\x20of\x20the\
    \x20limiter,\x20e.g.\x20'tx_bw_cap'\n\x20backlog\x20\x20\x20\x20:\x20num\
    ber\x20of\x20packets\x20currently\x20delayed\n\x20bytes\x20\x20\x20\x20\
    \x20\x20:\x20total\x20bytes\x20seen\n\x20drops\x20\x20\x20\x20\x20\x20:\
    \x20number\x20of\x20packets\x20dropped\x20in\x20total\n\x20overlimits\
    \x20:\x20number\x20of\x20packets\x20which\x20exceeded\x20allocation\n\
    \x20packets\x20\x20\x20\x20:\x20total\x20packets\x20seen\n\x20qlen\x20\
    \x20\x20\x20\x20\x20\x20:\x20number\x20of\x20packets\x20currently\x20que\
    ued\n\x20rate_bps\x20\x20\x20:\x20throughput\x20in\x20bytes/sec\n\x20rat\
    e_pps\x20\x20\x20:\x20throughput\x20in\x20packets/sec\n\x20requeues\x20\
    \x20\x20:\x20number\x20of\x20times\x20a\x20packet\x20has\x20been\x20dela\
    yed\x20due\x20to\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20locking\x20or\x20device\x20contention\x20issues\n\n\x20More\x20infor\
    mation\x20on\x20the\x20operation\x20of\x20Linux\x20Traffic\x20Control\
    \x20can\x20be\n\x20found\x20at\x20http://www.lartc.org/lartc.html.\n\n\
    \x0b\n\x03\x04\x1e\x01\x12\x04\xe7\x0b\x08\x20\n\x0c\n\x04\x04\x1e\x02\0\
    \x12\x04\xe8\x0b\x02\x19\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xe8\x0b\x02\
    \n\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xe8\x0b\x0b\x11\n\r\n\x05\x04\x1e\
    \x02\0\x01\x12\x04\xe8\x0b\x12\x14\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xe8\x0b\x17\x18\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xe9\x0b\x02\x1e\n\r\
    \n\x05\x04\x1e\x02\x01\x04\x12\x04\xe9\x0b\x02\n\n\r\n\x05\x04\x1e\x02\
    \x01\x05\x12\x04\xe9\x0b\x0b\x11\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\
    \xe9\x0b\x12\x19\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xe9\x0b\x1c\x1d\n\
    \x0c\n\x04\x04\x1e\x02\x02\x12\x04\xea\x0b\x02\x1c\n\r\n\x05\x04\x1e\x02\
    \x02\x04\x12\x04\xea\x0b\x02\n\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xea\
    \x0b\x0b\x11\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xea\x0b\x12\x17\n\r\n\
    \x05\x04\x1e\x02\x02\x03\x12\x04\xea\x0b\x1a\x1b\n\x0c\n\x04\x04\x1e\x02\
    \x03\x12\x04\xeb\x0b\x02\x1c\n\r\n\x05\x04\x1e\x02\x03\x04\x12\x04\xeb\
    \x0b\x02\n\n\r\n\x05\x04\x1e\x02\x03\x05\x12\x04\xeb\x0b\x0b\x11\n\r\n\
    \x05\x04\x1e\x02\x03\x01\x12\x04\xeb\x0b\x12\x17\n\r\n\x05\x04\x1e\x02\
    \x03\x03\x12\x04\xeb\x0b\x1a\x1b\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\xec\
    \x0b\x02!\n\r\n\x05\x04\x1e\x02\x04\x04\x12\x04\xec\x0b\x02\n\n\r\n\x05\
    \x04\x1e\x02\x04\x05\x12\x04\xec\x0b\x0b\x11\n\r\n\x05\x04\x1e\x02\x04\
    \x01\x12\x04\xec\x0b\x12\x1c\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\xec\
    \x0b\x1f\x20\n\x0c\n\x04\x04\x1e\x02\x05\x12\x04\xed\x0b\x02\x1e\n\r\n\
    \x05\x04\x1e\x02\x05\x04\x12\x04\xed\x0b\x02\n\n\r\n\x05\x04\x1e\x02\x05\
    \x05\x12\x04\xed\x0b\x0b\x11\n\r\n\x05\x04\x1e\x02\x05\x01\x12\x04\xed\
    \x0b\x12\x19\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xed\x0b\x1c\x1d\n\x0c\
    \n\x04\x04\x1e\x02\x06\x12\x04\xee\x0b\x02\x1b\n\r\n\x05\x04\x1e\x02\x06\
    \x04\x12\x04\xee\x0b\x02\n\n\r\n\x05\x04\x1e\x02\x06\x05\x12\x04\xee\x0b\
    \x0b\x11\n\r\n\x05\x04\x1e\x02\x06\x01\x12\x04\xee\x0b\x12\x16\n\r\n\x05\
    \x04\x1e\x02\x06\x03\x12\x04\xee\x0b\x19\x1a\n\x0c\n\x04\x04\x1e\x02\x07\
    \x12\x04\xef\x0b\x02\x1e\n\r\n\x05\x04\x1e\x02\x07\x04\x12\x04\xef\x0b\
    \x02\n\n\r\n\x05\x04\x1e\x02\x07\x05\x12\x04\xef\x0b\x0b\x11\n\r\n\x05\
    \x04\x1e\x02\x07\x01\x12\x04\xef\x0b\x12\x19\n\r\n\x05\x04\x1e\x02\x07\
    \x03\x12\x04\xef\x0b\x1c\x1d\n\x0c\n\x04\x04\x1e\x02\x08\x12\x04\xf0\x0b\
    \x02\x1e\n\r\n\x05\x04\x1e\x02\x08\x04\x12\x04\xf0\x0b\x02\n\n\r\n\x05\
    \x04\x1e\x02\x08\x05\x12\x04\xf0\x0b\x0b\x11\n\r\n\x05\x04\x1e\x02\x08\
    \x01\x12\x04\xf0\x0b\x12\x19\n\r\n\x05\x04\x1e\x02\x08\x03\x12\x04\xf0\
    \x0b\x1c\x1d\n\x0c\n\x04\x04\x1e\x02\t\x12\x04\xf1\x0b\x02\x20\n\r\n\x05\
    \x04\x1e\x02\t\x04\x12\x04\xf1\x0b\x02\n\n\r\n\x05\x04\x1e\x02\t\x05\x12\
    \x04\xf1\x0b\x0b\x11\n\r\n\x05\x04\x1e\x02\t\x01\x12\x04\xf1\x0b\x12\x1a\
    \n\r\n\x05\x04\x1e\x02\t\x03\x12\x04\xf1\x0b\x1d\x1f\n\x0c\n\x02\x04\x1f\
    \x12\x06\xf5\x0b\0\x89\x0c\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xf5\x0b\
    \x08\x14\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xf6\x0b\x02\x20\n\r\n\x05\x04\
    \x1f\x02\0\x04\x12\x04\xf6\x0b\x02\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\
    \xf6\x0b\x0b\x10\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xf6\x0b\x11\x1b\n\r\
    \n\x05\x04\x1f\x02\0\x03\x12\x04\xf6\x0b\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\
    \x01\x12\x04\xf7\x0b\x02\x20\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xf7\
    \x0b\x02\n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xf7\x0b\x0b\x10\n\r\n\
    \x05\x04\x1f\x02\x01\x01\x12\x04\xf7\x0b\x11\x1b\n\r\n\x05\x04\x1f\x02\
    \x01\x03\x12\x04\xf7\x0b\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\xf8\
    \x0b\x02\x20\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\xf8\x0b\x02\n\n\r\n\
    \x05\x04\x1f\x02\x02\x05\x12\x04\xf8\x0b\x0b\x10\n\r\n\x05\x04\x1f\x02\
    \x02\x01\x12\x04\xf8\x0b\x11\x1b\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\
    \xf8\x0b\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\x03\x12\x04\xf9\x0b\x02!\n\r\n\
    \x05\x04\x1f\x02\x03\x04\x12\x04\xf9\x0b\x02\n\n\r\n\x05\x04\x1f\x02\x03\
    \x05\x12\x04\xf9\x0b\x0b\x10\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\xf9\
    \x0b\x11\x1c\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\xf9\x0b\x1f\x20\n\x0c\
    \n\x04\x04\x1f\x02\x04\x12\x04\xfa\x0b\x02\"\n\r\n\x05\x04\x1f\x02\x04\
    \x04\x12\x04\xfa\x0b\x02\n\n\r\n\x05\x04\x1f\x02\x04\x05\x12\x04\xfa\x0b\
    \x0b\x10\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\xfa\x0b\x11\x1d\n\r\n\x05\
    \x04\x1f\x02\x04\x03\x12\x04\xfa\x0b\x20!\n\x0c\n\x04\x04\x1f\x02\x05\
    \x12\x04\xfb\x0b\x02#\n\r\n\x05\x04\x1f\x02\x05\x04\x12\x04\xfb\x0b\x02\
    \n\n\r\n\x05\x04\x1f\x02\x05\x05\x12\x04\xfb\x0b\x0b\x10\n\r\n\x05\x04\
    \x1f\x02\x05\x01\x12\x04\xfb\x0b\x11\x1e\n\r\n\x05\x04\x1f\x02\x05\x03\
    \x12\x04\xfb\x0b!\"\n\x0c\n\x04\x04\x1f\x02\x06\x12\x04\xfc\x0b\x02%\n\r\
    \n\x05\x04\x1f\x02\x06\x04\x12\x04\xfc\x0b\x02\n\n\r\n\x05\x04\x1f\x02\
    \x06\x05\x12\x04\xfc\x0b\x0b\x10\n\r\n\x05\x04\x1f\x02\x06\x01\x12\x04\
    \xfc\x0b\x11\x20\n\r\n\x05\x04\x1f\x02\x06\x03\x12\x04\xfc\x0b#$\n\x0c\n\
    \x04\x04\x1f\x02\x07\x12\x04\xfd\x0b\x02\x20\n\r\n\x05\x04\x1f\x02\x07\
    \x04\x12\x04\xfd\x0b\x02\n\n\r\n\x05\x04\x1f\x02\x07\x05\x12\x04\xfd\x0b\
    \x0b\x10\n\r\n\x05\x04\x1f\x02\x07\x01\x12\x04\xfd\x0b\x11\x1b\n\r\n\x05\
    \x04\x1f\x02\x07\x03\x12\x04\xfd\x0b\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\x08\
    \x12\x04\xfe\x0b\x02\x20\n\r\n\x05\x04\x1f\x02\x08\x04\x12\x04\xfe\x0b\
    \x02\n\n\r\n\x05\x04\x1f\x02\x08\x05\x12\x04\xfe\x0b\x0b\x10\n\r\n\x05\
    \x04\x1f\x02\x08\x01\x12\x04\xfe\x0b\x11\x1b\n\r\n\x05\x04\x1f\x02\x08\
    \x03\x12\x04\xfe\x0b\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\t\x12\x04\xff\x0b\
    \x02\"\n\r\n\x05\x04\x1f\x02\t\x04\x12\x04\xff\x0b\x02\n\n\r\n\x05\x04\
    \x1f\x02\t\x05\x12\x04\xff\x0b\x0b\x10\n\r\n\x05\x04\x1f\x02\t\x01\x12\
    \x04\xff\x0b\x11\x1c\n\r\n\x05\x04\x1f\x02\t\x03\x12\x04\xff\x0b\x1f!\n\
    \x0c\n\x04\x04\x1f\x02\n\x12\x04\x80\x0c\x02\"\n\r\n\x05\x04\x1f\x02\n\
    \x04\x12\x04\x80\x0c\x02\n\n\r\n\x05\x04\x1f\x02\n\x05\x12\x04\x80\x0c\
    \x0b\x10\n\r\n\x05\x04\x1f\x02\n\x01\x12\x04\x80\x0c\x11\x1c\n\r\n\x05\
    \x04\x1f\x02\n\x03\x12\x04\x80\x0c\x1f!\n\x0c\n\x04\x04\x1f\x02\x0b\x12\
    \x04\x81\x0c\x02\"\n\r\n\x05\x04\x1f\x02\x0b\x04\x12\x04\x81\x0c\x02\n\n\
    \r\n\x05\x04\x1f\x02\x0b\x05\x12\x04\x81\x0c\x0b\x10\n\r\n\x05\x04\x1f\
    \x02\x0b\x01\x12\x04\x81\x0c\x11\x1c\n\r\n\x05\x04\x1f\x02\x0b\x03\x12\
    \x04\x81\x0c\x1f!\n\x0c\n\x04\x04\x1f\x02\x0c\x12\x04\x82\x0c\x02#\n\r\n\
    \x05\x04\x1f\x02\x0c\x04\x12\x04\x82\x0c\x02\n\n\r\n\x05\x04\x1f\x02\x0c\
    \x05\x12\x04\x82\x0c\x0b\x10\n\r\n\x05\x04\x1f\x02\x0c\x01\x12\x04\x82\
    \x0c\x11\x1d\n\r\n\x05\x04\x1f\x02\x0c\x03\x12\x04\x82\x0c\x20\"\n\x0c\n\
    \x04\x04\x1f\x02\r\x12\x04\x83\x0c\x02!\n\r\n\x05\x04\x1f\x02\r\x04\x12\
    \x04\x83\x0c\x02\n\n\r\n\x05\x04\x1f\x02\r\x05\x12\x04\x83\x0c\x0b\x10\n\
    \r\n\x05\x04\x1f\x02\r\x01\x12\x04\x83\x0c\x11\x1b\n\r\n\x05\x04\x1f\x02\
    \r\x03\x12\x04\x83\x0c\x1e\x20\n\x0c\n\x04\x04\x1f\x02\x0e\x12\x04\x84\
    \x0c\x02\x1f\n\r\n\x05\x04\x1f\x02\x0e\x04\x12\x04\x84\x0c\x02\n\n\r\n\
    \x05\x04\x1f\x02\x0e\x05\x12\x04\x84\x0c\x0b\x10\n\r\n\x05\x04\x1f\x02\
    \x0e\x01\x12\x04\x84\x0c\x11\x19\n\r\n\x05\x04\x1f\x02\x0e\x03\x12\x04\
    \x84\x0c\x1c\x1e\n\x0c\n\x04\x04\x1f\x02\x0f\x12\x04\x85\x0c\x02!\n\r\n\
    \x05\x04\x1f\x02\x0f\x04\x12\x04\x85\x0c\x02\n\n\r\n\x05\x04\x1f\x02\x0f\
    \x05\x12\x04\x85\x0c\x0b\x10\n\r\n\x05\x04\x1f\x02\x0f\x01\x12\x04\x85\
    \x0c\x11\x1b\n\r\n\x05\x04\x1f\x02\x0f\x03\x12\x04\x85\x0c\x1e\x20\n\x0c\
    \n\x04\x04\x1f\x02\x10\x12\x04\x86\x0c\x02\x1e\n\r\n\x05\x04\x1f\x02\x10\
    \x04\x12\x04\x86\x0c\x02\n\n\r\n\x05\x04\x1f\x02\x10\x05\x12\x04\x86\x0c\
    \x0b\x10\n\r\n\x05\x04\x1f\x02\x10\x01\x12\x04\x86\x0c\x11\x18\n\r\n\x05\
    \x04\x1f\x02\x10\x03\x12\x04\x86\x0c\x1b\x1d\n\x0c\n\x04\x04\x1f\x02\x11\
    \x12\x04\x87\x0c\x02\x20\n\r\n\x05\x04\x1f\x02\x11\x04\x12\x04\x87\x0c\
    \x02\n\n\r\n\x05\x04\x1f\x02\x11\x05\x12\x04\x87\x0c\x0b\x10\n\r\n\x05\
    \x04\x1f\x02\x11\x01\x12\x04\x87\x0c\x11\x1a\n\r\n\x05\x04\x1f\x02\x11\
    \x03\x12\x04\x87\x0c\x1d\x1f\n\x0c\n\x04\x04\x1f\x02\x12\x12\x04\x88\x0c\
    \x02\"\n\r\n\x05\x04\x1f\x02\x12\x04\x12\x04\x88\x0c\x02\n\n\r\n\x05\x04\
    \x1f\x02\x12\x05\x12\x04\x88\x0c\x0b\x10\n\r\n\x05\x04\x1f\x02\x12\x01\
    \x12\x04\x88\x0c\x11\x1c\n\r\n\x05\x04\x1f\x02\x12\x03\x12\x04\x88\x0c\
    \x1f!\n\x0c\n\x02\x04\x20\x12\x06\x8c\x0c\0\xa8\x0c\x01\n\x0b\n\x03\x04\
    \x20\x01\x12\x04\x8c\x0c\x08\x16\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x8d\
    \x0c\x02\x1c\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\x8d\x0c\x02\n\n\r\n\x05\
    \x04\x20\x02\0\x05\x12\x04\x8d\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\0\x01\
    \x12\x04\x8d\x0c\x11\x17\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x8d\x0c\x1a\
    \x1b\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x8e\x0c\x02\x1e\n\r\n\x05\x04\
    \x20\x02\x01\x04\x12\x04\x8e\x0c\x02\n\n\r\n\x05\x04\x20\x02\x01\x05\x12\
    \x04\x8e\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x8e\x0c\x11\
    \x19\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x8e\x0c\x1c\x1d\n\x0c\n\x04\
    \x04\x20\x02\x02\x12\x04\x8f\x0c\x02\"\n\r\n\x05\x04\x20\x02\x02\x04\x12\
    \x04\x8f\x0c\x02\n\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\x8f\x0c\x0b\x10\
    \n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x8f\x0c\x11\x1d\n\r\n\x05\x04\x20\
    \x02\x02\x03\x12\x04\x8f\x0c\x20!\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\
    \x90\x0c\x02$\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x90\x0c\x02\n\n\r\n\
    \x05\x04\x20\x02\x03\x05\x12\x04\x90\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\
    \x03\x01\x12\x04\x90\x0c\x11\x1f\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\
    \x90\x0c\"#\n\x0c\n\x04\x04\x20\x02\x04\x12\x04\x91\x0c\x02!\n\r\n\x05\
    \x04\x20\x02\x04\x04\x12\x04\x91\x0c\x02\n\n\r\n\x05\x04\x20\x02\x04\x05\
    \x12\x04\x91\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\x91\x0c\
    \x11\x1c\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\x91\x0c\x1f\x20\n\x0c\n\
    \x04\x04\x20\x02\x05\x12\x04\x92\x0c\x02!\n\r\n\x05\x04\x20\x02\x05\x04\
    \x12\x04\x92\x0c\x02\n\n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\x92\x0c\x0b\
    \x10\n\r\n\x05\x04\x20\x02\x05\x01\x12\x04\x92\x0c\x11\x1c\n\r\n\x05\x04\
    \x20\x02\x05\x03\x12\x04\x92\x0c\x1f\x20\n\x0c\n\x04\x04\x20\x02\x06\x12\
    \x04\x93\x0c\x02\"\n\r\n\x05\x04\x20\x02\x06\x04\x12\x04\x93\x0c\x02\n\n\
    \r\n\x05\x04\x20\x02\x06\x05\x12\x04\x93\x0c\x0b\x10\n\r\n\x05\x04\x20\
    \x02\x06\x01\x12\x04\x93\x0c\x11\x1d\n\r\n\x05\x04\x20\x02\x06\x03\x12\
    \x04\x93\x0c\x20!\n\x0c\n\x04\x04\x20\x02\x07\x12\x04\x94\x0c\x02!\n\r\n\
    \x05\x04\x20\x02\x07\x04\x12\x04\x94\x0c\x02\n\n\r\n\x05\x04\x20\x02\x07\
    \x05\x12\x04\x94\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x07\x01\x12\x04\x94\
    \x0c\x11\x1c\n\r\n\x05\x04\x20\x02\x07\x03\x12\x04\x94\x0c\x1f\x20\n\x0c\
    \n\x04\x04\x20\x02\x08\x12\x04\x95\x0c\x02\x1d\n\r\n\x05\x04\x20\x02\x08\
    \x04\x12\x04\x95\x0c\x02\n\n\r\n\x05\x04\x20\x02\x08\x05\x12\x04\x95\x0c\
    \x0b\x10\n\r\n\x05\x04\x20\x02\x08\x01\x12\x04\x95\x0c\x11\x18\n\r\n\x05\
    \x04\x20\x02\x08\x03\x12\x04\x95\x0c\x1b\x1c\n\x0c\n\x04\x04\x20\x02\t\
    \x12\x04\x96\x0c\x02!\n\r\n\x05\x04\x20\x02\t\x04\x12\x04\x96\x0c\x02\n\
    \n\r\n\x05\x04\x20\x02\t\x05\x12\x04\x96\x0c\x0b\x10\n\r\n\x05\x04\x20\
    \x02\t\x01\x12\x04\x96\x0c\x11\x1b\n\r\n\x05\x04\x20\x02\t\x03\x12\x04\
    \x96\x0c\x1e\x20\n\x0c\n\x04\x04\x20\x02\n\x12\x04\x97\x0c\x02#\n\r\n\
    \x05\x04\x20\x02\n\x04\x12\x04\x97\x0c\x02\n\n\r\n\x05\x04\x20\x02\n\x05\
    \x12\x04\x97\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\n\x01\x12\x04\x97\x0c\x11\
    \x1d\n\r\n\x05\x04\x20\x02\n\x03\x12\x04\x97\x0c\x20\"\n\x0c\n\x04\x04\
    \x20\x02\x0b\x12\x04\x98\x0c\x02&\n\r\n\x05\x04\x20\x02\x0b\x04\x12\x04\
    \x98\x0c\x02\n\n\r\n\x05\x04\x20\x02\x0b\x05\x12\x04\x98\x0c\x0b\x10\n\r\
    \n\x05\x04\x20\x02\x0b\x01\x12\x04\x98\x0c\x11\x20\n\r\n\x05\x04\x20\x02\
    \x0b\x03\x12\x04\x98\x0c#%\n\x0c\n\x04\x04\x20\x02\x0c\x12\x04\x99\x0c\
    \x02\"\n\r\n\x05\x04\x20\x02\x0c\x04\x12\x04\x99\x0c\x02\n\n\r\n\x05\x04\
    \x20\x02\x0c\x05\x12\x04\x99\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x0c\x01\
    \x12\x04\x99\x0c\x11\x1c\n\r\n\x05\x04\x20\x02\x0c\x03\x12\x04\x99\x0c\
    \x1f!\n\x0c\n\x04\x04\x20\x02\r\x12\x04\x9a\x0c\x02%\n\r\n\x05\x04\x20\
    \x02\r\x04\x12\x04\x9a\x0c\x02\n\n\r\n\x05\x04\x20\x02\r\x05\x12\x04\x9a\
    \x0c\x0b\x10\n\r\n\x05\x04\x20\x02\r\x01\x12\x04\x9a\x0c\x11\x1f\n\r\n\
    \x05\x04\x20\x02\r\x03\x12\x04\x9a\x0c\"$\n\x0c\n\x04\x04\x20\x02\x0e\
    \x12\x04\x9b\x0c\x02\x1e\n\r\n\x05\x04\x20\x02\x0e\x04\x12\x04\x9b\x0c\
    \x02\n\n\r\n\x05\x04\x20\x02\x0e\x05\x12\x04\x9b\x0c\x0b\x10\n\r\n\x05\
    \x04\x20\x02\x0e\x01\x12\x04\x9b\x0c\x11\x18\n\r\n\x05\x04\x20\x02\x0e\
    \x03\x12\x04\x9b\x0c\x1b\x1d\n\x0c\n\x04\x04\x20\x02\x0f\x12\x04\x9c\x0c\
    \x02\x20\n\r\n\x05\x04\x20\x02\x0f\x04\x12\x04\x9c\x0c\x02\n\n\r\n\x05\
    \x04\x20\x02\x0f\x05\x12\x04\x9c\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x0f\
    \x01\x12\x04\x9c\x0c\x11\x1a\n\r\n\x05\x04\x20\x02\x0f\x03\x12\x04\x9c\
    \x0c\x1d\x1f\n\x0c\n\x04\x04\x20\x02\x10\x12\x04\x9d\x0c\x02&\n\r\n\x05\
    \x04\x20\x02\x10\x04\x12\x04\x9d\x0c\x02\n\n\r\n\x05\x04\x20\x02\x10\x05\
    \x12\x04\x9d\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x10\x01\x12\x04\x9d\x0c\
    \x11\x20\n\r\n\x05\x04\x20\x02\x10\x03\x12\x04\x9d\x0c#%\n\x0c\n\x04\x04\
    \x20\x02\x11\x12\x04\x9e\x0c\x02#\n\r\n\x05\x04\x20\x02\x11\x04\x12\x04\
    \x9e\x0c\x02\n\n\r\n\x05\x04\x20\x02\x11\x05\x12\x04\x9e\x0c\x0b\x10\n\r\
    \n\x05\x04\x20\x02\x11\x01\x12\x04\x9e\x0c\x11\x1d\n\r\n\x05\x04\x20\x02\
    \x11\x03\x12\x04\x9e\x0c\x20\"\n\x0c\n\x04\x04\x20\x02\x12\x12\x04\x9f\
    \x0c\x02#\n\r\n\x05\x04\x20\x02\x12\x04\x12\x04\x9f\x0c\x02\n\n\r\n\x05\
    \x04\x20\x02\x12\x05\x12\x04\x9f\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x12\
    \x01\x12\x04\x9f\x0c\x11\x1d\n\r\n\x05\x04\x20\x02\x12\x03\x12\x04\x9f\
    \x0c\x20\"\n\x0c\n\x04\x04\x20\x02\x13\x12\x04\xa0\x0c\x02$\n\r\n\x05\
    \x04\x20\x02\x13\x04\x12\x04\xa0\x0c\x02\n\n\r\n\x05\x04\x20\x02\x13\x05\
    \x12\x04\xa0\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x13\x01\x12\x04\xa0\x0c\
    \x11\x1e\n\r\n\x05\x04\x20\x02\x13\x03\x12\x04\xa0\x0c!#\n\x0c\n\x04\x04\
    \x20\x02\x14\x12\x04\xa1\x0c\x02#\n\r\n\x05\x04\x20\x02\x14\x04\x12\x04\
    \xa1\x0c\x02\n\n\r\n\x05\x04\x20\x02\x14\x05\x12\x04\xa1\x0c\x0b\x10\n\r\
    \n\x05\x04\x20\x02\x14\x01\x12\x04\xa1\x0c\x11\x1d\n\r\n\x05\x04\x20\x02\
    \x14\x03\x12\x04\xa1\x0c\x20\"\n\x0c\n\x04\x04\x20\x02\x15\x12\x04\xa2\
    \x0c\x02\x1f\n\r\n\x05\x04\x20\x02\x15\x04\x12\x04\xa2\x0c\x02\n\n\r\n\
    \x05\x04\x20\x02\x15\x05\x12\x04\xa2\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\
    \x15\x01\x12\x04\xa2\x0c\x11\x19\n\r\n\x05\x04\x20\x02\x15\x03\x12\x04\
    \xa2\x0c\x1c\x1e\n\x0c\n\x04\x04\x20\x02\x16\x12\x04\xa3\x0c\x02\"\n\r\n\
    \x05\x04\x20\x02\x16\x04\x12\x04\xa3\x0c\x02\n\n\r\n\x05\x04\x20\x02\x16\
    \x05\x12\x04\xa3\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x16\x01\x12\x04\xa3\
    \x0c\x11\x1c\n\r\n\x05\x04\x20\x02\x16\x03\x12\x04\xa3\x0c\x1f!\n\x0c\n\
    \x04\x04\x20\x02\x17\x12\x04\xa4\x0c\x02$\n\r\n\x05\x04\x20\x02\x17\x04\
    \x12\x04\xa4\x0c\x02\n\n\r\n\x05\x04\x20\x02\x17\x05\x12\x04\xa4\x0c\x0b\
    \x10\n\r\n\x05\x04\x20\x02\x17\x01\x12\x04\xa4\x0c\x11\x1e\n\r\n\x05\x04\
    \x20\x02\x17\x03\x12\x04\xa4\x0c!#\n\x0c\n\x04\x04\x20\x02\x18\x12\x04\
    \xa5\x0c\x02'\n\r\n\x05\x04\x20\x02\x18\x04\x12\x04\xa5\x0c\x02\n\n\r\n\
    \x05\x04\x20\x02\x18\x05\x12\x04\xa5\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\
    \x18\x01\x12\x04\xa5\x0c\x11!\n\r\n\x05\x04\x20\x02\x18\x03\x12\x04\xa5\
    \x0c$&\n\x0c\n\x04\x04\x20\x02\x19\x12\x04\xa6\x0c\x02#\n\r\n\x05\x04\
    \x20\x02\x19\x04\x12\x04\xa6\x0c\x02\n\n\r\n\x05\x04\x20\x02\x19\x05\x12\
    \x04\xa6\x0c\x0b\x10\n\r\n\x05\x04\x20\x02\x19\x01\x12\x04\xa6\x0c\x11\
    \x1d\n\r\n\x05\x04\x20\x02\x19\x03\x12\x04\xa6\x0c\x20\"\n\x0c\n\x04\x04\
    \x20\x02\x1a\x12\x04\xa7\x0c\x02&\n\r\n\x05\x04\x20\x02\x1a\x04\x12\x04\
    \xa7\x0c\x02\n\n\r\n\x05\x04\x20\x02\x1a\x05\x12\x04\xa7\x0c\x0b\x10\n\r\
    \n\x05\x04\x20\x02\x1a\x01\x12\x04\xa7\x0c\x11\x20\n\r\n\x05\x04\x20\x02\
    \x1a\x03\x12\x04\xa7\x0c#%\n\x0c\n\x02\x04!\x12\x06\xab\x0c\0\xbb\x0c\
    \x01\n\x0b\n\x03\x04!\x01\x12\x04\xab\x0c\x08\x15\n\x0c\n\x04\x04!\x02\0\
    \x12\x04\xac\x0c\x02\"\n\r\n\x05\x04!\x02\0\x04\x12\x04\xac\x0c\x02\n\n\
    \r\n\x05\x04!\x02\0\x05\x12\x04\xac\x0c\x0b\x10\n\r\n\x05\x04!\x02\0\x01\
    \x12\x04\xac\x0c\x11\x1d\n\r\n\x05\x04!\x02\0\x03\x12\x04\xac\x0c\x20!\n\
    \x0c\n\x04\x04!\x02\x01\x12\x04\xad\x0c\x02\x1c\n\r\n\x05\x04!\x02\x01\
    \x04\x12\x04\xad\x0c\x02\n\n\r\n\x05\x04!\x02\x01\x05\x12\x04\xad\x0c\
    \x0b\x10\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xad\x0c\x11\x17\n\r\n\x05\
    \x04!\x02\x01\x03\x12\x04\xad\x0c\x1a\x1b\n\x0c\n\x04\x04!\x02\x02\x12\
    \x04\xae\x0c\x02\x1c\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xae\x0c\x02\n\n\
    \r\n\x05\x04!\x02\x02\x05\x12\x04\xae\x0c\x0b\x10\n\r\n\x05\x04!\x02\x02\
    \x01\x12\x04\xae\x0c\x11\x17\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xae\x0c\
    \x1a\x1b\n\x0c\n\x04\x04!\x02\x03\x12\x04\xaf\x0c\x02\x1d\n\r\n\x05\x04!\
    \x02\x03\x04\x12\x04\xaf\x0c\x02\n\n\r\n\x05\x04!\x02\x03\x05\x12\x04\
    \xaf\x0c\x0b\x10\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xaf\x0c\x11\x18\n\r\
    \n\x05\x04!\x02\x03\x03\x12\x04\xaf\x0c\x1b\x1c\n\x0c\n\x04\x04!\x02\x04\
    \x12\x04\xb0\x0c\x02!\n\r\n\x05\x04!\x02\x04\x04\x12\x04\xb0\x0c\x02\n\n\
    \r\n\x05\x04!\x02\x04\x05\x12\x04\xb0\x0c\x0b\x10\n\r\n\x05\x04!\x02\x04\
    \x01\x12\x04\xb0\x0c\x11\x1c\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xb0\x0c\
    \x1f\x20\n\x0c\n\x04\x04!\x02\x05\x12\x04\xb1\x0c\x02\"\n\r\n\x05\x04!\
    \x02\x05\x04\x12\x04\xb1\x0c\x02\n\n\r\n\x05\x04!\x02\x05\x05\x12\x04\
    \xb1\x0c\x0b\x10\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xb1\x0c\x11\x1d\n\r\
    \n\x05\x04!\x02\x05\x03\x12\x04\xb1\x0c\x20!\n\x0c\n\x04\x04!\x02\x06\
    \x12\x04\xb2\x0c\x02\"\n\r\n\x05\x04!\x02\x06\x04\x12\x04\xb2\x0c\x02\n\
    \n\r\n\x05\x04!\x02\x06\x05\x12\x04\xb2\x0c\x0b\x10\n\r\n\x05\x04!\x02\
    \x06\x01\x12\x04\xb2\x0c\x11\x1d\n\r\n\x05\x04!\x02\x06\x03\x12\x04\xb2\
    \x0c\x20!\n\x0c\n\x04\x04!\x02\x07\x12\x04\xb3\x0c\x02!\n\r\n\x05\x04!\
    \x02\x07\x04\x12\x04\xb3\x0c\x02\n\n\r\n\x05\x04!\x02\x07\x05\x12\x04\
    \xb3\x0c\x0b\x10\n\r\n\x05\x04!\x02\x07\x01\x12\x04\xb3\x0c\x11\x1c\n\r\
    \n\x05\x04!\x02\x07\x03\x12\x04\xb3\x0c\x1f\x20\n\x0c\n\x04\x04!\x02\x08\
    \x12\x04\xb4\x0c\x02\x1f\n\r\n\x05\x04!\x02\x08\x04\x12\x04\xb4\x0c\x02\
    \n\n\r\n\x05\x04!\x02\x08\x05\x12\x04\xb4\x0c\x0b\x10\n\r\n\x05\x04!\x02\
    \x08\x01\x12\x04\xb4\x0c\x11\x1a\n\r\n\x05\x04!\x02\x08\x03\x12\x04\xb4\
    \x0c\x1d\x1e\n\x0c\n\x04\x04!\x02\t\x12\x04\xb5\x0c\x02\x1d\n\r\n\x05\
    \x04!\x02\t\x04\x12\x04\xb5\x0c\x02\n\n\r\n\x05\x04!\x02\t\x05\x12\x04\
    \xb5\x0c\x0b\x10\n\r\n\x05\x04!\x02\t\x01\x12\x04\xb5\x0c\x11\x17\n\r\n\
    \x05\x04!\x02\t\x03\x12\x04\xb5\x0c\x1a\x1c\n\x0c\n\x04\x04!\x02\n\x12\
    \x04\xb6\x0c\x02\x1e\n\r\n\x05\x04!\x02\n\x04\x12\x04\xb6\x0c\x02\n\n\r\
    \n\x05\x04!\x02\n\x05\x12\x04\xb6\x0c\x0b\x10\n\r\n\x05\x04!\x02\n\x01\
    \x12\x04\xb6\x0c\x11\x18\n\r\n\x05\x04!\x02\n\x03\x12\x04\xb6\x0c\x1b\
    \x1d\n\x0c\n\x04\x04!\x02\x0b\x12\x04\xb7\x0c\x02\"\n\r\n\x05\x04!\x02\
    \x0b\x04\x12\x04\xb7\x0c\x02\n\n\r\n\x05\x04!\x02\x0b\x05\x12\x04\xb7\
    \x0c\x0b\x10\n\r\n\x05\x04!\x02\x0b\x01\x12\x04\xb7\x0c\x11\x1c\n\r\n\
    \x05\x04!\x02\x0b\x03\x12\x04\xb7\x0c\x1f!\n\x0c\n\x04\x04!\x02\x0c\x12\
    \x04\xb8\x0c\x02\x1d\n\r\n\x05\x04!\x02\x0c\x04\x12\x04\xb8\x0c\x02\n\n\
    \r\n\x05\x04!\x02\x0c\x05\x12\x04\xb8\x0c\x0b\x10\n\r\n\x05\x04!\x02\x0c\
    \x01\x12\x04\xb8\x0c\x11\x17\n\r\n\x05\x04!\x02\x0c\x03\x12\x04\xb8\x0c\
    \x1a\x1c\n\x0c\n\x04\x04!\x02\r\x12\x04\xb9\x0c\x02\x1e\n\r\n\x05\x04!\
    \x02\r\x04\x12\x04\xb9\x0c\x02\n\n\r\n\x05\x04!\x02\r\x05\x12\x04\xb9\
    \x0c\x0b\x10\n\r\n\x05\x04!\x02\r\x01\x12\x04\xb9\x0c\x11\x18\n\r\n\x05\
    \x04!\x02\r\x03\x12\x04\xb9\x0c\x1b\x1d\n\x0c\n\x04\x04!\x02\x0e\x12\x04\
    \xba\x0c\x02#\n\r\n\x05\x04!\x02\x0e\x04\x12\x04\xba\x0c\x02\n\n\r\n\x05\
    \x04!\x02\x0e\x05\x12\x04\xba\x0c\x0b\x10\n\r\n\x05\x04!\x02\x0e\x01\x12\
    \x04\xba\x0c\x11\x1d\n\r\n\x05\x04!\x02\x0e\x03\x12\x04\xba\x0c\x20\"\n\
    \x0c\n\x02\x04\"\x12\x06\xbe\x0c\0\xc7\x0c\x01\n\x0b\n\x03\x04\"\x01\x12\
    \x04\xbe\x0c\x08\x15\n\x0c\n\x04\x04\"\x02\0\x12\x04\xbf\x0c\x02!\n\r\n\
    \x05\x04\"\x02\0\x04\x12\x04\xbf\x0c\x02\n\n\r\n\x05\x04\"\x02\0\x05\x12\
    \x04\xbf\x0c\x0b\x10\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xbf\x0c\x11\x1c\n\
    \r\n\x05\x04\"\x02\0\x03\x12\x04\xbf\x0c\x1f\x20\n\x0c\n\x04\x04\"\x02\
    \x01\x12\x04\xc0\x0c\x02\x1d\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xc0\x0c\
    \x02\n\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xc0\x0c\x0b\x10\n\r\n\x05\x04\
    \"\x02\x01\x01\x12\x04\xc0\x0c\x11\x18\n\r\n\x05\x04\"\x02\x01\x03\x12\
    \x04\xc0\x0c\x1b\x1c\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xc1\x0c\x02\x1e\n\
    \r\n\x05\x04\"\x02\x02\x04\x12\x04\xc1\x0c\x02\n\n\r\n\x05\x04\"\x02\x02\
    \x05\x12\x04\xc1\x0c\x0b\x10\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xc1\x0c\
    \x11\x19\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xc1\x0c\x1c\x1d\n\x0c\n\x04\
    \x04\"\x02\x03\x12\x04\xc2\x0c\x02\"\n\r\n\x05\x04\"\x02\x03\x04\x12\x04\
    \xc2\x0c\x02\n\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\xc2\x0c\x0b\x10\n\r\n\
    \x05\x04\"\x02\x03\x01\x12\x04\xc2\x0c\x11\x1d\n\r\n\x05\x04\"\x02\x03\
    \x03\x12\x04\xc2\x0c\x20!\n\x0c\n\x04\x04\"\x02\x04\x12\x04\xc3\x0c\x02\
    \"\n\r\n\x05\x04\"\x02\x04\x04\x12\x04\xc3\x0c\x02\n\n\r\n\x05\x04\"\x02\
    \x04\x05\x12\x04\xc3\x0c\x0b\x10\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xc3\
    \x0c\x11\x1d\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xc3\x0c\x20!\n\x0c\n\
    \x04\x04\"\x02\x05\x12\x04\xc4\x0c\x02\"\n\r\n\x05\x04\"\x02\x05\x04\x12\
    \x04\xc4\x0c\x02\n\n\r\n\x05\x04\"\x02\x05\x05\x12\x04\xc4\x0c\x0b\x10\n\
    \r\n\x05\x04\"\x02\x05\x01\x12\x04\xc4\x0c\x11\x1d\n\r\n\x05\x04\"\x02\
    \x05\x03\x12\x04\xc4\x0c\x20!\n\x0c\n\x04\x04\"\x02\x06\x12\x04\xc5\x0c\
    \x02\"\n\r\n\x05\x04\"\x02\x06\x04\x12\x04\xc5\x0c\x02\n\n\r\n\x05\x04\"\
    \x02\x06\x05\x12\x04\xc5\x0c\x0b\x10\n\r\n\x05\x04\"\x02\x06\x01\x12\x04\
    \xc5\x0c\x11\x1d\n\r\n\x05\x04\"\x02\x06\x03\x12\x04\xc5\x0c\x20!\n\x0c\
    \n\x04\x04\"\x02\x07\x12\x04\xc6\x0c\x02\"\n\r\n\x05\x04\"\x02\x07\x04\
    \x12\x04\xc6\x0c\x02\n\n\r\n\x05\x04\"\x02\x07\x05\x12\x04\xc6\x0c\x0b\
    \x10\n\r\n\x05\x04\"\x02\x07\x01\x12\x04\xc6\x0c\x11\x1d\n\r\n\x05\x04\"\
    \x02\x07\x03\x12\x04\xc6\x0c\x20!\n\x0c\n\x02\x04#\x12\x06\xca\x0c\0\xcf\
    \x0c\x01\n\x0b\n\x03\x04#\x01\x12\x04\xca\x0c\x08\x16\n\x0c\n\x04\x04#\
    \x02\0\x12\x04\xcb\x0c\x02%\n\r\n\x05\x04#\x02\0\x04\x12\x04\xcb\x0c\x02\
    \n\n\r\n\x05\x04#\x02\0\x06\x12\x04\xcb\x0c\x0b\x17\n\r\n\x05\x04#\x02\0\
    \x01\x12\x04\xcb\x0c\x18\x20\n\r\n\x05\x04#\x02\0\x03\x12\x04\xcb\x0c#$\
    \n\x0c\n\x04\x04#\x02\x01\x12\x04\xcc\x0c\x02)\n\r\n\x05\x04#\x02\x01\
    \x04\x12\x04\xcc\x0c\x02\n\n\r\n\x05\x04#\x02\x01\x06\x12\x04\xcc\x0c\
    \x0b\x19\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xcc\x0c\x1a$\n\r\n\x05\x04#\
    \x02\x01\x03\x12\x04\xcc\x0c'(\n\x0c\n\x04\x04#\x02\x02\x12\x04\xcd\x0c\
    \x02'\n\r\n\x05\x04#\x02\x02\x04\x12\x04\xcd\x0c\x02\n\n\r\n\x05\x04#\
    \x02\x02\x06\x12\x04\xcd\x0c\x0b\x18\n\r\n\x05\x04#\x02\x02\x01\x12\x04\
    \xcd\x0c\x19\"\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xcd\x0c%&\n\x0c\n\x04\
    \x04#\x02\x03\x12\x04\xce\x0c\x02'\n\r\n\x05\x04#\x02\x03\x04\x12\x04\
    \xce\x0c\x02\n\n\r\n\x05\x04#\x02\x03\x06\x12\x04\xce\x0c\x0b\x18\n\r\n\
    \x05\x04#\x02\x03\x01\x12\x04\xce\x0c\x19\"\n\r\n\x05\x04#\x02\x03\x03\
    \x12\x04\xce\x0c%&\n\x0c\n\x02\x04$\x12\x06\xd2\x0c\0\xd7\x0c\x01\n\x0b\
    \n\x03\x04$\x01\x12\x04\xd2\x0c\x08\x16\n\x0c\n\x04\x04$\x02\0\x12\x04\
    \xd3\x0c\x02/\n\r\n\x05\x04$\x02\0\x04\x12\x04\xd3\x0c\x02\n\n\r\n\x05\
    \x04$\x02\0\x06\x12\x04\xd3\x0c\x0b#\n\r\n\x05\x04$\x02\0\x01\x12\x04\
    \xd3\x0c$*\n\r\n\x05\x04$\x02\0\x03\x12\x04\xd3\x0c-.\n\x0c\n\x04\x04$\
    \x02\x01\x12\x04\xd4\x0c\x029\n\r\n\x05\x04$\x02\x01\x04\x12\x04\xd4\x0c\
    \x02\n\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xd4\x0c\x0b(\n\r\n\x05\x04$\
    \x02\x01\x01\x12\x04\xd4\x0c)4\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xd4\
    \x0c78\n\x0c\n\x04\x04$\x02\x02\x12\x04\xd5\x0c\x02\"\n\r\n\x05\x04$\x02\
    \x02\x04\x12\x04\xd5\x0c\x02\n\n\r\n\x05\x04$\x02\x02\x05\x12\x04\xd5\
    \x0c\x0b\x11\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xd5\x0c\x12\x1d\n\r\n\
    \x05\x04$\x02\x02\x03\x12\x04\xd5\x0c\x20!\n\x0c\n\x04\x04$\x02\x03\x12\
    \x04\xd6\x0c\x02!\n\r\n\x05\x04$\x02\x03\x04\x12\x04\xd6\x0c\x02\n\n\r\n\
    \x05\x04$\x02\x03\x05\x12\x04\xd6\x0c\x0b\x11\n\r\n\x05\x04$\x02\x03\x01\
    \x12\x04\xd6\x0c\x12\x1c\n\r\n\x05\x04$\x02\x03\x03\x12\x04\xd6\x0c\x1f\
    \x20\n:\n\x02\x04%\x12\x06\xdd\x0c\0\xc8\r\x01\x1a,*\n\x20A\x20snapshot\
    \x20of\x20resource\x20usage\x20statistics.\n\n\x0b\n\x03\x04%\x01\x12\
    \x04\xdd\x0c\x08\x1a\n:\n\x04\x04%\x02\0\x12\x04\xde\x0c\x02\x20\",\x20S\
    napshot\x20time,\x20in\x20seconds\x20since\x20the\x20Epoch.\n\n\r\n\x05\
    \x04%\x02\0\x04\x12\x04\xde\x0c\x02\n\n\r\n\x05\x04%\x02\0\x05\x12\x04\
    \xde\x0c\x0b\x11\n\r\n\x05\x04%\x02\0\x01\x12\x04\xde\x0c\x12\x1b\n\r\n\
    \x05\x04%\x02\0\x03\x12\x04\xde\x0c\x1e\x1f\n\x0c\n\x04\x04%\x02\x01\x12\
    \x04\xe0\x0c\x02!\n\r\n\x05\x04%\x02\x01\x04\x12\x04\xe0\x0c\x02\n\n\r\n\
    \x05\x04%\x02\x01\x05\x12\x04\xe0\x0c\x0b\x11\n\r\n\x05\x04%\x02\x01\x01\
    \x12\x04\xe0\x0c\x12\x1b\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xe0\x0c\x1e\
    \x20\n\x0c\n\x04\x04%\x02\x02\x12\x04\xe1\x0c\x02\x1f\n\r\n\x05\x04%\x02\
    \x02\x04\x12\x04\xe1\x0c\x02\n\n\r\n\x05\x04%\x02\x02\x05\x12\x04\xe1\
    \x0c\x0b\x11\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xe1\x0c\x12\x19\n\r\n\
    \x05\x04%\x02\x02\x03\x12\x04\xe1\x0c\x1c\x1e\n[\n\x04\x04%\x02\x03\x12\
    \x04\xe5\x0c\x02*\x1aM\x20CPU\x20Usage\x20Information:\n\x20Total\x20CPU\
    \x20time\x20spent\x20in\x20user\x20mode,\x20and\x20kernel\x20mode.\n\n\r\
    \n\x05\x04%\x02\x03\x04\x12\x04\xe5\x0c\x02\n\n\r\n\x05\x04%\x02\x03\x05\
    \x12\x04\xe5\x0c\x0b\x11\n\r\n\x05\x04%\x02\x03\x01\x12\x04\xe5\x0c\x12%\
    \n\r\n\x05\x04%\x02\x03\x03\x12\x04\xe5\x0c()\n\x0c\n\x04\x04%\x02\x04\
    \x12\x04\xe6\x0c\x02,\n\r\n\x05\x04%\x02\x04\x04\x12\x04\xe6\x0c\x02\n\n\
    \r\n\x05\x04%\x02\x04\x05\x12\x04\xe6\x0c\x0b\x11\n\r\n\x05\x04%\x02\x04\
    \x01\x12\x04\xe6\x0c\x12'\n\r\n\x05\x04%\x02\x04\x03\x12\x04\xe6\x0c*+\n\
    )\n\x04\x04%\x02\x05\x12\x04\xe9\x0c\x02!\x1a\x1b\x20Number\x20of\x20CPU\
    s\x20allocated.\n\n\r\n\x05\x04%\x02\x05\x04\x12\x04\xe9\x0c\x02\n\n\r\n\
    \x05\x04%\x02\x05\x05\x12\x04\xe9\x0c\x0b\x11\n\r\n\x05\x04%\x02\x05\x01\
    \x12\x04\xe9\x0c\x12\x1c\n\r\n\x05\x04%\x02\x05\x03\x12\x04\xe9\x0c\x1f\
    \x20\nG\n\x04\x04%\x02\x06\x12\x04\xec\x0c\x02&\x1a9\x20cpu.stat\x20on\
    \x20process\x20throttling\x20(for\x20contention\x20issues).\n\n\r\n\x05\
    \x04%\x02\x06\x04\x12\x04\xec\x0c\x02\n\n\r\n\x05\x04%\x02\x06\x05\x12\
    \x04\xec\x0c\x0b\x11\n\r\n\x05\x04%\x02\x06\x01\x12\x04\xec\x0c\x12!\n\r\
    \n\x05\x04%\x02\x06\x03\x12\x04\xec\x0c$%\n\x0c\n\x04\x04%\x02\x07\x12\
    \x04\xed\x0c\x02(\n\r\n\x05\x04%\x02\x07\x04\x12\x04\xed\x0c\x02\n\n\r\n\
    \x05\x04%\x02\x07\x05\x12\x04\xed\x0c\x0b\x11\n\r\n\x05\x04%\x02\x07\x01\
    \x12\x04\xed\x0c\x12#\n\r\n\x05\x04%\x02\x07\x03\x12\x04\xed\x0c&'\n\x0c\
    \n\x04\x04%\x02\x08\x12\x04\xee\x0c\x02/\n\r\n\x05\x04%\x02\x08\x04\x12\
    \x04\xee\x0c\x02\n\n\r\n\x05\x04%\x02\x08\x05\x12\x04\xee\x0c\x0b\x11\n\
    \r\n\x05\x04%\x02\x08\x01\x12\x04\xee\x0c\x12*\n\r\n\x05\x04%\x02\x08\
    \x03\x12\x04\xee\x0c-.\n\xeb\x02\n\x04\x04%\x02\t\x12\x04\xf7\x0c\x02'\
    \x1a\xbf\x02\x20mem_total_bytes\x20was\x20added\x20in\x200.23.0\x20to\
    \x20represent\x20the\x20total\x20memory\n\x20of\x20a\x20process\x20in\
    \x20RAM\x20(as\x20opposed\x20to\x20in\x20Swap).\x20This\x20was\x20previo\
    usly\n\x20reported\x20as\x20mem_rss_bytes,\x20which\x20was\x20also\x20ch\
    anged\x20in\x200.23.0\x20to\n\x20represent\x20only\x20the\x20anonymous\
    \x20memory\x20usage,\x20to\x20keep\x20in\x20sync\x20with\n\x20Linux\x20k\
    ernel's\x20(arguably\x20erroneous)\x20use\x20of\x20terminology.\n2\x1b\
    \x20Memory\x20Usage\x20Information:\n\n\r\n\x05\x04%\x02\t\x04\x12\x04\
    \xf7\x0c\x02\n\n\r\n\x05\x04%\x02\t\x05\x12\x04\xf7\x0c\x0b\x11\n\r\n\
    \x05\x04%\x02\t\x01\x12\x04\xf7\x0c\x12!\n\r\n\x05\x04%\x02\t\x03\x12\
    \x04\xf7\x0c$&\nJ\n\x04\x04%\x02\n\x12\x04\xfa\x0c\x02-\x1a<\x20Total\
    \x20memory\x20+\x20swap\x20usage.\x20This\x20is\x20set\x20if\x20swap\x20\
    is\x20enabled.\n\n\r\n\x05\x04%\x02\n\x04\x12\x04\xfa\x0c\x02\n\n\r\n\
    \x05\x04%\x02\n\x05\x12\x04\xfa\x0c\x0b\x11\n\r\n\x05\x04%\x02\n\x01\x12\
    \x04\xfa\x0c\x12'\n\r\n\x05\x04%\x02\n\x03\x12\x04\xfa\x0c*,\n2\n\x04\
    \x04%\x02\x0b\x12\x04\xfd\x0c\x02&\x1a$\x20Hard\x20memory\x20limit\x20fo\
    r\x20a\x20container.\n\n\r\n\x05\x04%\x02\x0b\x04\x12\x04\xfd\x0c\x02\n\
    \n\r\n\x05\x04%\x02\x0b\x05\x12\x04\xfd\x0c\x0b\x11\n\r\n\x05\x04%\x02\
    \x0b\x01\x12\x04\xfd\x0c\x12!\n\r\n\x05\x04%\x02\x0b\x03\x12\x04\xfd\x0c\
    $%\n2\n\x04\x04%\x02\x0c\x12\x04\x80\r\x02,\x1a$\x20Soft\x20memory\x20li\
    mit\x20for\x20a\x20container.\n\n\r\n\x05\x04%\x02\x0c\x04\x12\x04\x80\r\
    \x02\n\n\r\n\x05\x04%\x02\x0c\x05\x12\x04\x80\r\x0b\x11\n\r\n\x05\x04%\
    \x02\x0c\x01\x12\x04\x80\r\x12&\n\r\n\x05\x04%\x02\x0c\x03\x12\x04\x80\r\
    )+\n\xd3\x01\n\x04\x04%\x02\r\x12\x04\x87\r\x02&\x1ai\x20TODO(chzhcn)\
    \x20mem_file_bytes\x20and\x20mem_anon_bytes\x20are\x20deprecated\x20in\n\
    \x200.23.0\x20and\x20will\x20be\x20removed\x20in\x200.24.0.\n2Z\x20Broke\
    n\x20out\x20memory\x20usage\x20information:\x20pagecache,\x20rss\x20(ano\
    nymous),\n\x20mmaped\x20files\x20and\x20swap.\n\n\r\n\x05\x04%\x02\r\x04\
    \x12\x04\x87\r\x02\n\n\r\n\x05\x04%\x02\r\x05\x12\x04\x87\r\x0b\x11\n\r\
    \n\x05\x04%\x02\r\x01\x12\x04\x87\r\x12\x20\n\r\n\x05\x04%\x02\r\x03\x12\
    \x04\x87\r#%\n\x0c\n\x04\x04%\x02\x0e\x12\x04\x88\r\x02&\n\r\n\x05\x04%\
    \x02\x0e\x04\x12\x04\x88\r\x02\n\n\r\n\x05\x04%\x02\x0e\x05\x12\x04\x88\
    \r\x0b\x11\n\r\n\x05\x04%\x02\x0e\x01\x12\x04\x88\r\x12\x20\n\r\n\x05\
    \x04%\x02\x0e\x03\x12\x04\x88\r#%\nQ\n\x04\x04%\x02\x0f\x12\x04\x8b\r\
    \x02'\x1aC\x20mem_cache_bytes\x20is\x20added\x20in\x200.23.0\x20to\x20re\
    present\x20page\x20cache\x20usage.\n\n\r\n\x05\x04%\x02\x0f\x04\x12\x04\
    \x8b\r\x02\n\n\r\n\x05\x04%\x02\x0f\x05\x12\x04\x8b\r\x0b\x11\n\r\n\x05\
    \x04%\x02\x0f\x01\x12\x04\x8b\r\x12!\n\r\n\x05\x04%\x02\x0f\x03\x12\x04\
    \x8b\r$&\n\xb4\x01\n\x04\x04%\x02\x10\x12\x04\x90\r\x02$\x1a\xa5\x01\x20\
    Since\x200.23.0,\x20mem_rss_bytes\x20is\x20changed\x20to\x20represent\
    \x20only\n\x20anonymous\x20memory\x20usage.\x20Note\x20that\x20neither\
    \x20its\x20requiredness,\x20type,\n\x20name\x20nor\x20numeric\x20tag\x20\
    has\x20been\x20changed.\n\n\r\n\x05\x04%\x02\x10\x04\x12\x04\x90\r\x02\n\
    \n\r\n\x05\x04%\x02\x10\x05\x12\x04\x90\r\x0b\x11\n\r\n\x05\x04%\x02\x10\
    \x01\x12\x04\x90\r\x12\x1f\n\r\n\x05\x04%\x02\x10\x03\x12\x04\x90\r\"#\n\
    \x0c\n\x04\x04%\x02\x11\x12\x04\x92\r\x02-\n\r\n\x05\x04%\x02\x11\x04\
    \x12\x04\x92\r\x02\n\n\r\n\x05\x04%\x02\x11\x05\x12\x04\x92\r\x0b\x11\n\
    \r\n\x05\x04%\x02\x11\x01\x12\x04\x92\r\x12'\n\r\n\x05\x04%\x02\x11\x03\
    \x12\x04\x92\r*,\n4\n\x04\x04%\x02\x12\x12\x04\x94\r\x02&\x1a&\x20This\
    \x20is\x20only\x20set\x20if\x20swap\x20is\x20enabled.\n\n\r\n\x05\x04%\
    \x02\x12\x04\x12\x04\x94\r\x02\n\n\r\n\x05\x04%\x02\x12\x05\x12\x04\x94\
    \r\x0b\x11\n\r\n\x05\x04%\x02\x12\x01\x12\x04\x94\r\x12\x20\n\r\n\x05\
    \x04%\x02\x12\x03\x12\x04\x94\r#%\n\x0c\n\x04\x04%\x02\x13\x12\x04\x95\r\
    \x02-\n\r\n\x05\x04%\x02\x13\x04\x12\x04\x95\r\x02\n\n\r\n\x05\x04%\x02\
    \x13\x05\x12\x04\x95\r\x0b\x11\n\r\n\x05\x04%\x02\x13\x01\x12\x04\x95\r\
    \x12'\n\r\n\x05\x04%\x02\x13\x03\x12\x04\x95\r*,\n\x95\x02\n\x04\x04%\
    \x02\x14\x12\x04\x9c\r\x020\x1a\x86\x02\x20Number\x20of\x20occurrences\
    \x20of\x20different\x20levels\x20of\x20memory\x20pressure\n\x20events\
    \x20reported\x20by\x20memory\x20cgroup.\x20Pressure\x20listening\x20(re)\
    starts\n\x20with\x20these\x20values\x20set\x20to\x200\x20when\x20agent\
    \x20(re)starts.\x20See\n\x20https://www.kernel.org/doc/Documentation/cgr\
    oups/memory.txt\x20for\n\x20more\x20details.\n\n\r\n\x05\x04%\x02\x14\
    \x04\x12\x04\x9c\r\x02\n\n\r\n\x05\x04%\x02\x14\x05\x12\x04\x9c\r\x0b\
    \x11\n\r\n\x05\x04%\x02\x14\x01\x12\x04\x9c\r\x12*\n\r\n\x05\x04%\x02\
    \x14\x03\x12\x04\x9c\r-/\n\x0c\n\x04\x04%\x02\x15\x12\x04\x9d\r\x023\n\r\
    \n\x05\x04%\x02\x15\x04\x12\x04\x9d\r\x02\n\n\r\n\x05\x04%\x02\x15\x05\
    \x12\x04\x9d\r\x0b\x11\n\r\n\x05\x04%\x02\x15\x01\x12\x04\x9d\r\x12-\n\r\
    \n\x05\x04%\x02\x15\x03\x12\x04\x9d\r02\n\x0c\n\x04\x04%\x02\x16\x12\x04\
    \x9e\r\x025\n\r\n\x05\x04%\x02\x16\x04\x12\x04\x9e\r\x02\n\n\r\n\x05\x04\
    %\x02\x16\x05\x12\x04\x9e\r\x0b\x11\n\r\n\x05\x04%\x02\x16\x01\x12\x04\
    \x9e\r\x12/\n\r\n\x05\x04%\x02\x16\x03\x12\x04\x9e\r24\nF\n\x04\x04%\x02\
    \x17\x12\x04\xa1\r\x02(\x1a8\x20Disk\x20Usage\x20Information\x20for\x20e\
    xecutor\x20working\x20directory.\n\n\r\n\x05\x04%\x02\x17\x04\x12\x04\
    \xa1\r\x02\n\n\r\n\x05\x04%\x02\x17\x05\x12\x04\xa1\r\x0b\x11\n\r\n\x05\
    \x04%\x02\x17\x01\x12\x04\xa1\r\x12\"\n\r\n\x05\x04%\x02\x17\x03\x12\x04\
    \xa1\r%'\n\x0c\n\x04\x04%\x02\x18\x12\x04\xa2\r\x02'\n\r\n\x05\x04%\x02\
    \x18\x04\x12\x04\xa2\r\x02\n\n\r\n\x05\x04%\x02\x18\x05\x12\x04\xa2\r\
    \x0b\x11\n\r\n\x05\x04%\x02\x18\x01\x12\x04\xa2\r\x12!\n\r\n\x05\x04%\
    \x02\x18\x03\x12\x04\xa2\r$&\n/\n\x04\x04%\x02\x19\x12\x04\xa5\r\x02/\
    \x1a!\x20Per\x20disk\x20(resource)\x20statistics.\n\n\r\n\x05\x04%\x02\
    \x19\x04\x12\x04\xa5\r\x02\n\n\r\n\x05\x04%\x02\x19\x06\x12\x04\xa5\r\
    \x0b\x19\n\r\n\x05\x04%\x02\x19\x01\x12\x04\xa5\r\x1a)\n\r\n\x05\x04%\
    \x02\x19\x03\x12\x04\xa5\r,.\n)\n\x04\x04%\x02\x1a\x12\x04\xa8\r\x02=\
    \x1a\x1b\x20Cgroups\x20blkio\x20statistics.\n\n\r\n\x05\x04%\x02\x1a\x04\
    \x12\x04\xa8\r\x02\n\n\r\n\x05\x04%\x02\x1a\x06\x12\x04\xa8\r\x0b&\n\r\n\
    \x05\x04%\x02\x1a\x01\x12\x04\xa8\r'7\n\r\n\x05\x04%\x02\x1a\x03\x12\x04\
    \xa8\r:<\n\x20\n\x04\x04%\x02\x1b\x12\x04\xab\r\x02$\x1a\x12\x20Perf\x20\
    statistics.\n\n\r\n\x05\x04%\x02\x1b\x04\x12\x04\xab\r\x02\n\n\r\n\x05\
    \x04%\x02\x1b\x06\x12\x04\xab\r\x0b\x19\n\r\n\x05\x04%\x02\x1b\x01\x12\
    \x04\xab\r\x1a\x1e\n\r\n\x05\x04%\x02\x1b\x03\x12\x04\xab\r!#\n*\n\x04\
    \x04%\x02\x1c\x12\x04\xae\r\x02&\x1a\x1c\x20Network\x20Usage\x20Informat\
    ion:\n\n\r\n\x05\x04%\x02\x1c\x04\x12\x04\xae\r\x02\n\n\r\n\x05\x04%\x02\
    \x1c\x05\x12\x04\xae\r\x0b\x11\n\r\n\x05\x04%\x02\x1c\x01\x12\x04\xae\r\
    \x12\x20\n\r\n\x05\x04%\x02\x1c\x03\x12\x04\xae\r#%\n\x0c\n\x04\x04%\x02\
    \x1d\x12\x04\xaf\r\x02$\n\r\n\x05\x04%\x02\x1d\x04\x12\x04\xaf\r\x02\n\n\
    \r\n\x05\x04%\x02\x1d\x05\x12\x04\xaf\r\x0b\x11\n\r\n\x05\x04%\x02\x1d\
    \x01\x12\x04\xaf\r\x12\x1e\n\r\n\x05\x04%\x02\x1d\x03\x12\x04\xaf\r!#\n\
    \x0c\n\x04\x04%\x02\x1e\x12\x04\xb0\r\x02%\n\r\n\x05\x04%\x02\x1e\x04\
    \x12\x04\xb0\r\x02\n\n\r\n\x05\x04%\x02\x1e\x05\x12\x04\xb0\r\x0b\x11\n\
    \r\n\x05\x04%\x02\x1e\x01\x12\x04\xb0\r\x12\x1f\n\r\n\x05\x04%\x02\x1e\
    \x03\x12\x04\xb0\r\"$\n\x0c\n\x04\x04%\x02\x1f\x12\x04\xb1\r\x02&\n\r\n\
    \x05\x04%\x02\x1f\x04\x12\x04\xb1\r\x02\n\n\r\n\x05\x04%\x02\x1f\x05\x12\
    \x04\xb1\r\x0b\x11\n\r\n\x05\x04%\x02\x1f\x01\x12\x04\xb1\r\x12\x20\n\r\
    \n\x05\x04%\x02\x1f\x03\x12\x04\xb1\r#%\n\x0c\n\x04\x04%\x02\x20\x12\x04\
    \xb2\r\x02&\n\r\n\x05\x04%\x02\x20\x04\x12\x04\xb2\r\x02\n\n\r\n\x05\x04\
    %\x02\x20\x05\x12\x04\xb2\r\x0b\x11\n\r\n\x05\x04%\x02\x20\x01\x12\x04\
    \xb2\r\x12\x20\n\r\n\x05\x04%\x02\x20\x03\x12\x04\xb2\r#%\n\x0c\n\x04\
    \x04%\x02!\x12\x04\xb3\r\x02$\n\r\n\x05\x04%\x02!\x04\x12\x04\xb3\r\x02\
    \n\n\r\n\x05\x04%\x02!\x05\x12\x04\xb3\r\x0b\x11\n\r\n\x05\x04%\x02!\x01\
    \x12\x04\xb3\r\x12\x1e\n\r\n\x05\x04%\x02!\x03\x12\x04\xb3\r!#\n\x0c\n\
    \x04\x04%\x02\"\x12\x04\xb4\r\x02%\n\r\n\x05\x04%\x02\"\x04\x12\x04\xb4\
    \r\x02\n\n\r\n\x05\x04%\x02\"\x05\x12\x04\xb4\r\x0b\x11\n\r\n\x05\x04%\
    \x02\"\x01\x12\x04\xb4\r\x12\x1f\n\r\n\x05\x04%\x02\"\x03\x12\x04\xb4\r\
    \"$\n\x0c\n\x04\x04%\x02#\x12\x04\xb5\r\x02&\n\r\n\x05\x04%\x02#\x04\x12\
    \x04\xb5\r\x02\n\n\r\n\x05\x04%\x02#\x05\x12\x04\xb5\r\x0b\x11\n\r\n\x05\
    \x04%\x02#\x01\x12\x04\xb5\r\x12\x20\n\r\n\x05\x04%\x02#\x03\x12\x04\xb5\
    \r#%\n\x86\x01\n\x04\x04%\x02$\x12\x04\xb9\r\x021\x1ax\x20The\x20kernel\
    \x20keeps\x20track\x20of\x20RTT\x20(round-trip\x20time)\x20for\x20its\
    \x20TCP\n\x20sockets.\x20RTT\x20is\x20a\x20way\x20to\x20tell\x20the\x20l\
    atency\x20of\x20a\x20container.\n\n\r\n\x05\x04%\x02$\x04\x12\x04\xb9\r\
    \x02\n\n\r\n\x05\x04%\x02$\x05\x12\x04\xb9\r\x0b\x11\n\r\n\x05\x04%\x02$\
    \x01\x12\x04\xb9\r\x12+\n\r\n\x05\x04%\x02$\x03\x12\x04\xb9\r.0\n\x0c\n\
    \x04\x04%\x02%\x12\x04\xba\r\x021\n\r\n\x05\x04%\x02%\x04\x12\x04\xba\r\
    \x02\n\n\r\n\x05\x04%\x02%\x05\x12\x04\xba\r\x0b\x11\n\r\n\x05\x04%\x02%\
    \x01\x12\x04\xba\r\x12+\n\r\n\x05\x04%\x02%\x03\x12\x04\xba\r.0\n\x0c\n\
    \x04\x04%\x02&\x12\x04\xbb\r\x021\n\r\n\x05\x04%\x02&\x04\x12\x04\xbb\r\
    \x02\n\n\r\n\x05\x04%\x02&\x05\x12\x04\xbb\r\x0b\x11\n\r\n\x05\x04%\x02&\
    \x01\x12\x04\xbb\r\x12+\n\r\n\x05\x04%\x02&\x03\x12\x04\xbb\r.0\n\x0c\n\
    \x04\x04%\x02'\x12\x04\xbc\r\x021\n\r\n\x05\x04%\x02'\x04\x12\x04\xbc\r\
    \x02\n\n\r\n\x05\x04%\x02'\x05\x12\x04\xbc\r\x0b\x11\n\r\n\x05\x04%\x02'\
    \x01\x12\x04\xbc\r\x12+\n\r\n\x05\x04%\x02'\x03\x12\x04\xbc\r.0\n\x0c\n\
    \x04\x04%\x02(\x12\x04\xbe\r\x022\n\r\n\x05\x04%\x02(\x04\x12\x04\xbe\r\
    \x02\n\n\r\n\x05\x04%\x02(\x05\x12\x04\xbe\r\x0b\x11\n\r\n\x05\x04%\x02(\
    \x01\x12\x04\xbe\r\x12,\n\r\n\x05\x04%\x02(\x03\x12\x04\xbe\r/1\n\x0c\n\
    \x04\x04%\x02)\x12\x04\xbf\r\x025\n\r\n\x05\x04%\x02)\x04\x12\x04\xbf\r\
    \x02\n\n\r\n\x05\x04%\x02)\x05\x12\x04\xbf\r\x0b\x11\n\r\n\x05\x04%\x02)\
    \x01\x12\x04\xbf\r\x12/\n\r\n\x05\x04%\x02)\x03\x12\x04\xbf\r24\n\x9d\
    \x01\n\x04\x04%\x02*\x12\x04\xc4\r\x02H\x1a\x8e\x01\x20Network\x20traffi\
    c\x20flowing\x20into\x20or\x20out\x20of\x20a\x20container\x20can\x20be\
    \x20delayed\n\x20or\x20dropped\x20due\x20to\x20congestion\x20or\x20polic\
    y\x20inside\x20and\x20outside\x20the\n\x20container.\n\n\r\n\x05\x04%\
    \x02*\x04\x12\x04\xc4\r\x02\n\n\r\n\x05\x04%\x02*\x06\x12\x04\xc4\r\x0b#\
    \n\r\n\x05\x04%\x02*\x01\x12\x04\xc4\r$B\n\r\n\x05\x04%\x02*\x03\x12\x04\
    \xc4\rEG\n;\n\x04\x04%\x02+\x12\x04\xc7\r\x023\x1a-\x20Network\x20SNMP\
    \x20statistics\x20for\x20each\x20container.\n\n\r\n\x05\x04%\x02+\x04\
    \x12\x04\xc7\r\x02\n\n\r\n\x05\x04%\x02+\x06\x12\x04\xc7\r\x0b\x19\n\r\n\
    \x05\x04%\x02+\x01\x12\x04\xc7\r\x1a-\n\r\n\x05\x04%\x02+\x03\x12\x04\
    \xc7\r02\nK\n\x02\x04&\x12\x06\xce\r\0\xed\r\x01\x1a=*\n\x20Describes\
    \x20a\x20snapshot\x20of\x20the\x20resource\x20usage\x20for\x20executors.\
    \n\n\x0b\n\x03\x04&\x01\x12\x04\xce\r\x08\x15\n\x0e\n\x04\x04&\x03\0\x12\
    \x06\xcf\r\x02\xe6\r\x03\n\r\n\x05\x04&\x03\0\x01\x12\x04\xcf\r\n\x12\n\
    \x0e\n\x06\x04&\x03\0\x02\0\x12\x04\xd0\r\x04,\n\x0f\n\x07\x04&\x03\0\
    \x02\0\x04\x12\x04\xd0\r\x04\x0c\n\x0f\n\x07\x04&\x03\0\x02\0\x06\x12\
    \x04\xd0\r\r\x19\n\x0f\n\x07\x04&\x03\0\x02\0\x01\x12\x04\xd0\r\x1a'\n\
    \x0f\n\x07\x04&\x03\0\x02\0\x03\x12\x04\xd0\r*+\nc\n\x06\x04&\x03\0\x02\
    \x01\x12\x04\xd4\r\x04$\x1aS\x20This\x20includes\x20resources\x20used\
    \x20by\x20the\x20executor\x20itself\n\x20as\x20well\x20as\x20its\x20acti\
    ve\x20tasks.\n\n\x0f\n\x07\x04&\x03\0\x02\x01\x04\x12\x04\xd4\r\x04\x0c\
    \n\x0f\n\x07\x04&\x03\0\x02\x01\x06\x12\x04\xd4\r\r\x15\n\x0f\n\x07\x04&\
    \x03\0\x02\x01\x01\x12\x04\xd4\r\x16\x1f\n\x0f\n\x07\x04&\x03\0\x02\x01\
    \x03\x12\x04\xd4\r\"#\nf\n\x06\x04&\x03\0\x02\x02\x12\x04\xd8\r\x04/\x1a\
    V\x20Current\x20resource\x20usage.\x20If\x20absent,\x20the\x20containeri\
    zer\n\x20cannot\x20provide\x20resource\x20usage.\n\n\x0f\n\x07\x04&\x03\
    \0\x02\x02\x04\x12\x04\xd8\r\x04\x0c\n\x0f\n\x07\x04&\x03\0\x02\x02\x06\
    \x12\x04\xd8\r\r\x1f\n\x0f\n\x07\x04&\x03\0\x02\x02\x01\x12\x04\xd8\r\
    \x20*\n\x0f\n\x07\x04&\x03\0\x02\x02\x03\x12\x04\xd8\r-.\nY\n\x06\x04&\
    \x03\0\x02\x03\x12\x04\xdb\r\x04*\x1aI\x20The\x20container\x20id\x20for\
    \x20the\x20executor\x20specified\x20in\x20the\x20executor_info\x20field.\
    \n\n\x0f\n\x07\x04&\x03\0\x02\x03\x04\x12\x04\xdb\r\x04\x0c\n\x0f\n\x07\
    \x04&\x03\0\x02\x03\x06\x12\x04\xdb\r\r\x18\n\x0f\n\x07\x04&\x03\0\x02\
    \x03\x01\x12\x04\xdb\r\x19%\n\x0f\n\x07\x04&\x03\0\x02\x03\x03\x12\x04\
    \xdb\r()\n\x10\n\x06\x04&\x03\0\x03\0\x12\x06\xdd\r\x04\xe2\r\x05\n\x0f\
    \n\x07\x04&\x03\0\x03\0\x01\x12\x04\xdd\r\x0c\x10\n\x10\n\x08\x04&\x03\0\
    \x03\0\x02\0\x12\x04\xde\r\x06\x1f\n\x11\n\t\x04&\x03\0\x03\0\x02\0\x04\
    \x12\x04\xde\r\x06\x0e\n\x11\n\t\x04&\x03\0\x03\0\x02\0\x05\x12\x04\xde\
    \r\x0f\x15\n\x11\n\t\x04&\x03\0\x03\0\x02\0\x01\x12\x04\xde\r\x16\x1a\n\
    \x11\n\t\x04&\x03\0\x03\0\x02\0\x03\x12\x04\xde\r\x1d\x1e\n\x10\n\x08\
    \x04&\x03\0\x03\0\x02\x01\x12\x04\xdf\r\x06\x1d\n\x11\n\t\x04&\x03\0\x03\
    \0\x02\x01\x04\x12\x04\xdf\r\x06\x0e\n\x11\n\t\x04&\x03\0\x03\0\x02\x01\
    \x06\x12\x04\xdf\r\x0f\x15\n\x11\n\t\x04&\x03\0\x03\0\x02\x01\x01\x12\
    \x04\xdf\r\x16\x18\n\x11\n\t\x04&\x03\0\x03\0\x02\x01\x03\x12\x04\xdf\r\
    \x1b\x1c\n\x10\n\x08\x04&\x03\0\x03\0\x02\x02\x12\x04\xe0\r\x06&\n\x11\n\
    \t\x04&\x03\0\x03\0\x02\x02\x04\x12\x04\xe0\r\x06\x0e\n\x11\n\t\x04&\x03\
    \0\x03\0\x02\x02\x06\x12\x04\xe0\r\x0f\x17\n\x11\n\t\x04&\x03\0\x03\0\
    \x02\x02\x01\x12\x04\xe0\r\x18!\n\x11\n\t\x04&\x03\0\x03\0\x02\x02\x03\
    \x12\x04\xe0\r$%\n\x10\n\x08\x04&\x03\0\x03\0\x02\x03\x12\x04\xe1\r\x06!\
    \n\x11\n\t\x04&\x03\0\x03\0\x02\x03\x04\x12\x04\xe1\r\x06\x0e\n\x11\n\t\
    \x04&\x03\0\x03\0\x02\x03\x06\x12\x04\xe1\r\x0f\x15\n\x11\n\t\x04&\x03\0\
    \x03\0\x02\x03\x01\x12\x04\xe1\r\x16\x1c\n\x11\n\t\x04&\x03\0\x03\0\x02\
    \x03\x03\x12\x04\xe1\r\x1f\x20\n%\n\x06\x04&\x03\0\x02\x04\x12\x04\xe5\r\
    \x04\x1c\x1a\x15\x20Non-terminal\x20tasks.\n\n\x0f\n\x07\x04&\x03\0\x02\
    \x04\x04\x12\x04\xe5\r\x04\x0c\n\x0f\n\x07\x04&\x03\0\x02\x04\x06\x12\
    \x04\xe5\r\r\x11\n\x0f\n\x07\x04&\x03\0\x02\x04\x01\x12\x04\xe5\r\x12\
    \x17\n\x0f\n\x07\x04&\x03\0\x02\x04\x03\x12\x04\xe5\r\x1a\x1b\n\x0c\n\
    \x04\x04&\x02\0\x12\x04\xe8\r\x02\"\n\r\n\x05\x04&\x02\0\x04\x12\x04\xe8\
    \r\x02\n\n\r\n\x05\x04&\x02\0\x06\x12\x04\xe8\r\x0b\x13\n\r\n\x05\x04&\
    \x02\0\x01\x12\x04\xe8\r\x14\x1d\n\r\n\x05\x04&\x02\0\x03\x12\x04\xe8\r\
    \x20!\nl\n\x04\x04&\x02\x01\x12\x04\xec\r\x02\x1e\x1a^\x20Agent's\x20tot\
    al\x20resources\x20including\x20checkpointed\x20dynamic\n\x20reservation\
    s\x20and\x20persistent\x20volumes.\n\n\r\n\x05\x04&\x02\x01\x04\x12\x04\
    \xec\r\x02\n\n\r\n\x05\x04&\x02\x01\x06\x12\x04\xec\r\x0b\x13\n\r\n\x05\
    \x04&\x02\x01\x01\x12\x04\xec\r\x14\x19\n\r\n\x05\x04&\x02\x01\x03\x12\
    \x04\xec\r\x1c\x1d\n\xa8\x03\n\x02\x04'\x12\x06\xfc\r\0\xb8\x0e\x01\x1a\
    \x99\x03*\n\x20Describes\x20a\x20sample\x20of\x20events\x20from\x20\"per\
    f\x20stat\".\x20Only\x20available\x20on\n\x20Linux.\n\n\x20NOTE:\x20Each\
    \x20optional\x20field\x20matches\x20the\x20name\x20of\x20a\x20perf\x20ev\
    ent\x20(see\n\x20\"perf\x20list\")\x20with\x20the\x20following\x20change\
    s:\n\x201.\x20Names\x20are\x20downcased.\n\x202.\x20Hyphens\x20('-')\x20\
    are\x20replaced\x20with\x20underscores\x20('_').\n\x203.\x20Events\x20wi\
    th\x20alternate\x20names\x20use\x20the\x20name\x20\"perf\x20stat\"\x20re\
    turns,\n\x20\x20\x20\x20e.g.,\x20for\x20the\x20event\x20\"cycles\x20OR\
    \x20cpu-cycles\"\x20perf\x20always\x20returns\n\x20\x20\x20\x20cycles.\n\
    \n\x0b\n\x03\x04'\x01\x12\x04\xfc\r\x08\x16\nE\n\x04\x04'\x02\0\x12\x04\
    \xfd\r\x02\x20\"7\x20Start\x20of\x20sample\x20interval,\x20in\x20seconds\
    \x20since\x20the\x20Epoch.\n\n\r\n\x05\x04'\x02\0\x04\x12\x04\xfd\r\x02\
    \n\n\r\n\x05\x04'\x02\0\x05\x12\x04\xfd\r\x0b\x11\n\r\n\x05\x04'\x02\0\
    \x01\x12\x04\xfd\r\x12\x1b\n\r\n\x05\x04'\x02\0\x03\x12\x04\xfd\r\x1e\
    \x1f\n8\n\x04\x04'\x02\x01\x12\x04\xfe\r\x02\x1f\"*\x20Duration\x20of\
    \x20sample\x20interval,\x20in\x20seconds.\n\n\r\n\x05\x04'\x02\x01\x04\
    \x12\x04\xfe\r\x02\n\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xfe\r\x0b\x11\n\
    \r\n\x05\x04'\x02\x01\x01\x12\x04\xfe\r\x12\x1a\n\r\n\x05\x04'\x02\x01\
    \x03\x12\x04\xfe\r\x1d\x1e\n\x1f\n\x04\x04'\x02\x02\x12\x04\x81\x0e\x02\
    \x1d\x1a\x11\x20Hardware\x20event.\n\n\r\n\x05\x04'\x02\x02\x04\x12\x04\
    \x81\x0e\x02\n\n\r\n\x05\x04'\x02\x02\x05\x12\x04\x81\x0e\x0b\x11\n\r\n\
    \x05\x04'\x02\x02\x01\x12\x04\x81\x0e\x12\x18\n\r\n\x05\x04'\x02\x02\x03\
    \x12\x04\x81\x0e\x1b\x1c\n\x0c\n\x04\x04'\x02\x03\x12\x04\x82\x0e\x02.\n\
    \r\n\x05\x04'\x02\x03\x04\x12\x04\x82\x0e\x02\n\n\r\n\x05\x04'\x02\x03\
    \x05\x12\x04\x82\x0e\x0b\x11\n\r\n\x05\x04'\x02\x03\x01\x12\x04\x82\x0e\
    \x12)\n\r\n\x05\x04'\x02\x03\x03\x12\x04\x82\x0e,-\n\x0c\n\x04\x04'\x02\
    \x04\x12\x04\x83\x0e\x02-\n\r\n\x05\x04'\x02\x04\x04\x12\x04\x83\x0e\x02\
    \n\n\r\n\x05\x04'\x02\x04\x05\x12\x04\x83\x0e\x0b\x11\n\r\n\x05\x04'\x02\
    \x04\x01\x12\x04\x83\x0e\x12(\n\r\n\x05\x04'\x02\x04\x03\x12\x04\x83\x0e\
    +,\n\x0c\n\x04\x04'\x02\x05\x12\x04\x84\x0e\x02#\n\r\n\x05\x04'\x02\x05\
    \x04\x12\x04\x84\x0e\x02\n\n\r\n\x05\x04'\x02\x05\x05\x12\x04\x84\x0e\
    \x0b\x11\n\r\n\x05\x04'\x02\x05\x01\x12\x04\x84\x0e\x12\x1e\n\r\n\x05\
    \x04'\x02\x05\x03\x12\x04\x84\x0e!\"\n\x0c\n\x04\x04'\x02\x06\x12\x04\
    \x85\x0e\x02'\n\r\n\x05\x04'\x02\x06\x04\x12\x04\x85\x0e\x02\n\n\r\n\x05\
    \x04'\x02\x06\x05\x12\x04\x85\x0e\x0b\x11\n\r\n\x05\x04'\x02\x06\x01\x12\
    \x04\x85\x0e\x12\"\n\r\n\x05\x04'\x02\x06\x03\x12\x04\x85\x0e%&\n\x0c\n\
    \x04\x04'\x02\x07\x12\x04\x86\x0e\x02#\n\r\n\x05\x04'\x02\x07\x04\x12\
    \x04\x86\x0e\x02\n\n\r\n\x05\x04'\x02\x07\x05\x12\x04\x86\x0e\x0b\x11\n\
    \r\n\x05\x04'\x02\x07\x01\x12\x04\x86\x0e\x12\x1e\n\r\n\x05\x04'\x02\x07\
    \x03\x12\x04\x86\x0e!\"\n\x0c\n\x04\x04'\x02\x08\x12\x04\x87\x0e\x02\x1f\
    \n\r\n\x05\x04'\x02\x08\x04\x12\x04\x87\x0e\x02\n\n\r\n\x05\x04'\x02\x08\
    \x05\x12\x04\x87\x0e\x0b\x11\n\r\n\x05\x04'\x02\x08\x01\x12\x04\x87\x0e\
    \x12\x1a\n\r\n\x05\x04'\x02\x08\x03\x12\x04\x87\x0e\x1d\x1e\n\x0c\n\x04\
    \x04'\x02\t\x12\x04\x88\x0e\x02%\n\r\n\x05\x04'\x02\t\x04\x12\x04\x88\
    \x0e\x02\n\n\r\n\x05\x04'\x02\t\x05\x12\x04\x88\x0e\x0b\x11\n\r\n\x05\
    \x04'\x02\t\x01\x12\x04\x88\x0e\x12\x1f\n\r\n\x05\x04'\x02\t\x03\x12\x04\
    \x88\x0e\"$\n\x0c\n\x04\x04'\x02\n\x12\x04\x89\x0e\x02\"\n\r\n\x05\x04'\
    \x02\n\x04\x12\x04\x89\x0e\x02\n\n\r\n\x05\x04'\x02\n\x05\x12\x04\x89\
    \x0e\x0b\x11\n\r\n\x05\x04'\x02\n\x01\x12\x04\x89\x0e\x12\x1c\n\r\n\x05\
    \x04'\x02\n\x03\x12\x04\x89\x0e\x1f!\n\x0c\n\x04\x04'\x02\x0b\x12\x04\
    \x8a\x0e\x02\"\n\r\n\x05\x04'\x02\x0b\x04\x12\x04\x8a\x0e\x02\n\n\r\n\
    \x05\x04'\x02\x0b\x05\x12\x04\x8a\x0e\x0b\x11\n\r\n\x05\x04'\x02\x0b\x01\
    \x12\x04\x8a\x0e\x12\x1c\n\r\n\x05\x04'\x02\x0b\x03\x12\x04\x8a\x0e\x1f!\
    \n\x1f\n\x04\x04'\x02\x0c\x12\x04\x8d\x0e\x02!\x1a\x11\x20Software\x20ev\
    ent.\n\n\r\n\x05\x04'\x02\x0c\x04\x12\x04\x8d\x0e\x02\n\n\r\n\x05\x04'\
    \x02\x0c\x05\x12\x04\x8d\x0e\x0b\x11\n\r\n\x05\x04'\x02\x0c\x01\x12\x04\
    \x8d\x0e\x12\x1b\n\r\n\x05\x04'\x02\x0c\x03\x12\x04\x8d\x0e\x1e\x20\n\
    \x0c\n\x04\x04'\x02\r\x12\x04\x8e\x0e\x02\"\n\r\n\x05\x04'\x02\r\x04\x12\
    \x04\x8e\x0e\x02\n\n\r\n\x05\x04'\x02\r\x05\x12\x04\x8e\x0e\x0b\x11\n\r\
    \n\x05\x04'\x02\r\x01\x12\x04\x8e\x0e\x12\x1c\n\r\n\x05\x04'\x02\r\x03\
    \x12\x04\x8e\x0e\x1f!\n\x0c\n\x04\x04'\x02\x0e\x12\x04\x8f\x0e\x02#\n\r\
    \n\x05\x04'\x02\x0e\x04\x12\x04\x8f\x0e\x02\n\n\r\n\x05\x04'\x02\x0e\x05\
    \x12\x04\x8f\x0e\x0b\x11\n\r\n\x05\x04'\x02\x0e\x01\x12\x04\x8f\x0e\x12\
    \x1d\n\r\n\x05\x04'\x02\x0e\x03\x12\x04\x8f\x0e\x20\"\n\x0c\n\x04\x04'\
    \x02\x0f\x12\x04\x90\x0e\x02$\n\r\n\x05\x04'\x02\x0f\x04\x12\x04\x90\x0e\
    \x02\n\n\r\n\x05\x04'\x02\x0f\x05\x12\x04\x90\x0e\x0b\x11\n\r\n\x05\x04'\
    \x02\x0f\x01\x12\x04\x90\x0e\x12\x1e\n\r\n\x05\x04'\x02\x0f\x03\x12\x04\
    \x90\x0e!#\n\x0c\n\x04\x04'\x02\x10\x12\x04\x91\x0e\x02$\n\r\n\x05\x04'\
    \x02\x10\x04\x12\x04\x91\x0e\x02\n\n\r\n\x05\x04'\x02\x10\x05\x12\x04\
    \x91\x0e\x0b\x11\n\r\n\x05\x04'\x02\x10\x01\x12\x04\x91\x0e\x12\x1e\n\r\
    \n\x05\x04'\x02\x10\x03\x12\x04\x91\x0e!#\n\x0c\n\x04\x04'\x02\x11\x12\
    \x04\x92\x0e\x02(\n\r\n\x05\x04'\x02\x11\x04\x12\x04\x92\x0e\x02\n\n\r\n\
    \x05\x04'\x02\x11\x05\x12\x04\x92\x0e\x0b\x11\n\r\n\x05\x04'\x02\x11\x01\
    \x12\x04\x92\x0e\x12\"\n\r\n\x05\x04'\x02\x11\x03\x12\x04\x92\x0e%'\n\
    \x0c\n\x04\x04'\x02\x12\x12\x04\x93\x0e\x02&\n\r\n\x05\x04'\x02\x12\x04\
    \x12\x04\x93\x0e\x02\n\n\r\n\x05\x04'\x02\x12\x05\x12\x04\x93\x0e\x0b\
    \x11\n\r\n\x05\x04'\x02\x12\x01\x12\x04\x93\x0e\x12\x20\n\r\n\x05\x04'\
    \x02\x12\x03\x12\x04\x93\x0e#%\n\x0c\n\x04\x04'\x02\x13\x12\x04\x94\x0e\
    \x02(\n\r\n\x05\x04'\x02\x13\x04\x12\x04\x94\x0e\x02\n\n\r\n\x05\x04'\
    \x02\x13\x05\x12\x04\x94\x0e\x0b\x11\n\r\n\x05\x04'\x02\x13\x01\x12\x04\
    \x94\x0e\x12\"\n\r\n\x05\x04'\x02\x13\x03\x12\x04\x94\x0e%'\n\x0c\n\x04\
    \x04'\x02\x14\x12\x04\x95\x0e\x02(\n\r\n\x05\x04'\x02\x14\x04\x12\x04\
    \x95\x0e\x02\n\n\r\n\x05\x04'\x02\x14\x05\x12\x04\x95\x0e\x0b\x11\n\r\n\
    \x05\x04'\x02\x14\x01\x12\x04\x95\x0e\x12\"\n\r\n\x05\x04'\x02\x14\x03\
    \x12\x04\x95\x0e%'\n%\n\x04\x04'\x02\x15\x12\x04\x98\x0e\x02'\x1a\x17\
    \x20Hardware\x20cache\x20event.\n\n\r\n\x05\x04'\x02\x15\x04\x12\x04\x98\
    \x0e\x02\n\n\r\n\x05\x04'\x02\x15\x05\x12\x04\x98\x0e\x0b\x11\n\r\n\x05\
    \x04'\x02\x15\x01\x12\x04\x98\x0e\x12!\n\r\n\x05\x04'\x02\x15\x03\x12\
    \x04\x98\x0e$&\n\x0c\n\x04\x04'\x02\x16\x12\x04\x99\x0e\x02-\n\r\n\x05\
    \x04'\x02\x16\x04\x12\x04\x99\x0e\x02\n\n\r\n\x05\x04'\x02\x16\x05\x12\
    \x04\x99\x0e\x0b\x11\n\r\n\x05\x04'\x02\x16\x01\x12\x04\x99\x0e\x12'\n\r\
    \n\x05\x04'\x02\x16\x03\x12\x04\x99\x0e*,\n\x0c\n\x04\x04'\x02\x17\x12\
    \x04\x9a\x0e\x02(\n\r\n\x05\x04'\x02\x17\x04\x12\x04\x9a\x0e\x02\n\n\r\n\
    \x05\x04'\x02\x17\x05\x12\x04\x9a\x0e\x0b\x11\n\r\n\x05\x04'\x02\x17\x01\
    \x12\x04\x9a\x0e\x12\"\n\r\n\x05\x04'\x02\x17\x03\x12\x04\x9a\x0e%'\n\
    \x0c\n\x04\x04'\x02\x18\x12\x04\x9b\x0e\x02.\n\r\n\x05\x04'\x02\x18\x04\
    \x12\x04\x9b\x0e\x02\n\n\r\n\x05\x04'\x02\x18\x05\x12\x04\x9b\x0e\x0b\
    \x11\n\r\n\x05\x04'\x02\x18\x01\x12\x04\x9b\x0e\x12(\n\r\n\x05\x04'\x02\
    \x18\x03\x12\x04\x9b\x0e+-\n\x0c\n\x04\x04'\x02\x19\x12\x04\x9c\x0e\x02,\
    \n\r\n\x05\x04'\x02\x19\x04\x12\x04\x9c\x0e\x02\n\n\r\n\x05\x04'\x02\x19\
    \x05\x12\x04\x9c\x0e\x0b\x11\n\r\n\x05\x04'\x02\x19\x01\x12\x04\x9c\x0e\
    \x12&\n\r\n\x05\x04'\x02\x19\x03\x12\x04\x9c\x0e)+\n\x0c\n\x04\x04'\x02\
    \x1a\x12\x04\x9d\x0e\x021\n\r\n\x05\x04'\x02\x1a\x04\x12\x04\x9d\x0e\x02\
    \n\n\r\n\x05\x04'\x02\x1a\x05\x12\x04\x9d\x0e\x0b\x11\n\r\n\x05\x04'\x02\
    \x1a\x01\x12\x04\x9d\x0e\x12+\n\r\n\x05\x04'\x02\x1a\x03\x12\x04\x9d\x0e\
    .0\n\x0c\n\x04\x04'\x02\x1b\x12\x04\x9e\x0e\x02'\n\r\n\x05\x04'\x02\x1b\
    \x04\x12\x04\x9e\x0e\x02\n\n\r\n\x05\x04'\x02\x1b\x05\x12\x04\x9e\x0e\
    \x0b\x11\n\r\n\x05\x04'\x02\x1b\x01\x12\x04\x9e\x0e\x12!\n\r\n\x05\x04'\
    \x02\x1b\x03\x12\x04\x9e\x0e$&\n\x0c\n\x04\x04'\x02\x1c\x12\x04\x9f\x0e\
    \x02-\n\r\n\x05\x04'\x02\x1c\x04\x12\x04\x9f\x0e\x02\n\n\r\n\x05\x04'\
    \x02\x1c\x05\x12\x04\x9f\x0e\x0b\x11\n\r\n\x05\x04'\x02\x1c\x01\x12\x04\
    \x9f\x0e\x12'\n\r\n\x05\x04'\x02\x1c\x03\x12\x04\x9f\x0e*,\n\x0c\n\x04\
    \x04'\x02\x1d\x12\x04\xa0\x0e\x02,\n\r\n\x05\x04'\x02\x1d\x04\x12\x04\
    \xa0\x0e\x02\n\n\r\n\x05\x04'\x02\x1d\x05\x12\x04\xa0\x0e\x0b\x11\n\r\n\
    \x05\x04'\x02\x1d\x01\x12\x04\xa0\x0e\x12&\n\r\n\x05\x04'\x02\x1d\x03\
    \x12\x04\xa0\x0e)+\n\x0c\n\x04\x04'\x02\x1e\x12\x04\xa1\x0e\x021\n\r\n\
    \x05\x04'\x02\x1e\x04\x12\x04\xa1\x0e\x02\n\n\r\n\x05\x04'\x02\x1e\x05\
    \x12\x04\xa1\x0e\x0b\x11\n\r\n\x05\x04'\x02\x1e\x01\x12\x04\xa1\x0e\x12+\
    \n\r\n\x05\x04'\x02\x1e\x03\x12\x04\xa1\x0e.0\n\x0c\n\x04\x04'\x02\x1f\
    \x12\x04\xa2\x0e\x02!\n\r\n\x05\x04'\x02\x1f\x04\x12\x04\xa2\x0e\x02\n\n\
    \r\n\x05\x04'\x02\x1f\x05\x12\x04\xa2\x0e\x0b\x11\n\r\n\x05\x04'\x02\x1f\
    \x01\x12\x04\xa2\x0e\x12\x1b\n\r\n\x05\x04'\x02\x1f\x03\x12\x04\xa2\x0e\
    \x1e\x20\n\x0c\n\x04\x04'\x02\x20\x12\x04\xa3\x0e\x02'\n\r\n\x05\x04'\
    \x02\x20\x04\x12\x04\xa3\x0e\x02\n\n\r\n\x05\x04'\x02\x20\x05\x12\x04\
    \xa3\x0e\x0b\x11\n\r\n\x05\x04'\x02\x20\x01\x12\x04\xa3\x0e\x12!\n\r\n\
    \x05\x04'\x02\x20\x03\x12\x04\xa3\x0e$&\n\x0c\n\x04\x04'\x02!\x12\x04\
    \xa4\x0e\x02\"\n\r\n\x05\x04'\x02!\x04\x12\x04\xa4\x0e\x02\n\n\r\n\x05\
    \x04'\x02!\x05\x12\x04\xa4\x0e\x0b\x11\n\r\n\x05\x04'\x02!\x01\x12\x04\
    \xa4\x0e\x12\x1c\n\r\n\x05\x04'\x02!\x03\x12\x04\xa4\x0e\x1f!\n\x0c\n\
    \x04\x04'\x02\"\x12\x04\xa5\x0e\x02(\n\r\n\x05\x04'\x02\"\x04\x12\x04\
    \xa5\x0e\x02\n\n\r\n\x05\x04'\x02\"\x05\x12\x04\xa5\x0e\x0b\x11\n\r\n\
    \x05\x04'\x02\"\x01\x12\x04\xa5\x0e\x12\"\n\r\n\x05\x04'\x02\"\x03\x12\
    \x04\xa5\x0e%'\n\x0c\n\x04\x04'\x02#\x12\x04\xa6\x0e\x02&\n\r\n\x05\x04'\
    \x02#\x04\x12\x04\xa6\x0e\x02\n\n\r\n\x05\x04'\x02#\x05\x12\x04\xa6\x0e\
    \x0b\x11\n\r\n\x05\x04'\x02#\x01\x12\x04\xa6\x0e\x12\x20\n\r\n\x05\x04'\
    \x02#\x03\x12\x04\xa6\x0e#%\n\x0c\n\x04\x04'\x02$\x12\x04\xa7\x0e\x02+\n\
    \r\n\x05\x04'\x02$\x04\x12\x04\xa7\x0e\x02\n\n\r\n\x05\x04'\x02$\x05\x12\
    \x04\xa7\x0e\x0b\x11\n\r\n\x05\x04'\x02$\x01\x12\x04\xa7\x0e\x12%\n\r\n\
    \x05\x04'\x02$\x03\x12\x04\xa7\x0e(*\n\x0c\n\x04\x04'\x02%\x12\x04\xa8\
    \x0e\x02\"\n\r\n\x05\x04'\x02%\x04\x12\x04\xa8\x0e\x02\n\n\r\n\x05\x04'\
    \x02%\x05\x12\x04\xa8\x0e\x0b\x11\n\r\n\x05\x04'\x02%\x01\x12\x04\xa8\
    \x0e\x12\x1c\n\r\n\x05\x04'\x02%\x03\x12\x04\xa8\x0e\x1f!\n\x0c\n\x04\
    \x04'\x02&\x12\x04\xa9\x0e\x02(\n\r\n\x05\x04'\x02&\x04\x12\x04\xa9\x0e\
    \x02\n\n\r\n\x05\x04'\x02&\x05\x12\x04\xa9\x0e\x0b\x11\n\r\n\x05\x04'\
    \x02&\x01\x12\x04\xa9\x0e\x12\"\n\r\n\x05\x04'\x02&\x03\x12\x04\xa9\x0e%\
    '\n\x0c\n\x04\x04'\x02'\x12\x04\xaa\x0e\x02#\n\r\n\x05\x04'\x02'\x04\x12\
    \x04\xaa\x0e\x02\n\n\r\n\x05\x04'\x02'\x05\x12\x04\xaa\x0e\x0b\x11\n\r\n\
    \x05\x04'\x02'\x01\x12\x04\xaa\x0e\x12\x1d\n\r\n\x05\x04'\x02'\x03\x12\
    \x04\xaa\x0e\x20\"\n\x0c\n\x04\x04'\x02(\x12\x04\xab\x0e\x02)\n\r\n\x05\
    \x04'\x02(\x04\x12\x04\xab\x0e\x02\n\n\r\n\x05\x04'\x02(\x05\x12\x04\xab\
    \x0e\x0b\x11\n\r\n\x05\x04'\x02(\x01\x12\x04\xab\x0e\x12#\n\r\n\x05\x04'\
    \x02(\x03\x12\x04\xab\x0e&(\n\x0c\n\x04\x04'\x02)\x12\x04\xac\x0e\x02'\n\
    \r\n\x05\x04'\x02)\x04\x12\x04\xac\x0e\x02\n\n\r\n\x05\x04'\x02)\x05\x12\
    \x04\xac\x0e\x0b\x11\n\r\n\x05\x04'\x02)\x01\x12\x04\xac\x0e\x12!\n\r\n\
    \x05\x04'\x02)\x03\x12\x04\xac\x0e$&\n\x0c\n\x04\x04'\x02*\x12\x04\xad\
    \x0e\x02,\n\r\n\x05\x04'\x02*\x04\x12\x04\xad\x0e\x02\n\n\r\n\x05\x04'\
    \x02*\x05\x12\x04\xad\x0e\x0b\x11\n\r\n\x05\x04'\x02*\x01\x12\x04\xad\
    \x0e\x12&\n\r\n\x05\x04'\x02*\x03\x12\x04\xad\x0e)+\n\x0c\n\x04\x04'\x02\
    +\x12\x04\xae\x0e\x02\"\n\r\n\x05\x04'\x02+\x04\x12\x04\xae\x0e\x02\n\n\
    \r\n\x05\x04'\x02+\x05\x12\x04\xae\x0e\x0b\x11\n\r\n\x05\x04'\x02+\x01\
    \x12\x04\xae\x0e\x12\x1c\n\r\n\x05\x04'\x02+\x03\x12\x04\xae\x0e\x1f!\n\
    \x0c\n\x04\x04'\x02,\x12\x04\xaf\x0e\x02(\n\r\n\x05\x04'\x02,\x04\x12\
    \x04\xaf\x0e\x02\n\n\r\n\x05\x04'\x02,\x05\x12\x04\xaf\x0e\x0b\x11\n\r\n\
    \x05\x04'\x02,\x01\x12\x04\xaf\x0e\x12\"\n\r\n\x05\x04'\x02,\x03\x12\x04\
    \xaf\x0e%'\n\x0c\n\x04\x04'\x02-\x12\x04\xb0\x0e\x02$\n\r\n\x05\x04'\x02\
    -\x04\x12\x04\xb0\x0e\x02\n\n\r\n\x05\x04'\x02-\x05\x12\x04\xb0\x0e\x0b\
    \x11\n\r\n\x05\x04'\x02-\x01\x12\x04\xb0\x0e\x12\x1e\n\r\n\x05\x04'\x02-\
    \x03\x12\x04\xb0\x0e!#\n\x0c\n\x04\x04'\x02.\x12\x04\xb1\x0e\x02*\n\r\n\
    \x05\x04'\x02.\x04\x12\x04\xb1\x0e\x02\n\n\r\n\x05\x04'\x02.\x05\x12\x04\
    \xb1\x0e\x0b\x11\n\r\n\x05\x04'\x02.\x01\x12\x04\xb1\x0e\x12$\n\r\n\x05\
    \x04'\x02.\x03\x12\x04\xb1\x0e')\n\x0c\n\x04\x04'\x02/\x12\x04\xb2\x0e\
    \x02\"\n\r\n\x05\x04'\x02/\x04\x12\x04\xb2\x0e\x02\n\n\r\n\x05\x04'\x02/\
    \x05\x12\x04\xb2\x0e\x0b\x11\n\r\n\x05\x04'\x02/\x01\x12\x04\xb2\x0e\x12\
    \x1c\n\r\n\x05\x04'\x02/\x03\x12\x04\xb2\x0e\x1f!\n\x0c\n\x04\x04'\x020\
    \x12\x04\xb3\x0e\x02(\n\r\n\x05\x04'\x020\x04\x12\x04\xb3\x0e\x02\n\n\r\
    \n\x05\x04'\x020\x05\x12\x04\xb3\x0e\x0b\x11\n\r\n\x05\x04'\x020\x01\x12\
    \x04\xb3\x0e\x12\"\n\r\n\x05\x04'\x020\x03\x12\x04\xb3\x0e%'\n\x0c\n\x04\
    \x04'\x021\x12\x04\xb4\x0e\x02#\n\r\n\x05\x04'\x021\x04\x12\x04\xb4\x0e\
    \x02\n\n\r\n\x05\x04'\x021\x05\x12\x04\xb4\x0e\x0b\x11\n\r\n\x05\x04'\
    \x021\x01\x12\x04\xb4\x0e\x12\x1d\n\r\n\x05\x04'\x021\x03\x12\x04\xb4\
    \x0e\x20\"\n\x0c\n\x04\x04'\x022\x12\x04\xb5\x0e\x02)\n\r\n\x05\x04'\x02\
    2\x04\x12\x04\xb5\x0e\x02\n\n\r\n\x05\x04'\x022\x05\x12\x04\xb5\x0e\x0b\
    \x11\n\r\n\x05\x04'\x022\x01\x12\x04\xb5\x0e\x12#\n\r\n\x05\x04'\x022\
    \x03\x12\x04\xb5\x0e&(\n\x0c\n\x04\x04'\x023\x12\x04\xb6\x0e\x02'\n\r\n\
    \x05\x04'\x023\x04\x12\x04\xb6\x0e\x02\n\n\r\n\x05\x04'\x023\x05\x12\x04\
    \xb6\x0e\x0b\x11\n\r\n\x05\x04'\x023\x01\x12\x04\xb6\x0e\x12!\n\r\n\x05\
    \x04'\x023\x03\x12\x04\xb6\x0e$&\n\x0c\n\x04\x04'\x024\x12\x04\xb7\x0e\
    \x02,\n\r\n\x05\x04'\x024\x04\x12\x04\xb7\x0e\x02\n\n\r\n\x05\x04'\x024\
    \x05\x12\x04\xb7\x0e\x0b\x11\n\r\n\x05\x04'\x024\x01\x12\x04\xb7\x0e\x12\
    &\n\r\n\x05\x04'\x024\x03\x12\x04\xb7\x0e)+\n\xe1\x01\n\x02\x04(\x12\x06\
    \xc1\x0e\0\xc4\x0e\x01\x1a\xd2\x01*\n\x20Describes\x20a\x20request\x20fo\
    r\x20resources\x20that\x20can\x20be\x20used\x20by\x20a\x20framework\n\
    \x20to\x20proactively\x20influence\x20the\x20allocator.\x20\x20If\x20'ag\
    ent_id'\x20is\x20provided\n\x20then\x20this\x20request\x20is\x20assumed\
    \x20to\x20only\x20apply\x20to\x20resources\x20on\x20that\n\x20agent.\n\n\
    \x0b\n\x03\x04(\x01\x12\x04\xc1\x0e\x08\x0f\n\x0c\n\x04\x04(\x02\0\x12\
    \x04\xc2\x0e\x02\x20\n\r\n\x05\x04(\x02\0\x04\x12\x04\xc2\x0e\x02\n\n\r\
    \n\x05\x04(\x02\0\x06\x12\x04\xc2\x0e\x0b\x12\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\xc2\x0e\x13\x1b\n\r\n\x05\x04(\x02\0\x03\x12\x04\xc2\x0e\x1e\
    \x1f\n\x0c\n\x04\x04(\x02\x01\x12\x04\xc3\x0e\x02\"\n\r\n\x05\x04(\x02\
    \x01\x04\x12\x04\xc3\x0e\x02\n\n\r\n\x05\x04(\x02\x01\x06\x12\x04\xc3\
    \x0e\x0b\x13\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xc3\x0e\x14\x1d\n\r\n\
    \x05\x04(\x02\x01\x03\x12\x04\xc3\x0e\x20!\nx\n\x02\x04)\x12\x06\xcb\x0e\
    \0\xc2\x0f\x01\x1aj*\n\x20Describes\x20some\x20resources\x20available\
    \x20on\x20an\x20agent.\x20An\x20offer\x20only\n\x20contains\x20resources\
    \x20from\x20a\x20single\x20agent.\n\n\x0b\n\x03\x04)\x01\x12\x04\xcb\x0e\
    \x08\r\n\x0c\n\x04\x04)\x02\0\x12\x04\xcc\x0e\x02\x1a\n\r\n\x05\x04)\x02\
    \0\x04\x12\x04\xcc\x0e\x02\n\n\r\n\x05\x04)\x02\0\x06\x12\x04\xcc\x0e\
    \x0b\x12\n\r\n\x05\x04)\x02\0\x01\x12\x04\xcc\x0e\x13\x15\n\r\n\x05\x04)\
    \x02\0\x03\x12\x04\xcc\x0e\x18\x19\n\x0c\n\x04\x04)\x02\x01\x12\x04\xcd\
    \x0e\x02(\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xcd\x0e\x02\n\n\r\n\x05\x04\
    )\x02\x01\x06\x12\x04\xcd\x0e\x0b\x16\n\r\n\x05\x04)\x02\x01\x01\x12\x04\
    \xcd\x0e\x17#\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xcd\x0e&'\n\x0c\n\x04\
    \x04)\x02\x02\x12\x04\xce\x0e\x02\x20\n\r\n\x05\x04)\x02\x02\x04\x12\x04\
    \xce\x0e\x02\n\n\r\n\x05\x04)\x02\x02\x06\x12\x04\xce\x0e\x0b\x12\n\r\n\
    \x05\x04)\x02\x02\x01\x12\x04\xce\x0e\x13\x1b\n\r\n\x05\x04)\x02\x02\x03\
    \x12\x04\xce\x0e\x1e\x1f\n\x0c\n\x04\x04)\x02\x03\x12\x04\xcf\x0e\x02\
    \x1f\n\r\n\x05\x04)\x02\x03\x04\x12\x04\xcf\x0e\x02\n\n\r\n\x05\x04)\x02\
    \x03\x05\x12\x04\xcf\x0e\x0b\x11\n\r\n\x05\x04)\x02\x03\x01\x12\x04\xcf\
    \x0e\x12\x1a\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xcf\x0e\x1d\x1e\n?\n\x04\
    \x04)\x02\x04\x12\x04\xd2\x0e\x02\x17\x1a1\x20URL\x20for\x20reaching\x20\
    the\x20agent\x20running\x20on\x20the\x20host.\n\n\r\n\x05\x04)\x02\x04\
    \x04\x12\x04\xd2\x0e\x02\n\n\r\n\x05\x04)\x02\x04\x06\x12\x04\xd2\x0e\
    \x0b\x0e\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xd2\x0e\x0f\x12\n\r\n\x05\
    \x04)\x02\x04\x03\x12\x04\xd2\x0e\x15\x16\n(\n\x04\x04)\x02\x05\x12\x04\
    \xd5\x0e\x02\"\x1a\x1a\x20The\x20domain\x20of\x20the\x20agent.\n\n\r\n\
    \x05\x04)\x02\x05\x04\x12\x04\xd5\x0e\x02\n\n\r\n\x05\x04)\x02\x05\x06\
    \x12\x04\xd5\x0e\x0b\x15\n\r\n\x05\x04)\x02\x05\x01\x12\x04\xd5\x0e\x16\
    \x1c\n\r\n\x05\x04)\x02\x05\x03\x12\x04\xd5\x0e\x1f!\n\x0c\n\x04\x04)\
    \x02\x06\x12\x04\xd7\x0e\x02\"\n\r\n\x05\x04)\x02\x06\x04\x12\x04\xd7\
    \x0e\x02\n\n\r\n\x05\x04)\x02\x06\x06\x12\x04\xd7\x0e\x0b\x13\n\r\n\x05\
    \x04)\x02\x06\x01\x12\x04\xd7\x0e\x14\x1d\n\r\n\x05\x04)\x02\x06\x03\x12\
    \x04\xd7\x0e\x20!\n\x0c\n\x04\x04)\x02\x07\x12\x04\xd8\x0e\x02$\n\r\n\
    \x05\x04)\x02\x07\x04\x12\x04\xd8\x0e\x02\n\n\r\n\x05\x04)\x02\x07\x06\
    \x12\x04\xd8\x0e\x0b\x14\n\r\n\x05\x04)\x02\x07\x01\x12\x04\xd8\x0e\x15\
    \x1f\n\r\n\x05\x04)\x02\x07\x03\x12\x04\xd8\x0e\"#\n\x0c\n\x04\x04)\x02\
    \x08\x12\x04\xd9\x0e\x02'\n\r\n\x05\x04)\x02\x08\x04\x12\x04\xd9\x0e\x02\
    \n\n\r\n\x05\x04)\x02\x08\x06\x12\x04\xd9\x0e\x0b\x15\n\r\n\x05\x04)\x02\
    \x08\x01\x12\x04\xd9\x0e\x16\"\n\r\n\x05\x04)\x02\x08\x03\x12\x04\xd9\
    \x0e%&\n\xb7\x04\n\x04\x04)\x02\t\x12\x04\xe5\x0e\x02-\x1a\xa8\x04\x20Si\
    gnifies\x20that\x20the\x20resources\x20in\x20this\x20Offer\x20may\x20be\
    \x20unavailable\x20during\n\x20the\x20given\x20interval.\x20\x20Any\x20t\
    asks\x20launched\x20using\x20these\x20resources\x20may\x20be\n\x20killed\
    \x20when\x20the\x20interval\x20arrives.\x20\x20For\x20example,\x20these\
    \x20resources\x20may\x20be\n\x20part\x20of\x20a\x20planned\x20maintenanc\
    e\x20schedule.\n\n\x20This\x20field\x20only\x20provides\x20information\
    \x20about\x20a\x20planned\x20unavailability.\n\x20The\x20unavailability\
    \x20interval\x20may\x20not\x20necessarily\x20start\x20at\x20exactly\x20t\
    his\n\x20interval,\x20nor\x20last\x20for\x20exactly\x20the\x20duration\
    \x20of\x20this\x20interval.\n\x20The\x20unavailability\x20may\x20also\
    \x20be\x20forever!\x20\x20See\x20comments\x20in\n\x20`Unavailability`\
    \x20for\x20more\x20details.\n\n\r\n\x05\x04)\x02\t\x04\x12\x04\xe5\x0e\
    \x02\n\n\r\n\x05\x04)\x02\t\x06\x12\x04\xe5\x0e\x0b\x19\n\r\n\x05\x04)\
    \x02\t\x01\x12\x04\xe5\x0e\x1a(\n\r\n\x05\x04)\x02\t\x03\x12\x04\xe5\x0e\
    +,\n\xd4\x01\n\x04\x04)\x02\n\x12\x04\xeb\x0e\x028\x1a\xc5\x01\x20An\x20\
    offer\x20represents\x20resources\x20allocated\x20to\x20*one*\x20of\x20th\
    e\n\x20roles\x20managed\x20by\x20the\x20scheduler.\x20(Therefore,\x20eac\
    h\n\x20`Offer.resources[i].allocation_info`\x20will\x20match\x20the\n\
    \x20top\x20level\x20`Offer.allocation_info`).\n\n\r\n\x05\x04)\x02\n\x04\
    \x12\x04\xeb\x0e\x02\n\n\r\n\x05\x04)\x02\n\x06\x12\x04\xeb\x0e\x0b\"\n\
    \r\n\x05\x04)\x02\n\x01\x12\x04\xeb\x0e#2\n\r\n\x05\x04)\x02\n\x03\x12\
    \x04\xeb\x0e57\nL\n\x04\x04)\x03\0\x12\x06\xee\x0e\x02\xc1\x0f\x03\x1a<\
    \x20Defines\x20an\x20operation\x20that\x20can\x20be\x20performed\x20agai\
    nst\x20offers.\n\n\r\n\x05\x04)\x03\0\x01\x12\x04\xee\x0e\n\x13\n\x10\n\
    \x06\x04)\x03\0\x04\0\x12\x06\xef\x0e\x04\xfb\x0e\x05\n\x0f\n\x07\x04)\
    \x03\0\x04\0\x01\x12\x04\xef\x0e\t\r\n\x10\n\x08\x04)\x03\0\x04\0\x02\0\
    \x12\x04\xf0\x0e\x06\x12\n\x11\n\t\x04)\x03\0\x04\0\x02\0\x01\x12\x04\
    \xf0\x0e\x06\r\n\x11\n\t\x04)\x03\0\x04\0\x02\0\x02\x12\x04\xf0\x0e\x10\
    \x11\n\x10\n\x08\x04)\x03\0\x04\0\x02\x01\x12\x04\xf1\x0e\x06\x11\n\x11\
    \n\t\x04)\x03\0\x04\0\x02\x01\x01\x12\x04\xf1\x0e\x06\x0c\n\x11\n\t\x04)\
    \x03\0\x04\0\x02\x01\x02\x12\x04\xf1\x0e\x0f\x10\n\x10\n\x08\x04)\x03\0\
    \x04\0\x02\x02\x12\x04\xf2\x0e\x06\x17\n\x11\n\t\x04)\x03\0\x04\0\x02\
    \x02\x01\x12\x04\xf2\x0e\x06\x12\n\x11\n\t\x04)\x03\0\x04\0\x02\x02\x02\
    \x12\x04\xf2\x0e\x15\x16\n\x10\n\x08\x04)\x03\0\x04\0\x02\x03\x12\x04\
    \xf3\x0e\x06\x12\n\x11\n\t\x04)\x03\0\x04\0\x02\x03\x01\x12\x04\xf3\x0e\
    \x06\r\n\x11\n\t\x04)\x03\0\x04\0\x02\x03\x02\x12\x04\xf3\x0e\x10\x11\n\
    \x10\n\x08\x04)\x03\0\x04\0\x02\x04\x12\x04\xf4\x0e\x06\x14\n\x11\n\t\
    \x04)\x03\0\x04\0\x02\x04\x01\x12\x04\xf4\x0e\x06\x0f\n\x11\n\t\x04)\x03\
    \0\x04\0\x02\x04\x02\x12\x04\xf4\x0e\x12\x13\n\x10\n\x08\x04)\x03\0\x04\
    \0\x02\x05\x12\x04\xf5\x0e\x06\x11\n\x11\n\t\x04)\x03\0\x04\0\x02\x05\
    \x01\x12\x04\xf5\x0e\x06\x0c\n\x11\n\t\x04)\x03\0\x04\0\x02\x05\x02\x12\
    \x04\xf5\x0e\x0f\x10\n\x10\n\x08\x04)\x03\0\x04\0\x02\x06\x12\x04\xf6\
    \x0e\x06\x12\n\x11\n\t\x04)\x03\0\x04\0\x02\x06\x01\x12\x04\xf6\x0e\x06\
    \r\n\x11\n\t\x04)\x03\0\x04\0\x02\x06\x02\x12\x04\xf6\x0e\x10\x11\n\x10\
    \n\x08\x04)\x03\0\x04\0\x02\x07\x12\x04\xf7\x0e\x06\x18\n\x11\n\t\x04)\
    \x03\0\x04\0\x02\x07\x01\x12\x04\xf7\x0e\x06\x13\n\x11\n\t\x04)\x03\0\
    \x04\0\x02\x07\x02\x12\x04\xf7\x0e\x16\x17\n\x10\n\x08\x04)\x03\0\x04\0\
    \x02\x08\x12\x04\xf8\x0e\x06\x19\n\x11\n\t\x04)\x03\0\x04\0\x02\x08\x01\
    \x12\x04\xf8\x0e\x06\x14\n\x11\n\t\x04)\x03\0\x04\0\x02\x08\x02\x12\x04\
    \xf8\x0e\x17\x18\n\x10\n\x08\x04)\x03\0\x04\0\x02\t\x12\x04\xf9\x0e\x06\
    \x17\n\x11\n\t\x04)\x03\0\x04\0\x02\t\x01\x12\x04\xf9\x0e\x06\x12\n\x11\
    \n\t\x04)\x03\0\x04\0\x02\t\x02\x12\x04\xf9\x0e\x15\x16\n\x10\n\x08\x04)\
    \x03\0\x04\0\x02\n\x12\x04\xfa\x0e\x06\x19\n\x11\n\t\x04)\x03\0\x04\0\
    \x02\n\x01\x12\x04\xfa\x0e\x06\x13\n\x11\n\t\x04)\x03\0\x04\0\x02\n\x02\
    \x12\x04\xfa\x0e\x16\x18\nP\n\x06\x04)\x03\0\x03\0\x12\x06\xfe\x0e\x04\
    \x80\x0f\x05\x1a>\x20TODO(vinod):\x20Deprecate\x20this\x20in\x20favor\
    \x20of\x20`LaunchGroup`\x20below.\n\n\x0f\n\x07\x04)\x03\0\x03\0\x01\x12\
    \x04\xfe\x0e\x0c\x12\n\x10\n\x08\x04)\x03\0\x03\0\x02\0\x12\x04\xff\x0e\
    \x06'\n\x11\n\t\x04)\x03\0\x03\0\x02\0\x04\x12\x04\xff\x0e\x06\x0e\n\x11\
    \n\t\x04)\x03\0\x03\0\x02\0\x06\x12\x04\xff\x0e\x0f\x17\n\x11\n\t\x04)\
    \x03\0\x03\0\x02\0\x01\x12\x04\xff\x0e\x18\"\n\x11\n\t\x04)\x03\0\x03\0\
    \x02\0\x03\x12\x04\xff\x0e%&\n\xc1\x02\n\x06\x04)\x03\0\x03\x01\x12\x06\
    \x8a\x0f\x04\x8d\x0f\x05\x1a\xae\x02\x20Unlike\x20`Launch`\x20above,\x20\
    all\x20the\x20tasks\x20in\x20a\x20`task_group`\x20are\n\x20atomically\
    \x20delivered\x20to\x20an\x20executor.\n\n\x20`NetworkInfo`\x20set\x20on\
    \x20executor\x20will\x20be\x20shared\x20by\x20all\x20tasks\x20in\n\x20th\
    e\x20task\x20group.\n\n\x20TODO(vinod):\x20Any\x20volumes\x20set\x20on\
    \x20executor\x20could\x20be\x20used\x20by\x20a\n\x20task\x20by\x20explic\
    itly\x20setting\x20`Volume.source`\x20in\x20its\x20resources.\n\n\x0f\n\
    \x07\x04)\x03\0\x03\x01\x01\x12\x04\x8a\x0f\x0c\x17\n\x10\n\x08\x04)\x03\
    \0\x03\x01\x02\0\x12\x04\x8b\x0f\x06)\n\x11\n\t\x04)\x03\0\x03\x01\x02\0\
    \x04\x12\x04\x8b\x0f\x06\x0e\n\x11\n\t\x04)\x03\0\x03\x01\x02\0\x06\x12\
    \x04\x8b\x0f\x0f\x1b\n\x11\n\t\x04)\x03\0\x03\x01\x02\0\x01\x12\x04\x8b\
    \x0f\x1c$\n\x11\n\t\x04)\x03\0\x03\x01\x02\0\x03\x12\x04\x8b\x0f'(\n\x10\
    \n\x08\x04)\x03\0\x03\x01\x02\x01\x12\x04\x8c\x0f\x06,\n\x11\n\t\x04)\
    \x03\0\x03\x01\x02\x01\x04\x12\x04\x8c\x0f\x06\x0e\n\x11\n\t\x04)\x03\0\
    \x03\x01\x02\x01\x06\x12\x04\x8c\x0f\x0f\x1c\n\x11\n\t\x04)\x03\0\x03\
    \x01\x02\x01\x01\x12\x04\x8c\x0f\x1d'\n\x11\n\t\x04)\x03\0\x03\x01\x02\
    \x01\x03\x12\x04\x8c\x0f*+\n\x10\n\x06\x04)\x03\0\x03\x02\x12\x06\x8f\
    \x0f\x04\x91\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\x02\x01\x12\x04\x8f\x0f\
    \x0c\x13\n\x10\n\x08\x04)\x03\0\x03\x02\x02\0\x12\x04\x90\x0f\x06&\n\x11\
    \n\t\x04)\x03\0\x03\x02\x02\0\x04\x12\x04\x90\x0f\x06\x0e\n\x11\n\t\x04)\
    \x03\0\x03\x02\x02\0\x06\x12\x04\x90\x0f\x0f\x17\n\x11\n\t\x04)\x03\0\
    \x03\x02\x02\0\x01\x12\x04\x90\x0f\x18!\n\x11\n\t\x04)\x03\0\x03\x02\x02\
    \0\x03\x12\x04\x90\x0f$%\n\x10\n\x06\x04)\x03\0\x03\x03\x12\x06\x93\x0f\
    \x04\x95\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\x03\x01\x12\x04\x93\x0f\x0c\
    \x15\n\x10\n\x08\x04)\x03\0\x03\x03\x02\0\x12\x04\x94\x0f\x06&\n\x11\n\t\
    \x04)\x03\0\x03\x03\x02\0\x04\x12\x04\x94\x0f\x06\x0e\n\x11\n\t\x04)\x03\
    \0\x03\x03\x02\0\x06\x12\x04\x94\x0f\x0f\x17\n\x11\n\t\x04)\x03\0\x03\
    \x03\x02\0\x01\x12\x04\x94\x0f\x18!\n\x11\n\t\x04)\x03\0\x03\x03\x02\0\
    \x03\x12\x04\x94\x0f$%\n\x10\n\x06\x04)\x03\0\x03\x04\x12\x06\x97\x0f\
    \x04\x99\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\x04\x01\x12\x04\x97\x0f\x0c\
    \x12\n\x10\n\x08\x04)\x03\0\x03\x04\x02\0\x12\x04\x98\x0f\x06$\n\x11\n\t\
    \x04)\x03\0\x03\x04\x02\0\x04\x12\x04\x98\x0f\x06\x0e\n\x11\n\t\x04)\x03\
    \0\x03\x04\x02\0\x06\x12\x04\x98\x0f\x0f\x17\n\x11\n\t\x04)\x03\0\x03\
    \x04\x02\0\x01\x12\x04\x98\x0f\x18\x1f\n\x11\n\t\x04)\x03\0\x03\x04\x02\
    \0\x03\x12\x04\x98\x0f\"#\n\x10\n\x06\x04)\x03\0\x03\x05\x12\x06\x9b\x0f\
    \x04\x9d\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\x05\x01\x12\x04\x9b\x0f\x0c\
    \x13\n\x10\n\x08\x04)\x03\0\x03\x05\x02\0\x12\x04\x9c\x0f\x06$\n\x11\n\t\
    \x04)\x03\0\x03\x05\x02\0\x04\x12\x04\x9c\x0f\x06\x0e\n\x11\n\t\x04)\x03\
    \0\x03\x05\x02\0\x06\x12\x04\x9c\x0f\x0f\x17\n\x11\n\t\x04)\x03\0\x03\
    \x05\x02\0\x01\x12\x04\x9c\x0f\x18\x1f\n\x11\n\t\x04)\x03\0\x03\x05\x02\
    \0\x03\x12\x04\x9c\x0f\"#\n\x10\n\x06\x04)\x03\0\x03\x06\x12\x06\x9f\x0f\
    \x04\xa2\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\x06\x01\x12\x04\x9f\x0f\x0c\
    \x18\n\x10\n\x08\x04)\x03\0\x03\x06\x02\0\x12\x04\xa0\x0f\x06#\n\x11\n\t\
    \x04)\x03\0\x03\x06\x02\0\x04\x12\x04\xa0\x0f\x06\x0e\n\x11\n\t\x04)\x03\
    \0\x03\x06\x02\0\x06\x12\x04\xa0\x0f\x0f\x17\n\x11\n\t\x04)\x03\0\x03\
    \x06\x02\0\x01\x12\x04\xa0\x0f\x18\x1e\n\x11\n\t\x04)\x03\0\x03\x06\x02\
    \0\x03\x12\x04\xa0\x0f!\"\n\x10\n\x08\x04)\x03\0\x03\x06\x02\x01\x12\x04\
    \xa1\x0f\x06=\n\x11\n\t\x04)\x03\0\x03\x06\x02\x01\x04\x12\x04\xa1\x0f\
    \x06\x0e\n\x11\n\t\x04)\x03\0\x03\x06\x02\x01\x06\x12\x04\xa1\x0f\x0f,\n\
    \x11\n\t\x04)\x03\0\x03\x06\x02\x01\x01\x12\x04\xa1\x0f-8\n\x11\n\t\x04)\
    \x03\0\x03\x06\x02\x01\x03\x12\x04\xa1\x0f;<\n\x10\n\x06\x04)\x03\0\x03\
    \x07\x12\x06\xa4\x0f\x04\xa6\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\x07\x01\
    \x12\x04\xa4\x0f\x0c\x19\n\x10\n\x08\x04)\x03\0\x03\x07\x02\0\x12\x04\
    \xa5\x0f\x06#\n\x11\n\t\x04)\x03\0\x03\x07\x02\0\x04\x12\x04\xa5\x0f\x06\
    \x0e\n\x11\n\t\x04)\x03\0\x03\x07\x02\0\x06\x12\x04\xa5\x0f\x0f\x17\n\
    \x11\n\t\x04)\x03\0\x03\x07\x02\0\x01\x12\x04\xa5\x0f\x18\x1e\n\x11\n\t\
    \x04)\x03\0\x03\x07\x02\0\x03\x12\x04\xa5\x0f!\"\n\x10\n\x06\x04)\x03\0\
    \x03\x08\x12\x06\xa8\x0f\x04\xaa\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\x08\
    \x01\x12\x04\xa8\x0f\x0c\x17\n\x10\n\x08\x04)\x03\0\x03\x08\x02\0\x12\
    \x04\xa9\x0f\x06#\n\x11\n\t\x04)\x03\0\x03\x08\x02\0\x04\x12\x04\xa9\x0f\
    \x06\x0e\n\x11\n\t\x04)\x03\0\x03\x08\x02\0\x06\x12\x04\xa9\x0f\x0f\x17\
    \n\x11\n\t\x04)\x03\0\x03\x08\x02\0\x01\x12\x04\xa9\x0f\x18\x1e\n\x11\n\
    \t\x04)\x03\0\x03\x08\x02\0\x03\x12\x04\xa9\x0f!\"\n\x10\n\x06\x04)\x03\
    \0\x03\t\x12\x06\xac\x0f\x04\xae\x0f\x05\n\x0f\n\x07\x04)\x03\0\x03\t\
    \x01\x12\x04\xac\x0f\x0c\x18\n\x10\n\x08\x04)\x03\0\x03\t\x02\0\x12\x04\
    \xad\x0f\x06\"\n\x11\n\t\x04)\x03\0\x03\t\x02\0\x04\x12\x04\xad\x0f\x06\
    \x0e\n\x11\n\t\x04)\x03\0\x03\t\x02\0\x06\x12\x04\xad\x0f\x0f\x17\n\x11\
    \n\t\x04)\x03\0\x03\t\x02\0\x01\x12\x04\xad\x0f\x18\x1d\n\x11\n\t\x04)\
    \x03\0\x03\t\x02\0\x03\x12\x04\xad\x0f\x20!\n\x0e\n\x06\x04)\x03\0\x02\0\
    \x12\x04\xb0\x0f\x04\x1b\n\x0f\n\x07\x04)\x03\0\x02\0\x04\x12\x04\xb0\
    \x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\0\x06\x12\x04\xb0\x0f\r\x11\n\
    \x0f\n\x07\x04)\x03\0\x02\0\x01\x12\x04\xb0\x0f\x12\x16\n\x0f\n\x07\x04)\
    \x03\0\x02\0\x03\x12\x04\xb0\x0f\x19\x1a\n\xfb\x01\n\x06\x04)\x03\0\x02\
    \x01\x12\x04\xb5\x0f\x04!\x1a\xd9\x01\x20NOTE:\x20The\x20`id`\x20field\
    \x20will\x20allow\x20frameworks\x20to\x20indicate\x20that\x20they\x20wis\
    h\x20to\n\x20receive\x20feedback\x20about\x20an\x20operation.\x20Since\
    \x20this\x20feature\x20is\x20not\x20yet\n\x20implemented,\x20the\x20`id`\
    \x20field\x20should\x20NOT\x20be\x20set\x20at\x20present.\x20See\x20MESO\
    S-8054.\n\"\x0f\x20Experimental.\n\n\x0f\n\x07\x04)\x03\0\x02\x01\x04\
    \x12\x04\xb5\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\x01\x06\x12\x04\xb5\
    \x0f\r\x18\n\x0f\n\x07\x04)\x03\0\x02\x01\x01\x12\x04\xb5\x0f\x19\x1b\n\
    \x0f\n\x07\x04)\x03\0\x02\x01\x03\x12\x04\xb5\x0f\x1e\x20\n\x0e\n\x06\
    \x04)\x03\0\x02\x02\x12\x04\xb7\x0f\x04\x1f\n\x0f\n\x07\x04)\x03\0\x02\
    \x02\x04\x12\x04\xb7\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\x02\x06\x12\
    \x04\xb7\x0f\r\x13\n\x0f\n\x07\x04)\x03\0\x02\x02\x01\x12\x04\xb7\x0f\
    \x14\x1a\n\x0f\n\x07\x04)\x03\0\x02\x02\x03\x12\x04\xb7\x0f\x1d\x1e\n\
    \x0e\n\x06\x04)\x03\0\x02\x03\x12\x04\xb8\x0f\x04*\n\x0f\n\x07\x04)\x03\
    \0\x02\x03\x04\x12\x04\xb8\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\x03\
    \x06\x12\x04\xb8\x0f\r\x18\n\x0f\n\x07\x04)\x03\0\x02\x03\x01\x12\x04\
    \xb8\x0f\x19%\n\x0f\n\x07\x04)\x03\0\x02\x03\x03\x12\x04\xb8\x0f()\n\x0e\
    \n\x06\x04)\x03\0\x02\x04\x12\x04\xb9\x0f\x04!\n\x0f\n\x07\x04)\x03\0\
    \x02\x04\x04\x12\x04\xb9\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\x04\x06\
    \x12\x04\xb9\x0f\r\x14\n\x0f\n\x07\x04)\x03\0\x02\x04\x01\x12\x04\xb9\
    \x0f\x15\x1c\n\x0f\n\x07\x04)\x03\0\x02\x04\x03\x12\x04\xb9\x0f\x1f\x20\
    \n\x0e\n\x06\x04)\x03\0\x02\x05\x12\x04\xba\x0f\x04%\n\x0f\n\x07\x04)\
    \x03\0\x02\x05\x04\x12\x04\xba\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\
    \x05\x06\x12\x04\xba\x0f\r\x16\n\x0f\n\x07\x04)\x03\0\x02\x05\x01\x12\
    \x04\xba\x0f\x17\x20\n\x0f\n\x07\x04)\x03\0\x02\x05\x03\x12\x04\xba\x0f#\
    $\n\x0e\n\x06\x04)\x03\0\x02\x06\x12\x04\xbb\x0f\x04\x1f\n\x0f\n\x07\x04\
    )\x03\0\x02\x06\x04\x12\x04\xbb\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\
    \x06\x06\x12\x04\xbb\x0f\r\x13\n\x0f\n\x07\x04)\x03\0\x02\x06\x01\x12\
    \x04\xbb\x0f\x14\x1a\n\x0f\n\x07\x04)\x03\0\x02\x06\x03\x12\x04\xbb\x0f\
    \x1d\x1e\n\x0e\n\x06\x04)\x03\0\x02\x07\x12\x04\xbc\x0f\x04!\n\x0f\n\x07\
    \x04)\x03\0\x02\x07\x04\x12\x04\xbc\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\
    \x02\x07\x06\x12\x04\xbc\x0f\r\x14\n\x0f\n\x07\x04)\x03\0\x02\x07\x01\
    \x12\x04\xbc\x0f\x15\x1c\n\x0f\n\x07\x04)\x03\0\x02\x07\x03\x12\x04\xbc\
    \x0f\x1f\x20\n\x0e\n\x06\x04)\x03\0\x02\x08\x12\x04\xbd\x0f\x04,\n\x0f\n\
    \x07\x04)\x03\0\x02\x08\x04\x12\x04\xbd\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\
    \0\x02\x08\x06\x12\x04\xbd\x0f\r\x19\n\x0f\n\x07\x04)\x03\0\x02\x08\x01\
    \x12\x04\xbd\x0f\x1a'\n\x0f\n\x07\x04)\x03\0\x02\x08\x03\x12\x04\xbd\x0f\
    *+\n\x0e\n\x06\x04)\x03\0\x02\t\x12\x04\xbe\x0f\x04.\n\x0f\n\x07\x04)\
    \x03\0\x02\t\x04\x12\x04\xbe\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\t\
    \x06\x12\x04\xbe\x0f\r\x1a\n\x0f\n\x07\x04)\x03\0\x02\t\x01\x12\x04\xbe\
    \x0f\x1b)\n\x0f\n\x07\x04)\x03\0\x02\t\x03\x12\x04\xbe\x0f,-\n\x0e\n\x06\
    \x04)\x03\0\x02\n\x12\x04\xbf\x0f\x04+\n\x0f\n\x07\x04)\x03\0\x02\n\x04\
    \x12\x04\xbf\x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\n\x06\x12\x04\xbf\
    \x0f\r\x18\n\x0f\n\x07\x04)\x03\0\x02\n\x01\x12\x04\xbf\x0f\x19%\n\x0f\n\
    \x07\x04)\x03\0\x02\n\x03\x12\x04\xbf\x0f(*\n\x0e\n\x06\x04)\x03\0\x02\
    \x0b\x12\x04\xc0\x0f\x04-\n\x0f\n\x07\x04)\x03\0\x02\x0b\x04\x12\x04\xc0\
    \x0f\x04\x0c\n\x0f\n\x07\x04)\x03\0\x02\x0b\x06\x12\x04\xc0\x0f\r\x19\n\
    \x0f\n\x07\x04)\x03\0\x02\x0b\x01\x12\x04\xc0\x0f\x1a'\n\x0f\n\x07\x04)\
    \x03\0\x02\x0b\x03\x12\x04\xc0\x0f*,\nM\n\x02\x04*\x12\x06\xc8\x0f\0\xf5\
    \x0f\x01\x1a?*\n\x20A\x20request\x20to\x20return\x20some\x20resources\
    \x20occupied\x20by\x20a\x20framework.\n\n\x0b\n\x03\x04*\x01\x12\x04\xc8\
    \x0f\x08\x14\n~\n\x04\x04*\x02\0\x12\x04\xcb\x0f\x02\x1a\x1ap\x20This\
    \x20is\x20the\x20same\x20OfferID\x20as\x20found\x20in\x20normal\x20offer\
    s,\x20which\x20allows\n\x20re-use\x20of\x20some\x20of\x20the\x20OfferID-\
    only\x20messages.\n\n\r\n\x05\x04*\x02\0\x04\x12\x04\xcb\x0f\x02\n\n\r\n\
    \x05\x04*\x02\0\x06\x12\x04\xcb\x0f\x0b\x12\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\xcb\x0f\x13\x15\n\r\n\x05\x04*\x02\0\x03\x12\x04\xcb\x0f\x18\x19\n\
    \xdb\x01\n\x04\x04*\x02\x01\x12\x04\xd0\x0f\x02\x17\x1a\xcc\x01\x20URL\
    \x20for\x20reaching\x20the\x20agent\x20running\x20on\x20the\x20host.\x20\
    \x20This\x20enables\x20some\n\x20optimizations\x20as\x20described\x20in\
    \x20MESOS-3012,\x20such\x20as\x20allowing\x20the\n\x20scheduler\x20drive\
    r\x20to\x20bypass\x20the\x20master\x20and\x20talk\x20directly\x20with\
    \x20an\x20agent.\n\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xd0\x0f\x02\n\n\r\
    \n\x05\x04*\x02\x01\x06\x12\x04\xd0\x0f\x0b\x0e\n\r\n\x05\x04*\x02\x01\
    \x01\x12\x04\xd0\x0f\x0f\x12\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xd0\x0f\
    \x15\x16\n\xa6\x01\n\x04\x04*\x02\x02\x12\x04\xd5\x0f\x02(\x1a\x97\x01\
    \x20The\x20framework\x20that\x20should\x20release\x20its\x20resources.\n\
    \x20If\x20no\x20specifics\x20are\x20provided\x20(i.e.\x20which\x20agent)\
    ,\x20all\x20the\x20framework's\n\x20resources\x20are\x20requested\x20bac\
    k.\n\n\r\n\x05\x04*\x02\x02\x04\x12\x04\xd5\x0f\x02\n\n\r\n\x05\x04*\x02\
    \x02\x06\x12\x04\xd5\x0f\x0b\x16\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xd5\
    \x0f\x17#\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xd5\x0f&'\n\xcd\x01\n\x04\
    \x04*\x02\x03\x12\x04\xda\x0f\x02\x20\x1a\xbe\x01\x20Specified\x20if\x20\
    the\x20resources\x20need\x20to\x20be\x20released\x20from\x20a\x20particu\
    lar\x20agent.\n\x20All\x20the\x20framework's\x20resources\x20on\x20this\
    \x20agent\x20are\x20requested\x20back,\n\x20unless\x20further\x20qualifi\
    ed\x20by\x20the\x20`resources`\x20field.\n\n\r\n\x05\x04*\x02\x03\x04\
    \x12\x04\xda\x0f\x02\n\n\r\n\x05\x04*\x02\x03\x06\x12\x04\xda\x0f\x0b\
    \x12\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xda\x0f\x13\x1b\n\r\n\x05\x04*\
    \x02\x03\x03\x12\x04\xda\x0f\x1e\x1f\n\x9f\x06\n\x04\x04*\x02\x04\x12\
    \x04\xea\x0f\x02-\x1a\x90\x06\x20This\x20InverseOffer\x20represents\x20a\
    \x20planned\x20unavailability\x20event\x20in\x20the\n\x20specified\x20in\
    terval.\x20\x20Any\x20tasks\x20running\x20on\x20the\x20given\x20framewor\
    k\x20or\x20agent\n\x20may\x20be\x20killed\x20when\x20the\x20interval\x20\
    arrives.\x20\x20Therefore,\x20frameworks\x20should\n\x20aim\x20to\x20gra\
    cefully\x20terminate\x20tasks\x20prior\x20to\x20the\x20arrival\x20of\x20\
    the\x20interval.\n\n\x20For\x20reserved\x20resources,\x20the\x20resource\
    s\x20are\x20expected\x20to\x20be\x20returned\x20to\x20the\n\x20framework\
    \x20after\x20the\x20unavailability\x20interval.\x20\x20This\x20is\x20an\
    \x20expectation,\n\x20not\x20a\x20guarantee.\x20\x20For\x20example,\x20i\
    f\x20the\x20unavailability\x20duration\x20is\x20not\x20set,\n\x20the\x20\
    resources\x20may\x20be\x20removed\x20permanently.\n\n\x20For\x20other\
    \x20resources,\x20there\x20is\x20no\x20guarantee\x20that\x20requested\
    \x20resources\x20will\n\x20be\x20returned\x20after\x20the\x20unavailabil\
    ity\x20interval.\x20\x20The\x20allocator\x20has\x20no\n\x20obligation\
    \x20to\x20re-offer\x20these\x20resources\x20to\x20the\x20prior\x20framew\
    ork\x20after\n\x20the\x20unavailability.\n\n\r\n\x05\x04*\x02\x04\x04\
    \x12\x04\xea\x0f\x02\n\n\r\n\x05\x04*\x02\x04\x06\x12\x04\xea\x0f\x0b\
    \x19\n\r\n\x05\x04*\x02\x04\x01\x12\x04\xea\x0f\x1a(\n\r\n\x05\x04*\x02\
    \x04\x03\x12\x04\xea\x0f+,\n\xb2\x02\n\x04\x04*\x02\x05\x12\x04\xf1\x0f\
    \x02\"\x1a\xa3\x02\x20A\x20list\x20of\x20resources\x20being\x20requested\
    \x20back\x20from\x20the\x20framework,\n\x20on\x20the\x20agent\x20identif\
    ied\x20by\x20`agent_id`.\x20\x20If\x20no\x20resources\x20are\x20specifie\
    d\n\x20then\x20all\x20resources\x20are\x20being\x20requested\x20back.\
    \x20\x20For\x20the\x20purpose\x20of\n\x20maintenance,\x20this\x20field\
    \x20is\x20always\x20empty\x20(maintenance\x20always\x20requests\n\x20all\
    \x20resources\x20back).\n\n\r\n\x05\x04*\x02\x05\x04\x12\x04\xf1\x0f\x02\
    \n\n\r\n\x05\x04*\x02\x05\x06\x12\x04\xf1\x0f\x0b\x13\n\r\n\x05\x04*\x02\
    \x05\x01\x12\x04\xf1\x0f\x14\x1d\n\r\n\x05\x04*\x02\x05\x03\x12\x04\xf1\
    \x0f\x20!\n\xdb\x02\n\x02\x04+\x12\x06\xff\x0f\0\xaf\x10\x01\x1a\xcc\x02\
    *\n\x20Describes\x20a\x20task.\x20Passed\x20from\x20the\x20scheduler\x20\
    all\x20the\x20way\x20to\x20an\n\x20executor\x20(see\x20SchedulerDriver::\
    launchTasks\x20and\n\x20Executor::launchTask).\x20Either\x20ExecutorInfo\
    \x20or\x20CommandInfo\x20should\x20be\x20set.\n\x20A\x20different\x20exe\
    cutor\x20can\x20be\x20used\x20to\x20launch\x20this\x20task,\x20and\x20su\
    bsequent\x20tasks\n\x20meant\x20for\x20the\x20same\x20executor\x20can\
    \x20reuse\x20the\x20same\x20ExecutorInfo\x20struct.\n\n\x0b\n\x03\x04+\
    \x01\x12\x04\xff\x0f\x08\x10\n\x0c\n\x04\x04+\x02\0\x12\x04\x80\x10\x02\
    \x1b\n\r\n\x05\x04+\x02\0\x04\x12\x04\x80\x10\x02\n\n\r\n\x05\x04+\x02\0\
    \x05\x12\x04\x80\x10\x0b\x11\n\r\n\x05\x04+\x02\0\x01\x12\x04\x80\x10\
    \x12\x16\n\r\n\x05\x04+\x02\0\x03\x12\x04\x80\x10\x19\x1a\n\x0c\n\x04\
    \x04+\x02\x01\x12\x04\x81\x10\x02\x1e\n\r\n\x05\x04+\x02\x01\x04\x12\x04\
    \x81\x10\x02\n\n\r\n\x05\x04+\x02\x01\x06\x12\x04\x81\x10\x0b\x11\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\x81\x10\x12\x19\n\r\n\x05\x04+\x02\x01\x03\
    \x12\x04\x81\x10\x1c\x1d\n\x0c\n\x04\x04+\x02\x02\x12\x04\x82\x10\x02\
    \x20\n\r\n\x05\x04+\x02\x02\x04\x12\x04\x82\x10\x02\n\n\r\n\x05\x04+\x02\
    \x02\x06\x12\x04\x82\x10\x0b\x12\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x82\
    \x10\x13\x1b\n\r\n\x05\x04+\x02\x02\x03\x12\x04\x82\x10\x1e\x1f\n\x0c\n\
    \x04\x04+\x02\x03\x12\x04\x83\x10\x02\"\n\r\n\x05\x04+\x02\x03\x04\x12\
    \x04\x83\x10\x02\n\n\r\n\x05\x04+\x02\x03\x06\x12\x04\x83\x10\x0b\x13\n\
    \r\n\x05\x04+\x02\x03\x01\x12\x04\x83\x10\x14\x1d\n\r\n\x05\x04+\x02\x03\
    \x03\x12\x04\x83\x10\x20!\n\x0c\n\x04\x04+\x02\x04\x12\x04\x84\x10\x02%\
    \n\r\n\x05\x04+\x02\x04\x04\x12\x04\x84\x10\x02\n\n\r\n\x05\x04+\x02\x04\
    \x06\x12\x04\x84\x10\x0b\x17\n\r\n\x05\x04+\x02\x04\x01\x12\x04\x84\x10\
    \x18\x20\n\r\n\x05\x04+\x02\x04\x03\x12\x04\x84\x10#$\n\x0c\n\x04\x04+\
    \x02\x05\x12\x04\x85\x10\x02#\n\r\n\x05\x04+\x02\x05\x04\x12\x04\x85\x10\
    \x02\n\n\r\n\x05\x04+\x02\x05\x06\x12\x04\x85\x10\x0b\x16\n\r\n\x05\x04+\
    \x02\x05\x01\x12\x04\x85\x10\x17\x1e\n\r\n\x05\x04+\x02\x05\x03\x12\x04\
    \x85\x10!\"\n\x82\x01\n\x04\x04+\x02\x06\x12\x04\x89\x10\x02'\x1at\x20Ta\
    sk\x20provided\x20with\x20a\x20container\x20will\x20launch\x20the\x20con\
    tainer\x20as\x20part\n\x20of\x20this\x20task\x20paired\x20with\x20the\
    \x20task's\x20CommandInfo.\n\n\r\n\x05\x04+\x02\x06\x04\x12\x04\x89\x10\
    \x02\n\n\r\n\x05\x04+\x02\x06\x06\x12\x04\x89\x10\x0b\x18\n\r\n\x05\x04+\
    \x02\x06\x01\x12\x04\x89\x10\x19\"\n\r\n\x05\x04+\x02\x06\x03\x12\x04\
    \x89\x10%&\n\xcc\x01\n\x04\x04+\x02\x07\x12\x04\x8e\x10\x02(\x1a\xbd\x01\
    \x20A\x20health\x20check\x20for\x20the\x20task.\x20Implemented\x20for\
    \x20executor-less\n\x20command-based\x20tasks.\x20For\x20tasks\x20that\
    \x20specify\x20an\x20executor,\x20it\x20is\n\x20the\x20executor's\x20res\
    ponsibility\x20to\x20implement\x20the\x20health\x20checking.\n\n\r\n\x05\
    \x04+\x02\x07\x04\x12\x04\x8e\x10\x02\n\n\r\n\x05\x04+\x02\x07\x06\x12\
    \x04\x8e\x10\x0b\x16\n\r\n\x05\x04+\x02\x07\x01\x12\x04\x8e\x10\x17#\n\r\
    \n\x05\x04+\x02\x07\x03\x12\x04\x8e\x10&'\n\x9a\x03\n\x04\x04+\x02\x08\
    \x12\x04\x98\x10\x02\x20\x1a\x8b\x03\x20A\x20general\x20check\x20for\x20\
    the\x20task.\x20Implemented\x20for\x20all\x20built-in\x20executors.\n\
    \x20For\x20tasks\x20that\x20specify\x20an\x20executor,\x20it\x20is\x20th\
    e\x20executor's\x20responsibility\n\x20to\x20implement\x20checking\x20su\
    pport.\x20Executors\x20should\x20(all\x20built-in\x20executors\n\x20will\
    )\x20neither\x20interpret\x20nor\x20act\x20on\x20the\x20check's\x20resul\
    t.\n\n\x20NOTE:\x20Check\x20support\x20in\x20built-in\x20executors\x20is\
    \x20experimental.\n\n\x20TODO(alexr):\x20Consider\x20supporting\x20multi\
    ple\x20checks\x20per\x20task.\n\n\r\n\x05\x04+\x02\x08\x04\x12\x04\x98\
    \x10\x02\n\n\r\n\x05\x04+\x02\x08\x06\x12\x04\x98\x10\x0b\x14\n\r\n\x05\
    \x04+\x02\x08\x01\x12\x04\x98\x10\x15\x1a\n\r\n\x05\x04+\x02\x08\x03\x12\
    \x04\x98\x10\x1d\x1f\n\xd3\x01\n\x04\x04+\x02\t\x12\x04\x9e\x10\x02'\x1a\
    \xc4\x01\x20A\x20kill\x20policy\x20for\x20the\x20task.\x20Implemented\
    \x20for\x20executor-less\n\x20command-based\x20and\x20docker\x20tasks.\
    \x20For\x20tasks\x20that\x20specify\x20an\n\x20executor,\x20it\x20is\x20\
    the\x20executor's\x20responsibility\x20to\x20implement\n\x20the\x20kill\
    \x20policy.\n\n\r\n\x05\x04+\x02\t\x04\x12\x04\x9e\x10\x02\n\n\r\n\x05\
    \x04+\x02\t\x06\x12\x04\x9e\x10\x0b\x15\n\r\n\x05\x04+\x02\t\x01\x12\x04\
    \x9e\x10\x16!\n\r\n\x05\x04+\x02\t\x03\x12\x04\x9e\x10$&\n\x0c\n\x04\x04\
    +\x02\n\x12\x04\xa0\x10\x02\x1a\n\r\n\x05\x04+\x02\n\x04\x12\x04\xa0\x10\
    \x02\n\n\r\n\x05\x04+\x02\n\x05\x12\x04\xa0\x10\x0b\x10\n\r\n\x05\x04+\
    \x02\n\x01\x12\x04\xa0\x10\x11\x15\n\r\n\x05\x04+\x02\n\x03\x12\x04\xa0\
    \x10\x18\x19\n\x89\x03\n\x04\x04+\x02\x0b\x12\x04\xa8\x10\x02\x1e\x1a\
    \xfa\x02\x20Labels\x20are\x20free-form\x20key\x20value\x20pairs\x20which\
    \x20are\x20exposed\x20through\n\x20master\x20and\x20agent\x20endpoints.\
    \x20Labels\x20will\x20not\x20be\x20interpreted\x20or\n\x20acted\x20upon\
    \x20by\x20Mesos\x20itself.\x20As\x20opposed\x20to\x20the\x20data\x20fiel\
    d,\x20labels\n\x20will\x20be\x20kept\x20in\x20memory\x20on\x20master\x20\
    and\x20agent\x20processes.\x20Therefore,\n\x20labels\x20should\x20be\x20\
    used\x20to\x20tag\x20tasks\x20with\x20light-weight\x20meta-data.\n\x20La\
    bels\x20should\x20not\x20contain\x20duplicate\x20key-value\x20pairs.\n\n\
    \r\n\x05\x04+\x02\x0b\x04\x12\x04\xa8\x10\x02\n\n\r\n\x05\x04+\x02\x0b\
    \x06\x12\x04\xa8\x10\x0b\x11\n\r\n\x05\x04+\x02\x0b\x01\x12\x04\xa8\x10\
    \x12\x18\n\r\n\x05\x04+\x02\x0b\x03\x12\x04\xa8\x10\x1b\x1d\n\xf1\x01\n\
    \x04\x04+\x02\x0c\x12\x04\xae\x10\x02(\x1a\xe2\x01\x20Service\x20discove\
    ry\x20information\x20for\x20the\x20task.\x20It\x20is\x20not\x20interpret\
    ed\n\x20or\x20acted\x20upon\x20by\x20Mesos.\x20It\x20is\x20up\x20to\x20a\
    \x20service\x20discovery\x20system\n\x20to\x20use\x20this\x20information\
    \x20as\x20needed\x20and\x20to\x20handle\x20tasks\x20without\n\x20service\
    \x20discovery\x20information.\n\n\r\n\x05\x04+\x02\x0c\x04\x12\x04\xae\
    \x10\x02\n\n\r\n\x05\x04+\x02\x0c\x06\x12\x04\xae\x10\x0b\x18\n\r\n\x05\
    \x04+\x02\x0c\x01\x12\x04\xae\x10\x19\"\n\r\n\x05\x04+\x02\x0c\x03\x12\
    \x04\xae\x10%'\n\xe3\x02\n\x02\x04,\x12\x06\xbc\x10\0\xbe\x10\x01\x1a\
    \xd4\x02*\n\x20Describes\x20a\x20group\x20of\x20tasks\x20that\x20belong\
    \x20to\x20an\x20executor.\x20The\n\x20executor\x20will\x20receive\x20the\
    \x20task\x20group\x20in\x20a\x20single\x20message\x20to\n\x20allow\x20th\
    e\x20group\x20to\x20be\x20launched\x20\"atomically\".\n\n\x20NOTES:\n\
    \x201)\x20`NetworkInfo`\x20must\x20not\x20be\x20set\x20inside\x20task's\
    \x20`ContainerInfo`.\n\x202)\x20`TaskInfo.executor`\x20doesn't\x20need\
    \x20to\x20set.\x20If\x20set,\x20it\x20should\x20match\n\x20\x20\x20\x20`\
    LaunchGroup.executor`.\n\n\x0b\n\x03\x04,\x01\x12\x04\xbc\x10\x08\x15\n\
    \x0c\n\x04\x04,\x02\0\x12\x04\xbd\x10\x02\x1e\n\r\n\x05\x04,\x02\0\x04\
    \x12\x04\xbd\x10\x02\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\xbd\x10\x0b\x13\
    \n\r\n\x05\x04,\x02\0\x01\x12\x04\xbd\x10\x14\x19\n\r\n\x05\x04,\x02\0\
    \x03\x12\x04\xbd\x10\x1c\x1d\n\x82\x06\n\x02\x04-\x12\x06\xd2\x10\0\xef\
    \x10\x01\x1a\xfa\x03*\n\x20Describes\x20a\x20task,\x20similar\x20to\x20`\
    TaskInfo`.\n\n\x20`Task`\x20is\x20used\x20in\x20some\x20of\x20the\x20Mes\
    os\x20messages\x20found\x20below.\n\x20`Task`\x20is\x20used\x20instead\
    \x20of\x20`TaskInfo`\x20if:\n\x20\x20\x201)\x20we\x20need\x20additional\
    \x20IDs,\x20such\x20as\x20a\x20specific\n\x20\x20\x20\x20\x20\x20framewo\
    rk,\x20executor,\x20or\x20agent;\x20or\n\x20\x20\x202)\x20we\x20do\x20no\
    t\x20need\x20the\x20additional\x20data,\x20such\x20as\x20the\x20command\
    \x20run\x20by\x20the\n\x20\x20\x20\x20\x20\x20task\x20or\x20the\x20healt\
    h\x20checks.\x20\x20These\x20additional\x20fields\x20may\x20be\x20large\
    \x20and\n\x20\x20\x20\x20\x20\x20unnecessary\x20for\x20some\x20Mesos\x20\
    messages.\n\n\x20`Task`\x20is\x20generally\x20constructed\x20from\x20a\
    \x20`TaskInfo`.\x20\x20See\x20protobuf::createTask.\n2\xf6\x01\x20TODO(b\
    mahler):\x20Add\x20executor_uuid\x20here,\x20and\x20send\x20it\x20to\x20\
    the\x20master.\x20This\x20will\n\x20allow\x20us\x20to\x20expose\x20execu\
    tor\x20work\x20directories\x20for\x20tasks\x20in\x20the\x20webui\x20when\
    \n\x20looking\x20from\x20the\x20master\x20level.\x20Currently\x20only\
    \x20the\x20agent\x20knows\x20which\x20run\x20the\n\x20task\x20belongs\
    \x20to.\n\n\x0b\n\x03\x04-\x01\x12\x04\xd2\x10\x08\x0c\n\x0c\n\x04\x04-\
    \x02\0\x12\x04\xd3\x10\x02\x1b\n\r\n\x05\x04-\x02\0\x04\x12\x04\xd3\x10\
    \x02\n\n\r\n\x05\x04-\x02\0\x05\x12\x04\xd3\x10\x0b\x11\n\r\n\x05\x04-\
    \x02\0\x01\x12\x04\xd3\x10\x12\x16\n\r\n\x05\x04-\x02\0\x03\x12\x04\xd3\
    \x10\x19\x1a\n\x0c\n\x04\x04-\x02\x01\x12\x04\xd4\x10\x02\x1e\n\r\n\x05\
    \x04-\x02\x01\x04\x12\x04\xd4\x10\x02\n\n\r\n\x05\x04-\x02\x01\x06\x12\
    \x04\xd4\x10\x0b\x11\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xd4\x10\x12\x19\
    \n\r\n\x05\x04-\x02\x01\x03\x12\x04\xd4\x10\x1c\x1d\n\x0c\n\x04\x04-\x02\
    \x02\x12\x04\xd5\x10\x02(\n\r\n\x05\x04-\x02\x02\x04\x12\x04\xd5\x10\x02\
    \n\n\r\n\x05\x04-\x02\x02\x06\x12\x04\xd5\x10\x0b\x16\n\r\n\x05\x04-\x02\
    \x02\x01\x12\x04\xd5\x10\x17#\n\r\n\x05\x04-\x02\x02\x03\x12\x04\xd5\x10\
    &'\n\x0c\n\x04\x04-\x02\x03\x12\x04\xd6\x10\x02&\n\r\n\x05\x04-\x02\x03\
    \x04\x12\x04\xd6\x10\x02\n\n\r\n\x05\x04-\x02\x03\x06\x12\x04\xd6\x10\
    \x0b\x15\n\r\n\x05\x04-\x02\x03\x01\x12\x04\xd6\x10\x16!\n\r\n\x05\x04-\
    \x02\x03\x03\x12\x04\xd6\x10$%\n\x0c\n\x04\x04-\x02\x04\x12\x04\xd7\x10\
    \x02\x20\n\r\n\x05\x04-\x02\x04\x04\x12\x04\xd7\x10\x02\n\n\r\n\x05\x04-\
    \x02\x04\x06\x12\x04\xd7\x10\x0b\x12\n\r\n\x05\x04-\x02\x04\x01\x12\x04\
    \xd7\x10\x13\x1b\n\r\n\x05\x04-\x02\x04\x03\x12\x04\xd7\x10\x1e\x1f\n)\n\
    \x04\x04-\x02\x05\x12\x04\xd8\x10\x02\x1f\"\x1b\x20Latest\x20state\x20of\
    \x20the\x20task.\n\n\r\n\x05\x04-\x02\x05\x04\x12\x04\xd8\x10\x02\n\n\r\
    \n\x05\x04-\x02\x05\x06\x12\x04\xd8\x10\x0b\x14\n\r\n\x05\x04-\x02\x05\
    \x01\x12\x04\xd8\x10\x15\x1a\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xd8\x10\
    \x1d\x1e\n\x0c\n\x04\x04-\x02\x06\x12\x04\xd9\x10\x02\"\n\r\n\x05\x04-\
    \x02\x06\x04\x12\x04\xd9\x10\x02\n\n\r\n\x05\x04-\x02\x06\x06\x12\x04\
    \xd9\x10\x0b\x13\n\r\n\x05\x04-\x02\x06\x01\x12\x04\xd9\x10\x14\x1d\n\r\
    \n\x05\x04-\x02\x06\x03\x12\x04\xd9\x10\x20!\n\x0c\n\x04\x04-\x02\x07\
    \x12\x04\xda\x10\x02#\n\r\n\x05\x04-\x02\x07\x04\x12\x04\xda\x10\x02\n\n\
    \r\n\x05\x04-\x02\x07\x06\x12\x04\xda\x10\x0b\x15\n\r\n\x05\x04-\x02\x07\
    \x01\x12\x04\xda\x10\x16\x1e\n\r\n\x05\x04-\x02\x07\x03\x12\x04\xda\x10!\
    \"\n\xb5\x01\n\x04\x04-\x02\x08\x12\x04\xdf\x10\x02-\x1a\xa6\x01\x20Thes\
    e\x20fields\x20correspond\x20to\x20the\x20state\x20and\x20uuid\x20of\x20\
    the\x20latest\n\x20status\x20update\x20forwarded\x20to\x20the\x20master.\
    \n\x20NOTE:\x20Either\x20both\x20the\x20fields\x20must\x20be\x20set\x20o\
    r\x20both\x20must\x20be\x20unset.\n\n\r\n\x05\x04-\x02\x08\x04\x12\x04\
    \xdf\x10\x02\n\n\r\n\x05\x04-\x02\x08\x06\x12\x04\xdf\x10\x0b\x14\n\r\n\
    \x05\x04-\x02\x08\x01\x12\x04\xdf\x10\x15(\n\r\n\x05\x04-\x02\x08\x03\
    \x12\x04\xdf\x10+,\n\x0c\n\x04\x04-\x02\t\x12\x04\xe0\x10\x02)\n\r\n\x05\
    \x04-\x02\t\x04\x12\x04\xe0\x10\x02\n\n\r\n\x05\x04-\x02\t\x05\x12\x04\
    \xe0\x10\x0b\x10\n\r\n\x05\x04-\x02\t\x01\x12\x04\xe0\x10\x11#\n\r\n\x05\
    \x04-\x02\t\x03\x12\x04\xe0\x10&(\n\x0c\n\x04\x04-\x02\n\x12\x04\xe2\x10\
    \x02\x1e\n\r\n\x05\x04-\x02\n\x04\x12\x04\xe2\x10\x02\n\n\r\n\x05\x04-\
    \x02\n\x06\x12\x04\xe2\x10\x0b\x11\n\r\n\x05\x04-\x02\n\x01\x12\x04\xe2\
    \x10\x12\x18\n\r\n\x05\x04-\x02\n\x03\x12\x04\xe2\x10\x1b\x1d\n\xf1\x01\
    \n\x04\x04-\x02\x0b\x12\x04\xe8\x10\x02(\x1a\xe2\x01\x20Service\x20disco\
    very\x20information\x20for\x20the\x20task.\x20It\x20is\x20not\x20interpr\
    eted\n\x20or\x20acted\x20upon\x20by\x20Mesos.\x20It\x20is\x20up\x20to\
    \x20a\x20service\x20discovery\x20system\n\x20to\x20use\x20this\x20inform\
    ation\x20as\x20needed\x20and\x20to\x20handle\x20tasks\x20without\n\x20se\
    rvice\x20discovery\x20information.\n\n\r\n\x05\x04-\x02\x0b\x04\x12\x04\
    \xe8\x10\x02\n\n\r\n\x05\x04-\x02\x0b\x06\x12\x04\xe8\x10\x0b\x18\n\r\n\
    \x05\x04-\x02\x0b\x01\x12\x04\xe8\x10\x19\"\n\r\n\x05\x04-\x02\x0b\x03\
    \x12\x04\xe8\x10%'\n3\n\x04\x04-\x02\x0c\x12\x04\xeb\x10\x02(\x1a%\x20Co\
    ntainer\x20information\x20for\x20the\x20task.\n\n\r\n\x05\x04-\x02\x0c\
    \x04\x12\x04\xeb\x10\x02\n\n\r\n\x05\x04-\x02\x0c\x06\x12\x04\xeb\x10\
    \x0b\x18\n\r\n\x05\x04-\x02\x0c\x01\x12\x04\xeb\x10\x19\"\n\r\n\x05\x04-\
    \x02\x0c\x03\x12\x04\xeb\x10%'\n:\n\x04\x04-\x02\r\x12\x04\xee\x10\x02\
    \x1c\x1a,\x20Specific\x20user\x20under\x20which\x20task\x20is\x20running\
    .\n\n\r\n\x05\x04-\x02\r\x04\x12\x04\xee\x10\x02\n\n\r\n\x05\x04-\x02\r\
    \x05\x12\x04\xee\x10\x0b\x11\n\r\n\x05\x04-\x02\r\x01\x12\x04\xee\x10\
    \x12\x16\n\r\n\x05\x04-\x02\r\x03\x12\x04\xee\x10\x19\x1b\n\xa6\x02\n\
    \x02\x05\x01\x12\x06\xf9\x10\0\xb5\x11\x01\x1a\x97\x02*\n\x20Describes\
    \x20possible\x20task\x20states.\x20IMPORTANT:\x20Mesos\x20assumes\x20tas\
    ks\x20that\n\x20enter\x20terminal\x20states\x20(see\x20below)\x20imply\
    \x20the\x20task\x20is\x20no\x20longer\n\x20running\x20and\x20thus\x20cle\
    an\x20up\x20any\x20thing\x20associated\x20with\x20the\x20task\n\x20(ulti\
    mately\x20offering\x20any\x20resources\x20being\x20consumed\x20by\x20tha\
    t\x20task\x20to\n\x20another\x20task).\n\n\x0b\n\x03\x05\x01\x01\x12\x04\
    \xf9\x10\x05\x0e\nG\n\x04\x05\x01\x02\0\x12\x04\xfa\x10\x02\x13\"9\x20In\
    itial\x20state.\x20Framework\x20status\x20updates\x20should\x20not\x20us\
    e.\n\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xfa\x10\x02\x0e\n\r\n\x05\x05\
    \x01\x02\0\x02\x12\x04\xfa\x10\x11\x12\n;\n\x04\x05\x01\x02\x01\x12\x04\
    \xfb\x10\x02\x14\"-\x20The\x20task\x20is\x20being\x20launched\x20by\x20t\
    he\x20executor.\n\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xfb\x10\x02\x0f\
    \n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xfb\x10\x12\x13\n\x0c\n\x04\x05\
    \x01\x02\x02\x12\x04\xfc\x10\x02\x13\n\r\n\x05\x05\x01\x02\x02\x01\x12\
    \x04\xfc\x10\x02\x0e\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xfc\x10\x11\
    \x12\n\x96\x01\n\x04\x05\x01\x02\x03\x12\x04\x80\x11\x02\x13\x1a[\x20NOT\
    E:\x20This\x20should\x20only\x20be\x20sent\x20when\x20the\x20framework\
    \x20has\n\x20the\x20TASK_KILLING_STATE\x20capability.\n\"+\x20The\x20tas\
    k\x20is\x20being\x20killed\x20by\x20the\x20executor.\n\n\r\n\x05\x05\x01\
    \x02\x03\x01\x12\x04\x80\x11\x02\x0e\n\r\n\x05\x05\x01\x02\x03\x02\x12\
    \x04\x80\x11\x11\x12\ne\n\x04\x05\x01\x02\x04\x12\x04\x83\x11\x02\x14\
    \x1aJ\x20The\x20task\x20finished\x20successfully\x20on\x20its\x20own\x20\
    without\x20external\x20interference.\n\"\x0b\x20TERMINAL.\n\n\r\n\x05\
    \x05\x01\x02\x04\x01\x12\x04\x83\x11\x02\x0f\n\r\n\x05\x05\x01\x02\x04\
    \x02\x12\x04\x83\x11\x12\x13\nA\n\x04\x05\x01\x02\x05\x12\x04\x85\x11\
    \x02\x12\"3\x20TERMINAL:\x20The\x20task\x20failed\x20to\x20finish\x20suc\
    cessfully.\n\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\x85\x11\x02\r\n\r\n\
    \x05\x05\x01\x02\x05\x02\x12\x04\x85\x11\x10\x11\n>\n\x04\x05\x01\x02\
    \x06\x12\x04\x86\x11\x02\x12\"0\x20TERMINAL:\x20The\x20task\x20was\x20ki\
    lled\x20by\x20the\x20executor.\n\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\
    \x86\x11\x02\r\n\r\n\x05\x05\x01\x02\x06\x02\x12\x04\x86\x11\x10\x11\nA\
    \n\x04\x05\x01\x02\x07\x12\x04\x87\x11\x02\x11\"3\x20TERMINAL:\x20The\
    \x20task\x20description\x20contains\x20an\x20error.\n\n\r\n\x05\x05\x01\
    \x02\x07\x01\x12\x04\x87\x11\x02\x0c\n\r\n\x05\x05\x01\x02\x07\x02\x12\
    \x04\x87\x11\x0f\x10\n\xce\x02\n\x04\x05\x01\x02\x08\x12\x04\x8f\x11\x02\
    \x10\x1a\x94\x02\x20In\x20Mesos\x201.3,\x20this\x20will\x20only\x20be\
    \x20sent\x20when\x20the\x20framework\x20does\x20NOT\n\x20opt-in\x20to\
    \x20the\x20PARTITION_AWARE\x20capability.\n\n\x20NOTE:\x20This\x20state\
    \x20is\x20not\x20always\x20terminal.\x20For\x20example,\x20tasks\x20migh\
    t\n\x20transition\x20from\x20TASK_LOST\x20to\x20TASK_RUNNING\x20or\x20ot\
    her\x20states\x20when\x20a\n\x20partitioned\x20agent\x20re-registers.\n\
    \")\x20The\x20task\x20failed\x20but\x20can\x20be\x20rescheduled.\n\n\r\n\
    \x05\x05\x01\x02\x08\x01\x12\x04\x8f\x11\x02\x0b\n\r\n\x05\x05\x01\x02\
    \x08\x02\x12\x04\x8f\x11\x0e\x0f\n\xd8\x02\n\x04\x05\x01\x02\t\x12\x04\
    \x98\x11\x02\x13\x1a\xd2\x01\x20The\x20task\x20failed\x20to\x20launch\
    \x20because\x20of\x20a\x20transient\x20error.\x20The\n\x20task's\x20exec\
    utor\x20never\x20started\x20running.\x20Unlike\x20TASK_ERROR,\x20the\n\
    \x20task\x20description\x20is\x20valid\x20--\x20attempting\x20to\x20laun\
    ch\x20the\x20task\x20again\n\x20may\x20be\x20successful.\n\"\x0b\x20TERM\
    INAL.\n2h\x20The\x20following\x20task\x20states\x20are\x20only\x20sent\
    \x20when\x20the\x20framework\n\x20opts-in\x20to\x20the\x20PARTITION_AWAR\
    E\x20capability.\n\n\r\n\x05\x05\x01\x02\t\x01\x12\x04\x98\x11\x02\x0e\n\
    \r\n\x05\x05\x01\x02\t\x02\x12\x04\x98\x11\x11\x12\n\xb5\x01\n\x04\x05\
    \x01\x02\n\x12\x04\x9d\x11\x02\x18\x1a\xa6\x01\x20The\x20task\x20was\x20\
    running\x20on\x20an\x20agent\x20that\x20has\x20lost\x20contact\x20with\
    \x20the\n\x20master,\x20typically\x20due\x20to\x20a\x20network\x20failur\
    e\x20or\x20partition.\x20The\x20task\n\x20may\x20or\x20may\x20not\x20sti\
    ll\x20be\x20running.\n\n\r\n\x05\x05\x01\x02\n\x01\x12\x04\x9d\x11\x02\
    \x12\n\r\n\x05\x05\x01\x02\n\x02\x12\x04\x9d\x11\x15\x17\n\xf2\x02\n\x04\
    \x05\x01\x02\x0b\x12\x04\xa5\x11\x02\x11\x1a\xd6\x02\x20The\x20task\x20i\
    s\x20no\x20longer\x20running.\x20This\x20can\x20occur\x20if\x20the\x20ag\
    ent\x20has\n\x20been\x20terminated\x20along\x20with\x20all\x20of\x20its\
    \x20tasks\x20(e.g.,\x20the\x20host\x20that\n\x20was\x20running\x20the\
    \x20agent\x20was\x20rebooted).\x20It\x20might\x20also\x20occur\x20if\x20\
    the\n\x20task\x20was\x20terminated\x20due\x20to\x20an\x20agent\x20or\x20\
    containerizer\x20error,\x20or\x20if\n\x20the\x20task\x20was\x20preempted\
    \x20by\x20the\x20QoS\x20controller\x20in\x20an\n\x20oversubscription\x20\
    scenario.\n\"\x0b\x20TERMINAL.\n\n\r\n\x05\x05\x01\x02\x0b\x01\x12\x04\
    \xa5\x11\x02\x0b\n\r\n\x05\x05\x01\x02\x0b\x02\x12\x04\xa5\x11\x0e\x10\n\
    \x82\x03\n\x04\x05\x01\x02\x0c\x12\x04\xad\x11\x02\x1d\x1a\xf3\x02\x20Th\
    e\x20task\x20was\x20running\x20on\x20an\x20agent\x20that\x20the\x20maste\
    r\x20cannot\x20contact;\n\x20the\x20operator\x20has\x20asserted\x20that\
    \x20the\x20agent\x20has\x20been\x20shutdown,\x20but\n\x20this\x20has\x20\
    not\x20been\x20directly\x20confirmed\x20by\x20the\x20master.\x20If\x20th\
    e\n\x20operator\x20is\x20correct,\x20the\x20task\x20is\x20not\x20running\
    \x20and\x20this\x20is\x20a\n\x20terminal\x20state;\x20if\x20the\x20opera\
    tor\x20is\x20mistaken,\x20the\x20task\x20may\x20still\n\x20be\x20running\
    \x20and\x20might\x20return\x20to\x20RUNNING\x20in\x20the\x20future.\n\n\
    \r\n\x05\x05\x01\x02\x0c\x01\x12\x04\xad\x11\x02\x17\n\r\n\x05\x05\x01\
    \x02\x0c\x02\x12\x04\xad\x11\x1a\x1c\n\x9a\x02\n\x04\x05\x01\x02\r\x12\
    \x04\xb4\x11\x02\x14\x1a\x8b\x02\x20The\x20master\x20has\x20no\x20knowle\
    dge\x20of\x20the\x20task.\x20This\x20is\x20typically\n\x20because\x20eit\
    her\x20(a)\x20the\x20master\x20never\x20had\x20knowledge\x20of\x20the\
    \x20task,\x20or\n\x20(b)\x20the\x20master\x20forgot\x20about\x20the\x20t\
    ask\x20because\x20it\x20garbage\x20collected\n\x20its\x20metadata\x20abo\
    ut\x20the\x20task.\x20The\x20task\x20may\x20or\x20may\x20not\x20still\
    \x20be\n\x20running.\n\n\r\n\x05\x05\x01\x02\r\x01\x12\x04\xb4\x11\x02\
    \x0e\n\r\n\x05\x05\x01\x02\r\x02\x12\x04\xb4\x11\x11\x13\nM\n\x02\x04.\
    \x12\x06\xbb\x11\0\xc1\x11\x01\x1a?*\n\x20Describes\x20a\x20resource\x20\
    limitation\x20that\x20caused\x20a\x20task\x20failure.\n\n\x0b\n\x03\x04.\
    \x01\x12\x04\xbb\x11\x08\x1e\n\xbd\x01\n\x04\x04.\x02\0\x12\x04\xc0\x11\
    \x02\"\x1a\xae\x01\x20This\x20field\x20contains\x20the\x20resource\x20wh\
    ose\x20limits\x20were\x20violated.\n\n\x20NOTE:\x20'Resources'\x20is\x20\
    used\x20here\x20because\x20the\x20resource\x20may\x20span\n\x20multiple\
    \x20roles\x20(e.g.\x20`\"mem(*):1;mem(role):2\"`).\n\n\r\n\x05\x04.\x02\
    \0\x04\x12\x04\xc0\x11\x02\n\n\r\n\x05\x04.\x02\0\x06\x12\x04\xc0\x11\
    \x0b\x13\n\r\n\x05\x04.\x02\0\x01\x12\x04\xc0\x11\x14\x1d\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\xc0\x11\x20!\n#\n\x02\x04/\x12\x06\xc7\x11\0\xc9\x11\
    \x01\x1a\x15*\n\x20Describes\x20a\x20UUID.\n\n\x0b\n\x03\x04/\x01\x12\
    \x04\xc7\x11\x08\x0c\n\x0c\n\x04\x04/\x02\0\x12\x04\xc8\x11\x02\x1b\n\r\
    \n\x05\x04/\x02\0\x04\x12\x04\xc8\x11\x02\n\n\r\n\x05\x04/\x02\0\x05\x12\
    \x04\xc8\x11\x0b\x10\n\r\n\x05\x04/\x02\0\x01\x12\x04\xc8\x11\x11\x16\n\
    \r\n\x05\x04/\x02\0\x03\x12\x04\xc8\x11\x19\x1a\nj\n\x02\x040\x12\x06\
    \xd0\x11\0\xdd\x11\x01\x1a\\*\n\x20Describes\x20an\x20operation,\x20simi\
    lar\x20to\x20`Offer.Operation`,\x20with\n\x20some\x20additional\x20infor\
    mation.\n\n\x0b\n\x03\x040\x01\x12\x04\xd0\x11\x08\x11\n\x0c\n\x04\x040\
    \x02\0\x12\x04\xd1\x11\x02(\n\r\n\x05\x040\x02\0\x04\x12\x04\xd1\x11\x02\
    \n\n\r\n\x05\x040\x02\0\x06\x12\x04\xd1\x11\x0b\x16\n\r\n\x05\x040\x02\0\
    \x01\x12\x04\xd1\x11\x17#\n\r\n\x05\x040\x02\0\x03\x12\x04\xd1\x11&'\n\
    \x0c\n\x04\x040\x02\x01\x12\x04\xd2\x11\x02\x20\n\r\n\x05\x040\x02\x01\
    \x04\x12\x04\xd2\x11\x02\n\n\r\n\x05\x040\x02\x01\x06\x12\x04\xd2\x11\
    \x0b\x12\n\r\n\x05\x040\x02\x01\x01\x12\x04\xd2\x11\x13\x1b\n\r\n\x05\
    \x040\x02\x01\x03\x12\x04\xd2\x11\x1e\x1f\n\x0c\n\x04\x040\x02\x02\x12\
    \x04\xd3\x11\x02$\n\r\n\x05\x040\x02\x02\x04\x12\x04\xd3\x11\x02\n\n\r\n\
    \x05\x040\x02\x02\x06\x12\x04\xd3\x11\x0b\x1a\n\r\n\x05\x040\x02\x02\x01\
    \x12\x04\xd3\x11\x1b\x1f\n\r\n\x05\x040\x02\x02\x03\x12\x04\xd3\x11\"#\n\
    \x0c\n\x04\x040\x02\x03\x12\x04\xd4\x11\x02-\n\r\n\x05\x040\x02\x03\x04\
    \x12\x04\xd4\x11\x02\n\n\r\n\x05\x040\x02\x03\x06\x12\x04\xd4\x11\x0b\
    \x1a\n\r\n\x05\x040\x02\x03\x01\x12\x04\xd4\x11\x1b(\n\r\n\x05\x040\x02\
    \x03\x03\x12\x04\xd4\x11+,\n\x9d\x01\n\x04\x040\x02\x04\x12\x04\xd8\x11\
    \x02(\x1a\x8e\x01\x20All\x20the\x20statuses\x20known\x20to\x20this\x20op\
    eration.\x20Some\x20of\x20the\x20statuses\x20in\x20this\n\x20list\x20mig\
    ht\x20not\x20have\x20been\x20acknowledged\x20yet.\x20The\x20statuses\x20\
    are\x20ordered.\n\n\r\n\x05\x040\x02\x04\x04\x12\x04\xd8\x11\x02\n\n\r\n\
    \x05\x040\x02\x04\x06\x12\x04\xd8\x11\x0b\x1a\n\r\n\x05\x040\x02\x04\x01\
    \x12\x04\xd8\x11\x1b#\n\r\n\x05\x040\x02\x04\x03\x12\x04\xd8\x11&'\n\x98\
    \x01\n\x04\x040\x02\x05\x12\x04\xdc\x11\x02\x19\x1a\x89\x01\x20This\x20i\
    s\x20the\x20internal\x20UUID\x20for\x20the\x20operation,\x20which\x20is\
    \x20kept\x20independently\n\x20from\x20the\x20framework-specified\x20ope\
    ration\x20ID,\x20which\x20is\x20optional.\n\n\r\n\x05\x040\x02\x05\x04\
    \x12\x04\xdc\x11\x02\n\n\r\n\x05\x040\x02\x05\x06\x12\x04\xdc\x11\x0b\
    \x0f\n\r\n\x05\x040\x02\x05\x01\x12\x04\xdc\x11\x10\x14\n\r\n\x05\x040\
    \x02\x05\x03\x12\x04\xdc\x11\x17\x18\n6\n\x02\x05\x02\x12\x06\xe3\x11\0\
    \xf5\x11\x01\x1a(*\n\x20Describes\x20possible\x20operation\x20states.\n\
    \n\x0b\n\x03\x05\x02\x01\x12\x04\xe3\x11\x05\x13\nE\n\x04\x05\x02\x02\0\
    \x12\x04\xe5\x11\x02\x1c\x1a7\x20Default\x20value\x20if\x20the\x20enum\
    \x20is\x20not\x20set.\x20See\x20MESOS-4997.\n\n\r\n\x05\x05\x02\x02\0\
    \x01\x12\x04\xe5\x11\x02\x17\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\xe5\x11\
    \x1a\x1b\n\x1e\n\x04\x05\x02\x02\x01\x12\x04\xe8\x11\x02\x18\x1a\x10\x20\
    Initial\x20state.\n\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xe8\x11\x02\
    \x13\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\xe8\x11\x16\x17\nA\n\x04\x05\
    \x02\x02\x02\x12\x04\xeb\x11\x02\x19\x1a3\x20TERMINAL:\x20The\x20operati\
    on\x20was\x20successfully\x20applied.\n\n\r\n\x05\x05\x02\x02\x02\x01\
    \x12\x04\xeb\x11\x02\x14\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xeb\x11\
    \x17\x18\n8\n\x04\x05\x02\x02\x03\x12\x04\xee\x11\x02\x17\x1a*\x20TERMIN\
    AL:\x20The\x20operation\x20failed\x20to\x20apply.\n\n\r\n\x05\x05\x02\
    \x02\x03\x01\x12\x04\xee\x11\x02\x12\n\r\n\x05\x05\x02\x02\x03\x02\x12\
    \x04\xee\x11\x15\x16\nF\n\x04\x05\x02\x02\x04\x12\x04\xf1\x11\x02\x16\
    \x1a8\x20TERMINAL:\x20The\x20operation\x20description\x20contains\x20an\
    \x20error.\n\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\xf1\x11\x02\x11\n\r\n\
    \x05\x05\x02\x02\x04\x02\x12\x04\xf1\x11\x14\x15\nM\n\x04\x05\x02\x02\
    \x05\x12\x04\xf4\x11\x02\x18\x1a?\x20TERMINAL:\x20The\x20operation\x20wa\
    s\x20dropped\x20due\x20to\x20a\x20transient\x20error.\n\n\r\n\x05\x05\
    \x02\x02\x05\x01\x12\x04\xf4\x11\x02\x13\n\r\n\x05\x05\x02\x02\x05\x02\
    \x12\x04\xf4\x11\x16\x17\n?\n\x02\x041\x12\x06\xfb\x11\0\x8d\x12\x01\x1a\
    1*\n\x20Describes\x20the\x20current\x20status\x20of\x20an\x20operation.\
    \n\n\x0b\n\x03\x041\x01\x12\x04\xfb\x11\x08\x17\n\xf4\x01\n\x04\x041\x02\
    \0\x12\x04\x80\x12\x02(\x1a\xe5\x01\x20While\x20frameworks\x20will\x20on\
    ly\x20receive\x20status\x20updates\x20for\x20operations\x20on\x20which\n\
    \x20they\x20have\x20set\x20an\x20ID,\x20this\x20field\x20is\x20optional\
    \x20because\x20this\x20message\x20is\x20also\n\x20used\x20internally\x20\
    by\x20Mesos\x20components\x20when\x20the\x20operation's\x20ID\x20has\x20\
    not\x20been\n\x20set.\n\n\r\n\x05\x041\x02\0\x04\x12\x04\x80\x12\x02\n\n\
    \r\n\x05\x041\x02\0\x06\x12\x04\x80\x12\x0b\x16\n\r\n\x05\x041\x02\0\x01\
    \x12\x04\x80\x12\x17#\n\r\n\x05\x041\x02\0\x03\x12\x04\x80\x12&'\n\x0c\n\
    \x04\x041\x02\x01\x12\x04\x82\x12\x02$\n\r\n\x05\x041\x02\x01\x04\x12\
    \x04\x82\x12\x02\n\n\r\n\x05\x041\x02\x01\x06\x12\x04\x82\x12\x0b\x19\n\
    \r\n\x05\x041\x02\x01\x01\x12\x04\x82\x12\x1a\x1f\n\r\n\x05\x041\x02\x01\
    \x03\x12\x04\x82\x12\"#\n\x0c\n\x04\x041\x02\x02\x12\x04\x83\x12\x02\x1e\
    \n\r\n\x05\x041\x02\x02\x04\x12\x04\x83\x12\x02\n\n\r\n\x05\x041\x02\x02\
    \x05\x12\x04\x83\x12\x0b\x11\n\r\n\x05\x041\x02\x02\x01\x12\x04\x83\x12\
    \x12\x19\n\r\n\x05\x041\x02\x02\x03\x12\x04\x83\x12\x1c\x1d\n|\n\x04\x04\
    1\x02\x03\x12\x04\x87\x12\x02,\x1an\x20Converted\x20resources\x20after\
    \x20applying\x20the\x20operation.\x20This\x20only\n\x20applies\x20if\x20\
    the\x20`state`\x20is\x20`OPERATION_FINISHED`.\n\n\r\n\x05\x041\x02\x03\
    \x04\x12\x04\x87\x12\x02\n\n\r\n\x05\x041\x02\x03\x06\x12\x04\x87\x12\
    \x0b\x13\n\r\n\x05\x041\x02\x03\x01\x12\x04\x87\x12\x14'\n\r\n\x05\x041\
    \x02\x03\x03\x12\x04\x87\x12*+\n\xac\x01\n\x04\x041\x02\x04\x12\x04\x8c\
    \x12\x02\x19\x1a\x9d\x01\x20Statuses\x20that\x20are\x20delivered\x20reli\
    ably\x20to\x20the\x20scheduler\x20will\n\x20include\x20a\x20`uuid`.\x20T\
    he\x20status\x20is\x20considered\x20delivered\x20once\n\x20it\x20is\x20a\
    cknowledged\x20by\x20the\x20scheduler.\n\n\r\n\x05\x041\x02\x04\x04\x12\
    \x04\x8c\x12\x02\n\n\r\n\x05\x041\x02\x04\x06\x12\x04\x8c\x12\x0b\x0f\n\
    \r\n\x05\x041\x02\x04\x01\x12\x04\x8c\x12\x10\x14\n\r\n\x05\x041\x02\x04\
    \x03\x12\x04\x8c\x12\x17\x18\n\xea\x02\n\x02\x042\x12\x06\x98\x12\0\xc2\
    \x12\x01\x1a\xdb\x02*\n\x20Describes\x20the\x20status\x20of\x20a\x20chec\
    k.\x20Type\x20and\x20the\x20corresponding\x20field,\x20i.e.,\n\x20`comma\
    nd`\x20or\x20`http`\x20must\x20be\x20set.\x20If\x20the\x20result\x20of\
    \x20the\x20check\x20is\x20not\x20available\n\x20(e.g.,\x20the\x20check\
    \x20timed\x20out),\x20these\x20fields\x20must\x20contain\x20empty\x20mes\
    sages,\x20i.e.,\n\x20`exit_code`\x20or\x20`status_code`\x20will\x20be\
    \x20unset.\n\n\x20NOTE:\x20This\x20API\x20is\x20unstable\x20and\x20the\
    \x20related\x20feature\x20is\x20experimental.\n\n\x0b\n\x03\x042\x01\x12\
    \x04\x98\x12\x08\x17\n\x0e\n\x04\x042\x03\0\x12\x06\x99\x12\x02\x9e\x12\
    \x03\n\r\n\x05\x042\x03\0\x01\x12\x04\x99\x12\n\x11\n\xbd\x01\n\x06\x042\
    \x03\0\x02\0\x12\x04\x9d\x12\x04!\x1a\xac\x01\x20Exit\x20code\x20of\x20a\
    \x20command\x20check.\x20It\x20is\x20the\x20result\x20of\x20calling\n\
    \x20`WEXITSTATUS()`\x20on\x20`waitpid()`\x20termination\x20information\
    \x20on\n\x20Posix\x20and\x20calling\x20`GetExitCodeProcess()`\x20on\x20W\
    indows.\n\n\x0f\n\x07\x042\x03\0\x02\0\x04\x12\x04\x9d\x12\x04\x0c\n\x0f\
    \n\x07\x042\x03\0\x02\0\x05\x12\x04\x9d\x12\r\x12\n\x0f\n\x07\x042\x03\0\
    \x02\0\x01\x12\x04\x9d\x12\x13\x1c\n\x0f\n\x07\x042\x03\0\x02\0\x03\x12\
    \x04\x9d\x12\x1f\x20\n\x0e\n\x04\x042\x03\x01\x12\x06\xa0\x12\x02\xa3\
    \x12\x03\n\r\n\x05\x042\x03\x01\x01\x12\x04\xa0\x12\n\x0e\n4\n\x06\x042\
    \x03\x01\x02\0\x12\x04\xa2\x12\x04$\x1a$\x20HTTP\x20status\x20code\x20of\
    \x20an\x20HTTP\x20check.\n\n\x0f\n\x07\x042\x03\x01\x02\0\x04\x12\x04\
    \xa2\x12\x04\x0c\n\x0f\n\x07\x042\x03\x01\x02\0\x05\x12\x04\xa2\x12\r\
    \x13\n\x0f\n\x07\x042\x03\x01\x02\0\x01\x12\x04\xa2\x12\x14\x1f\n\x0f\n\
    \x07\x042\x03\x01\x02\0\x03\x12\x04\xa2\x12\"#\n\x0e\n\x04\x042\x03\x02\
    \x12\x06\xa5\x12\x02\xa8\x12\x03\n\r\n\x05\x042\x03\x02\x01\x12\x04\xa5\
    \x12\n\r\n5\n\x06\x042\x03\x02\x02\0\x12\x04\xa7\x12\x04\x20\x1a%\x20Whe\
    ther\x20a\x20TCP\x20connection\x20succeeded.\n\n\x0f\n\x07\x042\x03\x02\
    \x02\0\x04\x12\x04\xa7\x12\x04\x0c\n\x0f\n\x07\x042\x03\x02\x02\0\x05\
    \x12\x04\xa7\x12\r\x11\n\x0f\n\x07\x042\x03\x02\x02\0\x01\x12\x04\xa7\
    \x12\x12\x1b\n\x0f\n\x07\x042\x03\x02\x02\0\x03\x12\x04\xa7\x12\x1e\x1f\
    \n\xfe\x02\n\x04\x042\x02\0\x12\x04\xb1\x12\x02#\x1a3\x20The\x20type\x20\
    of\x20the\x20check\x20this\x20status\x20corresponds\x20to.\n2\xba\x02\
    \x20TODO(alexr):\x20Consider\x20adding\x20a\x20`data`\x20field,\x20which\
    \x20can\x20contain,\x20e.g.,\n\x20truncated\x20stdout/stderr\x20output\
    \x20for\x20command\x20checks\x20or\x20HTTP\x20response\x20body\n\x20for\
    \x20HTTP\x20checks.\x20Alternatively,\x20it\x20can\x20be\x20an\x20even\
    \x20shorter\x20`message`\x20field\n\x20containing\x20the\x20last\x20line\
    \x20of\x20stdout\x20or\x20Reason-Phrase\x20of\x20the\x20status\x20line\
    \x20of\n\x20the\x20HTTP\x20response.\n\n\r\n\x05\x042\x02\0\x04\x12\x04\
    \xb1\x12\x02\n\n\r\n\x05\x042\x02\0\x06\x12\x04\xb1\x12\x0b\x19\n\r\n\
    \x05\x042\x02\0\x01\x12\x04\xb1\x12\x1a\x1e\n\r\n\x05\x042\x02\0\x03\x12\
    \x04\xb1\x12!\"\n*\n\x04\x042\x02\x01\x12\x04\xb4\x12\x02\x1f\x1a\x1c\
    \x20Status\x20of\x20a\x20command\x20check.\n\n\r\n\x05\x042\x02\x01\x04\
    \x12\x04\xb4\x12\x02\n\n\r\n\x05\x042\x02\x01\x06\x12\x04\xb4\x12\x0b\
    \x12\n\r\n\x05\x042\x02\x01\x01\x12\x04\xb4\x12\x13\x1a\n\r\n\x05\x042\
    \x02\x01\x03\x12\x04\xb4\x12\x1d\x1e\n(\n\x04\x042\x02\x02\x12\x04\xb7\
    \x12\x02\x19\x1a\x1a\x20Status\x20of\x20an\x20HTTP\x20check.\n\n\r\n\x05\
    \x042\x02\x02\x04\x12\x04\xb7\x12\x02\n\n\r\n\x05\x042\x02\x02\x06\x12\
    \x04\xb7\x12\x0b\x0f\n\r\n\x05\x042\x02\x02\x01\x12\x04\xb7\x12\x10\x14\
    \n\r\n\x05\x042\x02\x02\x03\x12\x04\xb7\x12\x17\x18\n&\n\x04\x042\x02\
    \x03\x12\x04\xba\x12\x02\x17\x1a\x18\x20Status\x20of\x20a\x20TCP\x20chec\
    k.\n\n\r\n\x05\x042\x02\x03\x04\x12\x04\xba\x12\x02\n\n\r\n\x05\x042\x02\
    \x03\x06\x12\x04\xba\x12\x0b\x0e\n\r\n\x05\x042\x02\x03\x01\x12\x04\xba\
    \x12\x0f\x12\n\r\n\x05\x042\x02\x03\x03\x12\x04\xba\x12\x15\x16\n9\n\x02\
    \x043\x12\x06\xc8\x12\0\xb5\x13\x01\x1a+*\n\x20Describes\x20the\x20curre\
    nt\x20status\x20of\x20a\x20task.\n\n\x0b\n\x03\x043\x01\x12\x04\xc8\x12\
    \x08\x12\nA\n\x04\x043\x04\0\x12\x06\xca\x12\x02\xce\x12\x03\x1a1\x20Des\
    cribes\x20the\x20source\x20of\x20the\x20task\x20status\x20update.\n\n\r\
    \n\x05\x043\x04\0\x01\x12\x04\xca\x12\x07\r\n\x0e\n\x06\x043\x04\0\x02\0\
    \x12\x04\xcb\x12\x04\x16\n\x0f\n\x07\x043\x04\0\x02\0\x01\x12\x04\xcb\
    \x12\x04\x11\n\x0f\n\x07\x043\x04\0\x02\0\x02\x12\x04\xcb\x12\x14\x15\n\
    \x0e\n\x06\x043\x04\0\x02\x01\x12\x04\xcc\x12\x04\x15\n\x0f\n\x07\x043\
    \x04\0\x02\x01\x01\x12\x04\xcc\x12\x04\x10\n\x0f\n\x07\x043\x04\0\x02\
    \x01\x02\x12\x04\xcc\x12\x13\x14\n\x0e\n\x06\x043\x04\0\x02\x02\x12\x04\
    \xcd\x12\x04\x18\n\x0f\n\x07\x043\x04\0\x02\x02\x01\x12\x04\xcd\x12\x04\
    \x13\n\x0f\n\x07\x043\x04\0\x02\x02\x02\x12\x04\xcd\x12\x16\x17\n~\n\x04\
    \x043\x04\x01\x12\x06\xd2\x12\x02\xf8\x12\x03\x1an\x20Detailed\x20reason\
    \x20for\x20the\x20task\x20status\x20update.\n\x20Refer\x20to\x20docs/tas\
    k-state-reasons.md\x20for\x20additional\x20explanation.\n\n\r\n\x05\x043\
    \x04\x01\x01\x12\x04\xd2\x12\x07\r\n\xd1\x01\n\x06\x043\x04\x01\x02\0\
    \x12\x04\xd6\x12\x04'\x1a\xc0\x01\x20TODO(jieyu):\x20The\x20default\x20v\
    alue\x20when\x20a\x20caller\x20doesn't\x20check\x20for\n\x20presence\x20\
    is\x200\x20and\x20so\x20ideally\x20the\x200\x20reason\x20is\x20not\x20a\
    \x20valid\x20one.\n\x20Since\x20this\x20is\x20not\x20used\x20anywhere,\
    \x20consider\x20removing\x20this\x20reason.\n\n\x0f\n\x07\x043\x04\x01\
    \x02\0\x01\x12\x04\xd6\x12\x04\"\n\x0f\n\x07\x043\x04\x01\x02\0\x02\x12\
    \x04\xd6\x12%&\n\x0e\n\x06\x043\x04\x01\x02\x01\x12\x04\xd8\x12\x04(\n\
    \x0f\n\x07\x043\x04\x01\x02\x01\x01\x12\x04\xd8\x12\x04\"\n\x0f\n\x07\
    \x043\x04\x01\x02\x01\x02\x12\x04\xd8\x12%'\n\x0e\n\x06\x043\x04\x01\x02\
    \x02\x12\x04\xd9\x12\x04%\n\x0f\n\x07\x043\x04\x01\x02\x02\x01\x12\x04\
    \xd9\x12\x04\x1f\n\x0f\n\x07\x043\x04\x01\x02\x02\x02\x12\x04\xd9\x12\"$\
    \n\x0e\n\x06\x043\x04\x01\x02\x03\x12\x04\xda\x12\x04*\n\x0f\n\x07\x043\
    \x04\x01\x02\x03\x01\x12\x04\xda\x12\x04$\n\x0f\n\x07\x043\x04\x01\x02\
    \x03\x02\x12\x04\xda\x12')\n\x0e\n\x06\x043\x04\x01\x02\x04\x12\x04\xdb\
    \x12\x04+\n\x0f\n\x07\x043\x04\x01\x02\x04\x01\x12\x04\xdb\x12\x04&\n\
    \x0f\n\x07\x043\x04\x01\x02\x04\x02\x12\x04\xdb\x12)*\n\x0e\n\x06\x043\
    \x04\x01\x02\x05\x12\x04\xdc\x12\x04$\n\x0f\n\x07\x043\x04\x01\x02\x05\
    \x01\x12\x04\xdc\x12\x04\x1e\n\x0f\n\x07\x043\x04\x01\x02\x05\x02\x12\
    \x04\xdc\x12!#\n\x0e\n\x06\x043\x04\x01\x02\x06\x12\x04\xdd\x12\x04(\n\
    \x0f\n\x07\x043\x04\x01\x02\x06\x01\x12\x04\xdd\x12\x04\"\n\x0f\n\x07\
    \x043\x04\x01\x02\x06\x02\x12\x04\xdd\x12%'\n\x0e\n\x06\x043\x04\x01\x02\
    \x07\x12\x04\xde\x12\x04.\n\x0f\n\x07\x043\x04\x01\x02\x07\x01\x12\x04\
    \xde\x12\x04(\n\x0f\n\x07\x043\x04\x01\x02\x07\x02\x12\x04\xde\x12+-\n\
    \x0e\n\x06\x043\x04\x01\x02\x08\x12\x04\xdf\x12\x040\n\x0f\n\x07\x043\
    \x04\x01\x02\x08\x01\x12\x04\xdf\x12\x04*\n\x0f\n\x07\x043\x04\x01\x02\
    \x08\x02\x12\x04\xdf\x12-/\n\x0e\n\x06\x043\x04\x01\x02\t\x12\x04\xe0\
    \x12\x04#\n\x0f\n\x07\x043\x04\x01\x02\t\x01\x12\x04\xe0\x12\x04\x1e\n\
    \x0f\n\x07\x043\x04\x01\x02\t\x02\x12\x04\xe0\x12!\"\n!\n\x06\x043\x04\
    \x01\x02\n\x12\x04\xe1\x12\x04%\"\x11\x20No\x20longer\x20used.\n\n\x0f\n\
    \x07\x043\x04\x01\x02\n\x01\x12\x04\xe1\x12\x04\x20\n\x0f\n\x07\x043\x04\
    \x01\x02\n\x02\x12\x04\xe1\x12#$\n\x0e\n\x06\x043\x04\x01\x02\x0b\x12\
    \x04\xe2\x12\x04!\n\x0f\n\x07\x043\x04\x01\x02\x0b\x01\x12\x04\xe2\x12\
    \x04\x1c\n\x0f\n\x07\x043\x04\x01\x02\x0b\x02\x12\x04\xe2\x12\x1f\x20\n\
    \x0e\n\x06\x043\x04\x01\x02\x0c\x12\x04\xe3\x12\x04\x18\n\x0f\n\x07\x043\
    \x04\x01\x02\x0c\x01\x12\x04\xe3\x12\x04\x13\n\x0f\n\x07\x043\x04\x01\
    \x02\x0c\x02\x12\x04\xe3\x12\x16\x17\n\x0e\n\x06\x043\x04\x01\x02\r\x12\
    \x04\xe4\x12\x04#\n\x0f\n\x07\x043\x04\x01\x02\r\x01\x12\x04\xe4\x12\x04\
    \x1e\n\x0f\n\x07\x043\x04\x01\x02\r\x02\x12\x04\xe4\x12!\"\n\x0e\n\x06\
    \x043\x04\x01\x02\x0e\x12\x04\xe5\x12\x04\x1e\n\x0f\n\x07\x043\x04\x01\
    \x02\x0e\x01\x12\x04\xe5\x12\x04\x19\n\x0f\n\x07\x043\x04\x01\x02\x0e\
    \x02\x12\x04\xe5\x12\x1c\x1d\n\x0e\n\x06\x043\x04\x01\x02\x0f\x12\x04\
    \xe6\x12\x04&\n\x0f\n\x07\x043\x04\x01\x02\x0f\x01\x12\x04\xe6\x12\x04\
    \x20\n\x0f\n\x07\x043\x04\x01\x02\x0f\x02\x12\x04\xe6\x12#%\n\x0e\n\x06\
    \x043\x04\x01\x02\x10\x12\x04\xe7\x12\x04#\n\x0f\n\x07\x043\x04\x01\x02\
    \x10\x01\x12\x04\xe7\x12\x04\x1e\n\x0f\n\x07\x043\x04\x01\x02\x10\x02\
    \x12\x04\xe7\x12!\"\n\x0e\n\x06\x043\x04\x01\x02\x11\x12\x04\xe8\x12\x04\
    \x1e\n\x0f\n\x07\x043\x04\x01\x02\x11\x01\x12\x04\xe8\x12\x04\x19\n\x0f\
    \n\x07\x043\x04\x01\x02\x11\x02\x12\x04\xe8\x12\x1c\x1d\n\x0e\n\x06\x043\
    \x04\x01\x02\x12\x12\x04\xe9\x12\x04\"\n\x0f\n\x07\x043\x04\x01\x02\x12\
    \x01\x12\x04\xe9\x12\x04\x1c\n\x0f\n\x07\x043\x04\x01\x02\x12\x02\x12\
    \x04\xe9\x12\x1f!\n\x0e\n\x06\x043\x04\x01\x02\x13\x12\x04\xea\x12\x04#\
    \n\x0f\n\x07\x043\x04\x01\x02\x13\x01\x12\x04\xea\x12\x04\x1d\n\x0f\n\
    \x07\x043\x04\x01\x02\x13\x02\x12\x04\xea\x12\x20\"\n\x0e\n\x06\x043\x04\
    \x01\x02\x14\x12\x04\xeb\x12\x04\x1e\n\x0f\n\x07\x043\x04\x01\x02\x14\
    \x01\x12\x04\xeb\x12\x04\x18\n\x0f\n\x07\x043\x04\x01\x02\x14\x02\x12\
    \x04\xeb\x12\x1b\x1d\n\x0e\n\x06\x043\x04\x01\x02\x15\x12\x04\xec\x12\
    \x04*\n\x0f\n\x07\x043\x04\x01\x02\x15\x01\x12\x04\xec\x12\x04$\n\x0f\n\
    \x07\x043\x04\x01\x02\x15\x02\x12\x04\xec\x12')\n\x0e\n\x06\x043\x04\x01\
    \x02\x16\x12\x04\xed\x12\x04#\n\x0f\n\x07\x043\x04\x01\x02\x16\x01\x12\
    \x04\xed\x12\x04\x1d\n\x0f\n\x07\x043\x04\x01\x02\x16\x02\x12\x04\xed\
    \x12\x20\"\n\x0e\n\x06\x043\x04\x01\x02\x17\x12\x04\xee\x12\x04\x20\n\
    \x0f\n\x07\x043\x04\x01\x02\x17\x01\x12\x04\xee\x12\x04\x1a\n\x0f\n\x07\
    \x043\x04\x01\x02\x17\x02\x12\x04\xee\x12\x1d\x1f\n\x0e\n\x06\x043\x04\
    \x01\x02\x18\x12\x04\xef\x12\x04\x1e\n\x0f\n\x07\x043\x04\x01\x02\x18\
    \x01\x12\x04\xef\x12\x04\x18\n\x0f\n\x07\x043\x04\x01\x02\x18\x02\x12\
    \x04\xef\x12\x1b\x1d\n\x0e\n\x06\x043\x04\x01\x02\x19\x12\x04\xf0\x12\
    \x04*\n\x0f\n\x07\x043\x04\x01\x02\x19\x01\x12\x04\xf0\x12\x04$\n\x0f\n\
    \x07\x043\x04\x01\x02\x19\x02\x12\x04\xf0\x12')\n\x0e\n\x06\x043\x04\x01\
    \x02\x1a\x12\x04\xf1\x12\x04*\n\x0f\n\x07\x043\x04\x01\x02\x1a\x01\x12\
    \x04\xf1\x12\x04$\n\x0f\n\x07\x043\x04\x01\x02\x1a\x02\x12\x04\xf1\x12')\
    \n\x0e\n\x06\x043\x04\x01\x02\x1b\x12\x04\xf2\x12\x041\n\x0f\n\x07\x043\
    \x04\x01\x02\x1b\x01\x12\x04\xf2\x12\x04+\n\x0f\n\x07\x043\x04\x01\x02\
    \x1b\x02\x12\x04\xf2\x12.0\n\x0e\n\x06\x043\x04\x01\x02\x1c\x12\x04\xf3\
    \x12\x04#\n\x0f\n\x07\x043\x04\x01\x02\x1c\x01\x12\x04\xf3\x12\x04\x1d\n\
    \x0f\n\x07\x043\x04\x01\x02\x1c\x02\x12\x04\xf3\x12\x20\"\n\x0e\n\x06\
    \x043\x04\x01\x02\x1d\x12\x04\xf4\x12\x04(\n\x0f\n\x07\x043\x04\x01\x02\
    \x1d\x01\x12\x04\xf4\x12\x04\"\n\x0f\n\x07\x043\x04\x01\x02\x1d\x02\x12\
    \x04\xf4\x12%'\n\x0e\n\x06\x043\x04\x01\x02\x1e\x12\x04\xf5\x12\x04\x1d\
    \n\x0f\n\x07\x043\x04\x01\x02\x1e\x01\x12\x04\xf5\x12\x04\x17\n\x0f\n\
    \x07\x043\x04\x01\x02\x1e\x02\x12\x04\xf5\x12\x1a\x1c\n\x0e\n\x06\x043\
    \x04\x01\x02\x1f\x12\x04\xf6\x12\x04\"\n\x0f\n\x07\x043\x04\x01\x02\x1f\
    \x01\x12\x04\xf6\x12\x04\x1c\n\x0f\n\x07\x043\x04\x01\x02\x1f\x02\x12\
    \x04\xf6\x12\x1f!\n\x0e\n\x06\x043\x04\x01\x02\x20\x12\x04\xf7\x12\x04\
    \x1d\n\x0f\n\x07\x043\x04\x01\x02\x20\x01\x12\x04\xf7\x12\x04\x17\n\x0f\
    \n\x07\x043\x04\x01\x02\x20\x02\x12\x04\xf7\x12\x1a\x1c\n\x0c\n\x04\x043\
    \x02\0\x12\x04\xfa\x12\x02\x1e\n\r\n\x05\x043\x02\0\x04\x12\x04\xfa\x12\
    \x02\n\n\r\n\x05\x043\x02\0\x06\x12\x04\xfa\x12\x0b\x11\n\r\n\x05\x043\
    \x02\0\x01\x12\x04\xfa\x12\x12\x19\n\r\n\x05\x043\x02\0\x03\x12\x04\xfa\
    \x12\x1c\x1d\n\x0c\n\x04\x043\x02\x01\x12\x04\xfb\x12\x02\x1f\n\r\n\x05\
    \x043\x02\x01\x04\x12\x04\xfb\x12\x02\n\n\r\n\x05\x043\x02\x01\x06\x12\
    \x04\xfb\x12\x0b\x14\n\r\n\x05\x043\x02\x01\x01\x12\x04\xfb\x12\x15\x1a\
    \n\r\n\x05\x043\x02\x01\x03\x12\x04\xfb\x12\x1d\x1e\n2\n\x04\x043\x02\
    \x02\x12\x04\xfc\x12\x02\x1e\"$\x20Possible\x20message\x20explaining\x20\
    state.\n\n\r\n\x05\x043\x02\x02\x04\x12\x04\xfc\x12\x02\n\n\r\n\x05\x043\
    \x02\x02\x05\x12\x04\xfc\x12\x0b\x11\n\r\n\x05\x043\x02\x02\x01\x12\x04\
    \xfc\x12\x12\x19\n\r\n\x05\x043\x02\x02\x03\x12\x04\xfc\x12\x1c\x1d\n\
    \x0c\n\x04\x043\x02\x03\x12\x04\xfd\x12\x02\x1d\n\r\n\x05\x043\x02\x03\
    \x04\x12\x04\xfd\x12\x02\n\n\r\n\x05\x043\x02\x03\x06\x12\x04\xfd\x12\
    \x0b\x11\n\r\n\x05\x043\x02\x03\x01\x12\x04\xfd\x12\x12\x18\n\r\n\x05\
    \x043\x02\x03\x03\x12\x04\xfd\x12\x1b\x1c\n\x0c\n\x04\x043\x02\x04\x12\
    \x04\xfe\x12\x02\x1e\n\r\n\x05\x043\x02\x04\x04\x12\x04\xfe\x12\x02\n\n\
    \r\n\x05\x043\x02\x04\x06\x12\x04\xfe\x12\x0b\x11\n\r\n\x05\x043\x02\x04\
    \x01\x12\x04\xfe\x12\x12\x18\n\r\n\x05\x043\x02\x04\x03\x12\x04\xfe\x12\
    \x1b\x1d\n\x0c\n\x04\x043\x02\x05\x12\x04\xff\x12\x02\x1a\n\r\n\x05\x043\
    \x02\x05\x04\x12\x04\xff\x12\x02\n\n\r\n\x05\x043\x02\x05\x05\x12\x04\
    \xff\x12\x0b\x10\n\r\n\x05\x043\x02\x05\x01\x12\x04\xff\x12\x11\x15\n\r\
    \n\x05\x043\x02\x05\x03\x12\x04\xff\x12\x18\x19\n\x0c\n\x04\x043\x02\x06\
    \x12\x04\x80\x13\x02\x20\n\r\n\x05\x043\x02\x06\x04\x12\x04\x80\x13\x02\
    \n\n\r\n\x05\x043\x02\x06\x06\x12\x04\x80\x13\x0b\x12\n\r\n\x05\x043\x02\
    \x06\x01\x12\x04\x80\x13\x13\x1b\n\r\n\x05\x043\x02\x06\x03\x12\x04\x80\
    \x13\x1e\x1f\n0\n\x04\x043\x02\x07\x12\x04\x81\x13\x02&\"\"\x20TODO(benh\
    ):\x20Use\x20in\x20master/agent.\n\n\r\n\x05\x043\x02\x07\x04\x12\x04\
    \x81\x13\x02\n\n\r\n\x05\x043\x02\x07\x06\x12\x04\x81\x13\x0b\x15\n\r\n\
    \x05\x043\x02\x07\x01\x12\x04\x81\x13\x16!\n\r\n\x05\x043\x02\x07\x03\
    \x12\x04\x81\x13$%\n\x0c\n\x04\x043\x02\x08\x12\x04\x82\x13\x02\x20\n\r\
    \n\x05\x043\x02\x08\x04\x12\x04\x82\x13\x02\n\n\r\n\x05\x043\x02\x08\x05\
    \x12\x04\x82\x13\x0b\x11\n\r\n\x05\x043\x02\x08\x01\x12\x04\x82\x13\x12\
    \x1b\n\r\n\x05\x043\x02\x08\x03\x12\x04\x82\x13\x1e\x1f\n\xde\x03\n\x04\
    \x043\x02\t\x12\x04\x8d\x13\x02\x1b\x1a\xcf\x03\x20Statuses\x20that\x20a\
    re\x20delivered\x20reliably\x20to\x20the\x20scheduler\x20will\n\x20inclu\
    de\x20a\x20'uuid'.\x20The\x20status\x20is\x20considered\x20delivered\x20\
    once\n\x20it\x20is\x20acknowledged\x20by\x20the\x20scheduler.\x20Schedul\
    ers\x20can\x20choose\n\x20to\x20either\x20explicitly\x20acknowledge\x20s\
    tatuses\x20or\x20let\x20the\x20scheduler\n\x20driver\x20implicitly\x20ac\
    knowledge\x20(default).\n\n\x20TODO(bmahler):\x20This\x20is\x20currently\
    \x20overwritten\x20in\x20the\x20scheduler\n\x20driver\x20and\x20executor\
    \x20driver,\x20but\x20executors\x20will\x20need\x20to\x20set\x20this\n\
    \x20to\x20a\x20valid\x20RFC-4122\x20UUID\x20if\x20using\x20the\x20HTTP\
    \x20API.\n\n\r\n\x05\x043\x02\t\x04\x12\x04\x8d\x13\x02\n\n\r\n\x05\x043\
    \x02\t\x05\x12\x04\x8d\x13\x0b\x10\n\r\n\x05\x043\x02\t\x01\x12\x04\x8d\
    \x13\x11\x15\n\r\n\x05\x043\x02\t\x03\x12\x04\x8d\x13\x18\x1a\n\x9f\x01\
    \n\x04\x043\x02\n\x12\x04\x91\x13\x02\x1c\x1a\x90\x01\x20Describes\x20wh\
    ether\x20the\x20task\x20has\x20been\x20determined\x20to\x20be\x20healthy\
    \x20(true)\x20or\n\x20unhealthy\x20(false)\x20according\x20to\x20the\x20\
    `health_check`\x20field\x20in\x20`TaskInfo`.\n\n\r\n\x05\x043\x02\n\x04\
    \x12\x04\x91\x13\x02\n\n\r\n\x05\x043\x02\n\x05\x12\x04\x91\x13\x0b\x0f\
    \n\r\n\x05\x043\x02\n\x01\x12\x04\x91\x13\x10\x17\n\r\n\x05\x043\x02\n\
    \x03\x12\x04\x91\x13\x1a\x1b\n\xc1\x04\n\x04\x043\x02\x0b\x12\x04\x9e\
    \x13\x02-\x1a\xb2\x04\x20Contains\x20check\x20status\x20for\x20the\x20ch\
    eck\x20specified\x20in\x20the\x20corresponding\n\x20`TaskInfo`.\x20If\
    \x20no\x20check\x20has\x20been\x20specified,\x20this\x20field\x20must\
    \x20be\n\x20absent,\x20otherwise\x20it\x20must\x20be\x20present\x20even\
    \x20if\x20the\x20check\x20status\x20is\n\x20not\x20available\x20yet.\x20\
    If\x20the\x20status\x20update\x20is\x20triggered\x20for\x20a\x20differen\
    t\n\x20reason\x20than\x20`REASON_TASK_CHECK_STATUS_UPDATED`,\x20this\x20\
    field\x20will\x20contain\n\x20the\x20last\x20known\x20value.\n\n\x20NOTE\
    :\x20A\x20check-related\x20task\x20status\x20update\x20is\x20triggered\
    \x20if\x20and\x20only\x20if\n\x20the\x20value\x20or\x20presence\x20of\
    \x20any\x20field\x20in\x20`CheckStatusInfo`\x20changes.\n\n\x20NOTE:\x20\
    Check\x20support\x20in\x20built-in\x20executors\x20is\x20experimental.\n\
    \n\r\n\x05\x043\x02\x0b\x04\x12\x04\x9e\x13\x02\n\n\r\n\x05\x043\x02\x0b\
    \x06\x12\x04\x9e\x13\x0b\x1a\n\r\n\x05\x043\x02\x0b\x01\x12\x04\x9e\x13\
    \x1b'\n\r\n\x05\x043\x02\x0b\x03\x12\x04\x9e\x13*,\n\x96\x03\n\x04\x043\
    \x02\x0c\x12\x04\xa6\x13\x02\x1e\x1a\x87\x03\x20Labels\x20are\x20free-fo\
    rm\x20key\x20value\x20pairs\x20which\x20are\x20exposed\x20through\n\x20m\
    aster\x20and\x20agent\x20endpoints.\x20Labels\x20will\x20not\x20be\x20in\
    terpreted\x20or\n\x20acted\x20upon\x20by\x20Mesos\x20itself.\x20As\x20op\
    posed\x20to\x20the\x20data\x20field,\x20labels\n\x20will\x20be\x20kept\
    \x20in\x20memory\x20on\x20master\x20and\x20agent\x20processes.\x20Theref\
    ore,\n\x20labels\x20should\x20be\x20used\x20to\x20tag\x20TaskStatus\x20m\
    essage\x20with\x20light-weight\n\x20meta-data.\x20Labels\x20should\x20no\
    t\x20contain\x20duplicate\x20key-value\x20pairs.\n\n\r\n\x05\x043\x02\
    \x0c\x04\x12\x04\xa6\x13\x02\n\n\r\n\x05\x043\x02\x0c\x06\x12\x04\xa6\
    \x13\x0b\x11\n\r\n\x05\x043\x02\x0c\x01\x12\x04\xa6\x13\x12\x18\n\r\n\
    \x05\x043\x02\x0c\x03\x12\x04\xa6\x13\x1b\x1d\nd\n\x04\x043\x02\r\x12\
    \x04\xaa\x13\x021\x1aV\x20Container\x20related\x20information\x20that\
    \x20is\x20resolved\x20dynamically\x20such\x20as\n\x20network\x20address.\
    \n\n\r\n\x05\x043\x02\r\x04\x12\x04\xaa\x13\x02\n\n\r\n\x05\x043\x02\r\
    \x06\x12\x04\xaa\x13\x0b\x1a\n\r\n\x05\x043\x02\r\x01\x12\x04\xaa\x13\
    \x1b+\n\r\n\x05\x043\x02\r\x03\x12\x04\xaa\x13.0\n\xfb\x01\n\x04\x043\
    \x02\x0e\x12\x04\xb0\x13\x02*\x1a\xec\x01\x20The\x20time\x20(according\
    \x20to\x20the\x20master's\x20clock)\x20when\x20the\x20agent\x20where\n\
    \x20this\x20task\x20was\x20running\x20became\x20unreachable.\x20This\x20\
    is\x20only\x20set\x20on\n\x20status\x20updates\x20for\x20tasks\x20runnin\
    g\x20on\x20agents\x20that\x20are\x20unreachable\n\x20(e.g.,\x20partition\
    ed\x20away\x20from\x20the\x20master).\n\n\r\n\x05\x043\x02\x0e\x04\x12\
    \x04\xb0\x13\x02\n\n\r\n\x05\x043\x02\x0e\x06\x12\x04\xb0\x13\x0b\x13\n\
    \r\n\x05\x043\x02\x0e\x01\x12\x04\xb0\x13\x14$\n\r\n\x05\x043\x02\x0e\
    \x03\x12\x04\xb0\x13')\n\x86\x01\n\x04\x043\x02\x0f\x12\x04\xb4\x13\x022\
    \x1ax\x20If\x20the\x20reason\x20field\x20indicates\x20a\x20container\x20\
    resource\x20limitation,\n\x20this\x20field\x20optionally\x20contains\x20\
    additional\x20information.\n\n\r\n\x05\x043\x02\x0f\x04\x12\x04\xb4\x13\
    \x02\n\n\r\n\x05\x043\x02\x0f\x06\x12\x04\xb4\x13\x0b!\n\r\n\x05\x043\
    \x02\x0f\x01\x12\x04\xb4\x13\",\n\r\n\x05\x043\x02\x0f\x03\x12\x04\xb4\
    \x13/1\n\x95\x01\n\x02\x044\x12\x06\xbc\x13\0\xc9\x13\x01\x1a\x86\x01*\n\
    \x20Describes\x20possible\x20filters\x20that\x20can\x20be\x20applied\x20\
    to\x20unused\x20resources\n\x20(see\x20SchedulerDriver::launchTasks)\x20\
    to\x20influence\x20the\x20allocator.\n\n\x0b\n\x03\x044\x01\x12\x04\xbc\
    \x13\x08\x0f\n\xdb\x04\n\x04\x044\x02\0\x12\x04\xc8\x13\x025\x1a\xcc\x04\
    \x20Time\x20to\x20consider\x20unused\x20resources\x20refused.\x20Note\
    \x20that\x20all\x20unused\n\x20resources\x20will\x20be\x20considered\x20\
    refused\x20and\x20use\x20the\x20default\x20value\n\x20(below)\x20regardl\
    ess\x20of\x20whether\x20Filters\x20was\x20passed\x20to\n\x20SchedulerDri\
    ver::launchTasks.\x20You\x20MUST\x20pass\x20Filters\x20with\x20this\n\
    \x20field\x20set\x20to\x20change\x20this\x20behavior\x20(i.e.,\x20get\
    \x20another\x20offer\x20which\n\x20includes\x20unused\x20resources\x20so\
    oner\x20or\x20later\x20than\x20the\x20default).\n\n\x20If\x20this\x20fie\
    ld\x20is\x20set\x20to\x20a\x20number\x20of\x20seconds\x20greater\x20than\
    \x2031536000\n\x20(365\x20days),\x20then\x20the\x20resources\x20will\x20\
    be\x20considered\x20refused\x20for\x20365\n\x20days.\x20If\x20it\x20is\
    \x20set\x20to\x20a\x20negative\x20number,\x20then\x20the\x20default\x20v\
    alue\n\x20will\x20be\x20used.\n\n\r\n\x05\x044\x02\0\x04\x12\x04\xc8\x13\
    \x02\n\n\r\n\x05\x044\x02\0\x05\x12\x04\xc8\x13\x0b\x11\n\r\n\x05\x044\
    \x02\0\x01\x12\x04\xc8\x13\x12\x20\n\r\n\x05\x044\x02\0\x03\x12\x04\xc8\
    \x13#$\n\r\n\x05\x044\x02\0\x08\x12\x04\xc8\x13%4\n\r\n\x05\x044\x02\0\
    \x07\x12\x04\xc8\x1303\n\x9a\x02\n\x02\x045\x12\x06\xd2\x13\0\xe9\x13\
    \x01\x1a\x8b\x02*\n\x20Describes\x20a\x20collection\x20of\x20environment\
    \x20variables.\x20This\x20is\x20used\x20with\n\x20CommandInfo\x20in\x20o\
    rder\x20to\x20set\x20environment\x20variables\x20before\x20running\x20a\
    \n\x20command.\x20The\x20contents\x20of\x20each\x20variable\x20may\x20be\
    \x20specified\x20as\x20a\x20string\n\x20or\x20a\x20Secret;\x20only\x20on\
    e\x20of\x20`value`\x20and\x20`secret`\x20must\x20be\x20set.\n\n\x0b\n\
    \x03\x045\x01\x12\x04\xd2\x13\x08\x13\n\x0e\n\x04\x045\x03\0\x12\x06\xd3\
    \x13\x02\xe6\x13\x03\n\r\n\x05\x045\x03\0\x01\x12\x04\xd3\x13\n\x12\n\
    \x0e\n\x06\x045\x03\0\x02\0\x12\x04\xd4\x13\x04\x1d\n\x0f\n\x07\x045\x03\
    \0\x02\0\x04\x12\x04\xd4\x13\x04\x0c\n\x0f\n\x07\x045\x03\0\x02\0\x05\
    \x12\x04\xd4\x13\r\x13\n\x0f\n\x07\x045\x03\0\x02\0\x01\x12\x04\xd4\x13\
    \x14\x18\n\x0f\n\x07\x045\x03\0\x02\0\x03\x12\x04\xd4\x13\x1b\x1c\n\x10\
    \n\x06\x045\x03\0\x04\0\x12\x06\xd6\x13\x04\xda\x13\x05\n\x0f\n\x07\x045\
    \x03\0\x04\0\x01\x12\x04\xd6\x13\t\r\n\x10\n\x08\x045\x03\0\x04\0\x02\0\
    \x12\x04\xd7\x13\x06\x12\n\x11\n\t\x045\x03\0\x04\0\x02\0\x01\x12\x04\
    \xd7\x13\x06\r\n\x11\n\t\x045\x03\0\x04\0\x02\0\x02\x12\x04\xd7\x13\x10\
    \x11\n\x10\n\x08\x045\x03\0\x04\0\x02\x01\x12\x04\xd8\x13\x06\x10\n\x11\
    \n\t\x045\x03\0\x04\0\x02\x01\x01\x12\x04\xd8\x13\x06\x0b\n\x11\n\t\x045\
    \x03\0\x04\0\x02\x01\x02\x12\x04\xd8\x13\x0e\x0f\n\x10\n\x08\x045\x03\0\
    \x04\0\x02\x02\x12\x04\xd9\x13\x06\x11\n\x11\n\t\x045\x03\0\x04\0\x02\
    \x02\x01\x12\x04\xd9\x13\x06\x0c\n\x11\n\t\x045\x03\0\x04\0\x02\x02\x02\
    \x12\x04\xd9\x13\x0f\x10\n\xaf\x02\n\x06\x045\x03\0\x02\x01\x12\x04\xe1\
    \x13\x04-\x1a\x9e\x02\x20In\x20Mesos\x201.2,\x20the\x20`Environment.vari\
    ables.value`\x20message\x20was\x20made\n\x20optional.\x20The\x20default\
    \x20type\x20for\x20`Environment.variables.type`\x20is\x20now\x20VALUE,\n\
    \x20which\x20requires\x20`value`\x20to\x20be\x20set,\x20maintaining\x20b\
    ackward\x20compatibility.\n\n\x20TODO(greggomann):\x20The\x20default\x20\
    can\x20be\x20removed\x20in\x20Mesos\x202.1\x20(MESOS-7134).\n\n\x0f\n\
    \x07\x045\x03\0\x02\x01\x04\x12\x04\xe1\x13\x04\x0c\n\x0f\n\x07\x045\x03\
    \0\x02\x01\x06\x12\x04\xe1\x13\r\x11\n\x0f\n\x07\x045\x03\0\x02\x01\x01\
    \x12\x04\xe1\x13\x12\x16\n\x0f\n\x07\x045\x03\0\x02\x01\x03\x12\x04\xe1\
    \x13\x19\x1a\n\x0f\n\x07\x045\x03\0\x02\x01\x08\x12\x04\xe1\x13\x1b,\n\
    \x0f\n\x07\x045\x03\0\x02\x01\x07\x12\x04\xe1\x13&+\n?\n\x06\x045\x03\0\
    \x02\x02\x12\x04\xe4\x13\x04\x1e\x1a/\x20Only\x20one\x20of\x20`value`\
    \x20and\x20`secret`\x20must\x20be\x20set.\n\n\x0f\n\x07\x045\x03\0\x02\
    \x02\x04\x12\x04\xe4\x13\x04\x0c\n\x0f\n\x07\x045\x03\0\x02\x02\x05\x12\
    \x04\xe4\x13\r\x13\n\x0f\n\x07\x045\x03\0\x02\x02\x01\x12\x04\xe4\x13\
    \x14\x19\n\x0f\n\x07\x045\x03\0\x02\x02\x03\x12\x04\xe4\x13\x1c\x1d\n\
    \x0e\n\x06\x045\x03\0\x02\x03\x12\x04\xe5\x13\x04\x1f\n\x0f\n\x07\x045\
    \x03\0\x02\x03\x04\x12\x04\xe5\x13\x04\x0c\n\x0f\n\x07\x045\x03\0\x02\
    \x03\x06\x12\x04\xe5\x13\r\x13\n\x0f\n\x07\x045\x03\0\x02\x03\x01\x12\
    \x04\xe5\x13\x14\x1a\n\x0f\n\x07\x045\x03\0\x02\x03\x03\x12\x04\xe5\x13\
    \x1d\x1e\n\x0c\n\x04\x045\x02\0\x12\x04\xe8\x13\x02\"\n\r\n\x05\x045\x02\
    \0\x04\x12\x04\xe8\x13\x02\n\n\r\n\x05\x045\x02\0\x06\x12\x04\xe8\x13\
    \x0b\x13\n\r\n\x05\x045\x02\0\x01\x12\x04\xe8\x13\x14\x1d\n\r\n\x05\x045\
    \x02\0\x03\x12\x04\xe8\x13\x20!\nT\n\x02\x046\x12\x06\xef\x13\0\xf2\x13\
    \x01\x1aF*\n\x20A\x20generic\x20(key,\x20value)\x20pair\x20used\x20in\
    \x20various\x20places\x20for\x20parameters.\n\n\x0b\n\x03\x046\x01\x12\
    \x04\xef\x13\x08\x11\n\x0c\n\x04\x046\x02\0\x12\x04\xf0\x13\x02\x1a\n\r\
    \n\x05\x046\x02\0\x04\x12\x04\xf0\x13\x02\n\n\r\n\x05\x046\x02\0\x05\x12\
    \x04\xf0\x13\x0b\x11\n\r\n\x05\x046\x02\0\x01\x12\x04\xf0\x13\x12\x15\n\
    \r\n\x05\x046\x02\0\x03\x12\x04\xf0\x13\x18\x19\n\x0c\n\x04\x046\x02\x01\
    \x12\x04\xf1\x13\x02\x1c\n\r\n\x05\x046\x02\x01\x04\x12\x04\xf1\x13\x02\
    \n\n\r\n\x05\x046\x02\x01\x05\x12\x04\xf1\x13\x0b\x11\n\r\n\x05\x046\x02\
    \x01\x01\x12\x04\xf1\x13\x12\x17\n\r\n\x05\x046\x02\x01\x03\x12\x04\xf1\
    \x13\x1a\x1b\n*\n\x02\x047\x12\x06\xf8\x13\0\xfa\x13\x01\x1a\x1c*\n\x20C\
    ollection\x20of\x20Parameter.\n\n\x0b\n\x03\x047\x01\x12\x04\xf8\x13\x08\
    \x12\n\x0c\n\x04\x047\x02\0\x12\x04\xf9\x13\x02#\n\r\n\x05\x047\x02\0\
    \x04\x12\x04\xf9\x13\x02\n\n\r\n\x05\x047\x02\0\x06\x12\x04\xf9\x13\x0b\
    \x14\n\r\n\x05\x047\x02\0\x01\x12\x04\xf9\x13\x15\x1e\n\r\n\x05\x047\x02\
    \0\x03\x12\x04\xf9\x13!\"\n\xc0\x02\n\x02\x048\x12\x06\x86\x14\0\x89\x14\
    \x01\x1a\xb1\x02*\n\x20Credential\x20used\x20in\x20various\x20places\x20\
    for\x20authentication\x20and\n\x20authorization.\n\n\x20NOTE:\x20A\x20'p\
    rincipal'\x20is\x20different\x20from\x20'FrameworkInfo.user'.\x20The\n\
    \x20former\x20is\x20used\x20for\x20authentication\x20and\x20authorizatio\
    n\x20while\x20the\n\x20latter\x20is\x20used\x20to\x20determine\x20the\
    \x20default\x20user\x20under\x20which\x20the\n\x20framework's\x20executo\
    rs/tasks\x20are\x20run.\n\n\x0b\n\x03\x048\x01\x12\x04\x86\x14\x08\x12\n\
    \x0c\n\x04\x048\x02\0\x12\x04\x87\x14\x02\x20\n\r\n\x05\x048\x02\0\x04\
    \x12\x04\x87\x14\x02\n\n\r\n\x05\x048\x02\0\x05\x12\x04\x87\x14\x0b\x11\
    \n\r\n\x05\x048\x02\0\x01\x12\x04\x87\x14\x12\x1b\n\r\n\x05\x048\x02\0\
    \x03\x12\x04\x87\x14\x1e\x1f\n\x0c\n\x04\x048\x02\x01\x12\x04\x88\x14\
    \x02\x1d\n\r\n\x05\x048\x02\x01\x04\x12\x04\x88\x14\x02\n\n\r\n\x05\x048\
    \x02\x01\x05\x12\x04\x88\x14\x0b\x11\n\r\n\x05\x048\x02\x01\x01\x12\x04\
    \x88\x14\x12\x18\n\r\n\x05\x048\x02\x01\x03\x12\x04\x88\x14\x1b\x1c\n\
    \xc0\x01\n\x02\x049\x12\x06\x91\x14\0\x93\x14\x01\x1a\xb1\x01*\n\x20Cred\
    entials\x20used\x20for\x20framework\x20authentication,\x20HTTP\x20authen\
    tication\n\x20(where\x20the\x20common\x20'username'\x20and\x20'password'\
    \x20are\x20captured\x20as\n\x20'principal'\x20and\x20'secret'\x20respect\
    ively),\x20etc.\n\n\x0b\n\x03\x049\x01\x12\x04\x91\x14\x08\x13\n\x0c\n\
    \x04\x049\x02\0\x12\x04\x92\x14\x02&\n\r\n\x05\x049\x02\0\x04\x12\x04\
    \x92\x14\x02\n\n\r\n\x05\x049\x02\0\x06\x12\x04\x92\x14\x0b\x15\n\r\n\
    \x05\x049\x02\0\x01\x12\x04\x92\x14\x16!\n\r\n\x05\x049\x02\0\x03\x12\
    \x04\x92\x14$%\n\xe6\x01\n\x02\x04:\x12\x06\x9b\x14\0\xc2\x14\x01\x1a\
    \xd7\x01*\n\x20Secret\x20used\x20to\x20pass\x20privileged\x20information\
    .\x20It\x20is\x20designed\x20to\x20provide\n\x20pass-by-value\x20or\x20p\
    ass-by-reference\x20semantics,\x20where\x20the\x20REFERENCE\x20type\x20c\
    an\x20be\n\x20used\x20by\x20custom\x20modules\x20which\x20interact\x20wi\
    th\x20a\x20secure\x20back-end.\n\n\x0b\n\x03\x04:\x01\x12\x04\x9b\x14\
    \x08\x0e\n\x0e\n\x04\x04:\x04\0\x12\x06\x9d\x14\x02\xa1\x14\x03\n\r\n\
    \x05\x04:\x04\0\x01\x12\x04\x9d\x14\x07\x0b\n\x0e\n\x06\x04:\x04\0\x02\0\
    \x12\x04\x9e\x14\x04\x10\n\x0f\n\x07\x04:\x04\0\x02\0\x01\x12\x04\x9e\
    \x14\x04\x0b\n\x0f\n\x07\x04:\x04\0\x02\0\x02\x12\x04\x9e\x14\x0e\x0f\n\
    \x0e\n\x06\x04:\x04\0\x02\x01\x12\x04\x9f\x14\x04\x12\n\x0f\n\x07\x04:\
    \x04\0\x02\x01\x01\x12\x04\x9f\x14\x04\r\n\x0f\n\x07\x04:\x04\0\x02\x01\
    \x02\x12\x04\x9f\x14\x10\x11\n\x0e\n\x06\x04:\x04\0\x02\x02\x12\x04\xa0\
    \x14\x04\x0e\n\x0f\n\x07\x04:\x04\0\x02\x02\x01\x12\x04\xa0\x14\x04\t\n\
    \x0f\n\x07\x04:\x04\0\x02\x02\x02\x12\x04\xa0\x14\x0c\r\n\x8c\x04\n\x04\
    \x04:\x03\0\x12\x06\xb1\x14\x02\xb5\x14\x03\x1a\xfb\x03\x20Can\x20be\x20\
    used\x20by\x20modules\x20to\x20refer\x20to\x20a\x20secret\x20stored\x20i\
    n\x20a\x20secure\x20back-end.\n\x20The\x20`key`\x20field\x20is\x20provid\
    ed\x20to\x20permit\x20reference\x20to\x20a\x20single\x20value\x20within\
    \x20a\n\x20secret\x20containing\x20arbitrary\x20key-value\x20pairs.\n\n\
    \x20For\x20example,\x20given\x20a\x20back-end\x20secret\x20store\x20with\
    \x20a\x20secret\x20named\n\x20\"my-secret\"\x20containing\x20the\x20foll\
    owing\x20key-value\x20pairs:\n\n\x20\x20\x20{\n\x20\x20\x20\x20\x20\"use\
    rname\":\x20\"my-user\",\n\x20\x20\x20\x20\x20\"password\":\x20\"my-pass\
    word\n\x20\x20\x20}\n\n\x20the\x20username\x20could\x20be\x20referred\
    \x20to\x20in\x20a\x20`Secret`\x20by\x20specifying\n\x20\"my-secret\"\x20\
    for\x20the\x20`name`\x20and\x20\"username\"\x20for\x20the\x20`key`.\n\n\
    \r\n\x05\x04:\x03\0\x01\x12\x04\xb1\x14\n\x13\n\x0e\n\x06\x04:\x03\0\x02\
    \0\x12\x04\xb3\x14\x04\x1d\n\x0f\n\x07\x04:\x03\0\x02\0\x04\x12\x04\xb3\
    \x14\x04\x0c\n\x0f\n\x07\x04:\x03\0\x02\0\x05\x12\x04\xb3\x14\r\x13\n\
    \x0f\n\x07\x04:\x03\0\x02\0\x01\x12\x04\xb3\x14\x14\x18\n\x0f\n\x07\x04:\
    \x03\0\x02\0\x03\x12\x04\xb3\x14\x1b\x1c\n\x0e\n\x06\x04:\x03\0\x02\x01\
    \x12\x04\xb4\x14\x04\x1c\n\x0f\n\x07\x04:\x03\0\x02\x01\x04\x12\x04\xb4\
    \x14\x04\x0c\n\x0f\n\x07\x04:\x03\0\x02\x01\x05\x12\x04\xb4\x14\r\x13\n\
    \x0f\n\x07\x04:\x03\0\x02\x01\x01\x12\x04\xb4\x14\x14\x17\n\x0f\n\x07\
    \x04:\x03\0\x02\x01\x03\x12\x04\xb4\x14\x1a\x1b\n5\n\x04\x04:\x03\x01\
    \x12\x06\xb8\x14\x02\xbb\x14\x03\x1a%\x20Used\x20to\x20pass\x20the\x20va\
    lue\x20of\x20a\x20secret.\n\n\r\n\x05\x04:\x03\x01\x01\x12\x04\xb8\x14\n\
    \x0f\n\x0e\n\x06\x04:\x03\x01\x02\0\x12\x04\xba\x14\x04\x1c\n\x0f\n\x07\
    \x04:\x03\x01\x02\0\x04\x12\x04\xba\x14\x04\x0c\n\x0f\n\x07\x04:\x03\x01\
    \x02\0\x05\x12\x04\xba\x14\r\x12\n\x0f\n\x07\x04:\x03\x01\x02\0\x01\x12\
    \x04\xba\x14\x13\x17\n\x0f\n\x07\x04:\x03\x01\x02\0\x03\x12\x04\xba\x14\
    \x1a\x1b\n\x0c\n\x04\x04:\x02\0\x12\x04\xbd\x14\x02\x19\n\r\n\x05\x04:\
    \x02\0\x04\x12\x04\xbd\x14\x02\n\n\r\n\x05\x04:\x02\0\x06\x12\x04\xbd\
    \x14\x0b\x0f\n\r\n\x05\x04:\x02\0\x01\x12\x04\xbd\x14\x10\x14\n\r\n\x05\
    \x04:\x02\0\x03\x12\x04\xbd\x14\x17\x18\n@\n\x04\x04:\x02\x01\x12\x04\
    \xc0\x14\x02#\x1a2\x20Only\x20one\x20of\x20`reference`\x20and\x20`value`\
    \x20must\x20be\x20set.\n\n\r\n\x05\x04:\x02\x01\x04\x12\x04\xc0\x14\x02\
    \n\n\r\n\x05\x04:\x02\x01\x06\x12\x04\xc0\x14\x0b\x14\n\r\n\x05\x04:\x02\
    \x01\x01\x12\x04\xc0\x14\x15\x1e\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xc0\
    \x14!\"\n\x0c\n\x04\x04:\x02\x02\x12\x04\xc1\x14\x02\x1b\n\r\n\x05\x04:\
    \x02\x02\x04\x12\x04\xc1\x14\x02\n\n\r\n\x05\x04:\x02\x02\x06\x12\x04\
    \xc1\x14\x0b\x10\n\r\n\x05\x04:\x02\x02\x01\x12\x04\xc1\x14\x11\x16\n\r\
    \n\x05\x04:\x02\x02\x03\x12\x04\xc1\x14\x19\x1a\n\xba\x01\n\x02\x04;\x12\
    \x06\xca\x14\0\xda\x14\x01\x1a\xab\x01*\n\x20Rate\x20(queries\x20per\x20\
    second,\x20QPS)\x20limit\x20for\x20messages\x20from\x20a\x20framework\
    \x20to\x20master.\n\x20Strictly\x20speaking\x20they\x20are\x20the\x20com\
    bined\x20rate\x20from\x20all\x20frameworks\x20of\x20the\x20same\n\x20pri\
    ncipal.\n\n\x0b\n\x03\x04;\x01\x12\x04\xca\x14\x08\x11\nx\n\x04\x04;\x02\
    \0\x12\x04\xcd\x14\x02\x1a\x1aj\x20Leaving\x20QPS\x20unset\x20gives\x20i\
    t\x20unlimited\x20rate\x20(i.e.,\x20not\x20throttled),\n\x20which\x20als\
    o\x20implies\x20unlimited\x20capacity.\n\n\r\n\x05\x04;\x02\0\x04\x12\
    \x04\xcd\x14\x02\n\n\r\n\x05\x04;\x02\0\x05\x12\x04\xcd\x14\x0b\x11\n\r\
    \n\x05\x04;\x02\0\x01\x12\x04\xcd\x14\x12\x15\n\r\n\x05\x04;\x02\0\x03\
    \x12\x04\xcd\x14\x18\x19\n\x95\x01\n\x04\x04;\x02\x01\x12\x04\xd1\x14\
    \x02\x20\x1a\x86\x01\x20Principal\x20of\x20framework(s)\x20to\x20be\x20t\
    hrottled.\x20Should\x20match\n\x20FrameworkInfo.principal\x20and\x20Cred\
    ential.principal\x20(if\x20using\x20authentication).\n\n\r\n\x05\x04;\
    \x02\x01\x04\x12\x04\xd1\x14\x02\n\n\r\n\x05\x04;\x02\x01\x05\x12\x04\
    \xd1\x14\x0b\x11\n\r\n\x05\x04;\x02\x01\x01\x12\x04\xd1\x14\x12\x1b\n\r\
    \n\x05\x04;\x02\x01\x03\x12\x04\xd1\x14\x1e\x1f\n\x92\x03\n\x04\x04;\x02\
    \x02\x12\x04\xd9\x14\x02\x1f\x1a\x83\x03\x20Max\x20number\x20of\x20outst\
    anding\x20messages\x20from\x20frameworks\x20of\x20this\x20principal\n\
    \x20allowed\x20by\x20master\x20before\x20the\x20next\x20message\x20is\
    \x20dropped\x20and\x20an\x20error\x20is\x20sent\n\x20back\x20to\x20the\
    \x20sender.\x20Messages\x20received\x20before\x20the\x20capacity\x20is\
    \x20reached\x20are\n\x20still\x20going\x20to\x20be\x20processed\x20after\
    \x20the\x20error\x20is\x20sent.\n\x20If\x20unspecified,\x20this\x20princ\
    ipal\x20is\x20assigned\x20unlimited\x20capacity.\n\x20NOTE:\x20This\x20v\
    alue\x20is\x20ignored\x20if\x20'qps'\x20is\x20not\x20set.\n\n\r\n\x05\
    \x04;\x02\x02\x04\x12\x04\xd9\x14\x02\n\n\r\n\x05\x04;\x02\x02\x05\x12\
    \x04\xd9\x14\x0b\x11\n\r\n\x05\x04;\x02\x02\x01\x12\x04\xd9\x14\x12\x1a\
    \n\r\n\x05\x04;\x02\x02\x03\x12\x04\xd9\x14\x1d\x1e\n\x98\x01\n\x02\x04<\
    \x12\x06\xe2\x14\0\xee\x14\x01\x1a\x89\x01*\n\x20Collection\x20of\x20Rat\
    eLimit.\n\x20Frameworks\x20without\x20rate\x20limits\x20defined\x20here\
    \x20are\x20not\x20throttled\x20unless\n\x20'aggregate_default_qps'\x20is\
    \x20specified.\n\n\x0b\n\x03\x04<\x01\x12\x04\xe2\x14\x08\x12\n4\n\x04\
    \x04<\x02\0\x12\x04\xe4\x14\x02\x20\x1a&\x20Items\x20should\x20have\x20u\
    nique\x20principals.\n\n\r\n\x05\x04<\x02\0\x04\x12\x04\xe4\x14\x02\n\n\
    \r\n\x05\x04<\x02\0\x06\x12\x04\xe4\x14\x0b\x14\n\r\n\x05\x04<\x02\0\x01\
    \x12\x04\xe4\x14\x15\x1b\n\r\n\x05\x04<\x02\0\x03\x12\x04\xe4\x14\x1e\
    \x1f\n\xc7\x01\n\x04\x04<\x02\x01\x12\x04\xe9\x14\x02,\x1a\xb8\x01\x20Al\
    l\x20the\x20frameworks\x20not\x20specified\x20in\x20'limits'\x20get\x20t\
    his\x20default\x20rate.\n\x20This\x20rate\x20is\x20an\x20aggregate\x20ra\
    te\x20for\x20all\x20of\x20them,\x20i.e.,\x20their\x20combined\n\x20traff\
    ic\x20is\x20throttled\x20together\x20at\x20this\x20rate.\n\n\r\n\x05\x04\
    <\x02\x01\x04\x12\x04\xe9\x14\x02\n\n\r\n\x05\x04<\x02\x01\x05\x12\x04\
    \xe9\x14\x0b\x11\n\r\n\x05\x04<\x02\x01\x01\x12\x04\xe9\x14\x12'\n\r\n\
    \x05\x04<\x02\x01\x03\x12\x04\xe9\x14*+\n\x98\x01\n\x04\x04<\x02\x02\x12\
    \x04\xed\x14\x021\x1a\x89\x01\x20All\x20the\x20frameworks\x20not\x20spec\
    ified\x20in\x20'limits'\x20get\x20this\x20default\x20capacity.\n\x20This\
    \x20is\x20an\x20aggregate\x20value\x20similar\x20to\x20'aggregate_defaul\
    t_qps'.\n\n\r\n\x05\x04<\x02\x02\x04\x12\x04\xed\x14\x02\n\n\r\n\x05\x04\
    <\x02\x02\x05\x12\x04\xed\x14\x0b\x11\n\r\n\x05\x04<\x02\x02\x01\x12\x04\
    \xed\x14\x12,\n\r\n\x05\x04<\x02\x02\x03\x12\x04\xed\x14/0\n\x96\x01\n\
    \x02\x04=\x12\x06\xf5\x14\0\xac\x15\x01\x1a\x87\x01*\n\x20Describe\x20an\
    \x20image\x20used\x20by\x20tasks\x20or\x20executors.\x20Note\x20that\x20\
    it's\x20only\n\x20for\x20tasks\x20or\x20executors\x20launched\x20by\x20M\
    esosContainerizer\x20currently.\n\n\x0b\n\x03\x04=\x01\x12\x04\xf5\x14\
    \x08\r\n\x0e\n\x04\x04=\x04\0\x12\x06\xf6\x14\x02\xf9\x14\x03\n\r\n\x05\
    \x04=\x04\0\x01\x12\x04\xf6\x14\x07\x0b\n\x0e\n\x06\x04=\x04\0\x02\0\x12\
    \x04\xf7\x14\x04\r\n\x0f\n\x07\x04=\x04\0\x02\0\x01\x12\x04\xf7\x14\x04\
    \x08\n\x0f\n\x07\x04=\x04\0\x02\0\x02\x12\x04\xf7\x14\x0b\x0c\n\x0e\n\
    \x06\x04=\x04\0\x02\x01\x12\x04\xf8\x14\x04\x0f\n\x0f\n\x07\x04=\x04\0\
    \x02\x01\x01\x12\x04\xf8\x14\x04\n\n\x0f\n\x07\x04=\x04\0\x02\x01\x02\
    \x12\x04\xf8\x14\r\x0e\n}\n\x04\x04=\x03\0\x12\x06\xfd\x14\x02\x89\x15\
    \x03\x1am\x20Protobuf\x20for\x20specifying\x20an\x20Appc\x20container\
    \x20image.\x20See:\n\x20https://github.com/appc/spec/blob/master/spec/ac\
    i.md\n\n\r\n\x05\x04=\x03\0\x01\x12\x04\xfd\x14\n\x0e\n(\n\x06\x04=\x03\
    \0\x02\0\x12\x04\xff\x14\x04\x1d\x1a\x18\x20The\x20name\x20of\x20the\x20\
    image.\n\n\x0f\n\x07\x04=\x03\0\x02\0\x04\x12\x04\xff\x14\x04\x0c\n\x0f\
    \n\x07\x04=\x03\0\x02\0\x05\x12\x04\xff\x14\r\x13\n\x0f\n\x07\x04=\x03\0\
    \x02\0\x01\x12\x04\xff\x14\x14\x18\n\x0f\n\x07\x04=\x03\0\x02\0\x03\x12\
    \x04\xff\x14\x1b\x1c\n\xdd\x01\n\x06\x04=\x03\0\x02\x01\x12\x04\x85\x15\
    \x04\x1b\x1a\xcc\x01\x20An\x20image\x20ID\x20is\x20a\x20string\x20of\x20\
    the\x20format\x20\"hash-value\",\x20where\n\x20\"hash\"\x20is\x20the\x20\
    hash\x20algorithm\x20used\x20and\x20\"value\"\x20is\x20the\x20hex\n\x20e\
    ncoded\x20string\x20of\x20the\x20digest.\x20Currently\x20the\x20only\x20\
    permitted\n\x20hash\x20algorithm\x20is\x20sha512.\n\n\x0f\n\x07\x04=\x03\
    \0\x02\x01\x04\x12\x04\x85\x15\x04\x0c\n\x0f\n\x07\x04=\x03\0\x02\x01\
    \x05\x12\x04\x85\x15\r\x13\n\x0f\n\x07\x04=\x03\0\x02\x01\x01\x12\x04\
    \x85\x15\x14\x16\n\x0f\n\x07\x04=\x03\0\x02\x01\x03\x12\x04\x85\x15\x19\
    \x1a\nQ\n\x06\x04=\x03\0\x02\x02\x12\x04\x88\x15\x04\x1f\x1aA\x20Optiona\
    l\x20labels.\x20Suggested\x20labels:\x20\"version\",\x20\"os\",\x20and\
    \x20\"arch\".\n\n\x0f\n\x07\x04=\x03\0\x02\x02\x04\x12\x04\x88\x15\x04\
    \x0c\n\x0f\n\x07\x04=\x03\0\x02\x02\x06\x12\x04\x88\x15\r\x13\n\x0f\n\
    \x07\x04=\x03\0\x02\x02\x01\x12\x04\x88\x15\x14\x1a\n\x0f\n\x07\x04=\x03\
    \0\x02\x02\x03\x12\x04\x88\x15\x1d\x1e\n\x0e\n\x04\x04=\x03\x01\x12\x06\
    \x8b\x15\x02\x9f\x15\x03\n\r\n\x05\x04=\x03\x01\x01\x12\x04\x8b\x15\n\
    \x10\n\xb6\x01\n\x06\x04=\x03\x01\x02\0\x12\x04\x90\x15\x04\x1d\x1a\xa5\
    \x01\x20The\x20name\x20of\x20the\x20image.\x20Expected\x20format:\n\x20\
    \x20\x20[REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG|@TYPE:DIGEST]\n\
    \n\x20See:\x20https://docs.docker.com/reference/commandline/pull/\n\n\
    \x0f\n\x07\x04=\x03\x01\x02\0\x04\x12\x04\x90\x15\x04\x0c\n\x0f\n\x07\
    \x04=\x03\x01\x02\0\x05\x12\x04\x90\x15\r\x13\n\x0f\n\x07\x04=\x03\x01\
    \x02\0\x01\x12\x04\x90\x15\x14\x18\n\x0f\n\x07\x04=\x03\x01\x02\0\x03\
    \x12\x04\x90\x15\x1b\x1c\n\xd1\x02\n\x06\x04=\x03\x01\x02\x01\x12\x04\
    \x99\x15\x04;\x1a\xb2\x02\x20Credential\x20to\x20authenticate\x20with\
    \x20docker\x20registry.\n\x20NOTE:\x20This\x20is\x20not\x20encrypted,\
    \x20therefore\x20framework\x20and\x20operators\n\x20should\x20enable\x20\
    SSL\x20when\x20passing\x20this\x20information.\n\n\x20This\x20field\x20h\
    as\x20never\x20been\x20used\x20in\x20Mesos\x20before\x20and\x20is\n\x20d\
    eprecated\x20since\x20Mesos\x201.3.\x20Please\x20use\x20`config`\x20belo\
    w\n\x20(see\x20MESOS-7088\x20for\x20details).\n\"\x0c\x20Since\x201.3.\n\
    \n\x0f\n\x07\x04=\x03\x01\x02\x01\x04\x12\x04\x99\x15\x04\x0c\n\x0f\n\
    \x07\x04=\x03\x01\x02\x01\x06\x12\x04\x99\x15\r\x17\n\x0f\n\x07\x04=\x03\
    \x01\x02\x01\x01\x12\x04\x99\x15\x18\"\n\x0f\n\x07\x04=\x03\x01\x02\x01\
    \x03\x12\x04\x99\x15%&\n\x0f\n\x07\x04=\x03\x01\x02\x01\x08\x12\x04\x99\
    \x15':\n\x12\n\n\x04=\x03\x01\x02\x01\x08\xe7\x07\0\x12\x04\x99\x15(9\n\
    \x13\n\x0b\x04=\x03\x01\x02\x01\x08\xe7\x07\0\x02\x12\x04\x99\x15(2\n\
    \x14\n\x0c\x04=\x03\x01\x02\x01\x08\xe7\x07\0\x02\0\x12\x04\x99\x15(2\n\
    \x15\n\r\x04=\x03\x01\x02\x01\x08\xe7\x07\0\x02\0\x01\x12\x04\x99\x15(2\
    \n\x13\n\x0b\x04=\x03\x01\x02\x01\x08\xe7\x07\0\x03\x12\x04\x99\x1559\n\
    \xbf\x01\n\x06\x04=\x03\x01\x02\x02\x12\x04\x9e\x15\x04\x1f\x1a\xae\x01\
    \x20Docker\x20config\x20containing\x20credentails\x20to\x20authenticate\
    \x20with\n\x20docker\x20registry.\x20The\x20secret\x20is\x20expected\x20\
    to\x20be\x20a\x20docker\n\x20config\x20file\x20in\x20JSON\x20format\x20w\
    ith\x20UTF-8\x20character\x20encoding.\n\n\x0f\n\x07\x04=\x03\x01\x02\
    \x02\x04\x12\x04\x9e\x15\x04\x0c\n\x0f\n\x07\x04=\x03\x01\x02\x02\x06\
    \x12\x04\x9e\x15\r\x13\n\x0f\n\x07\x04=\x03\x01\x02\x02\x01\x12\x04\x9e\
    \x15\x14\x1a\n\x0f\n\x07\x04=\x03\x01\x02\x02\x03\x12\x04\x9e\x15\x1d\
    \x1e\n\x0c\n\x04\x04=\x02\0\x12\x04\xa1\x15\x02\x19\n\r\n\x05\x04=\x02\0\
    \x04\x12\x04\xa1\x15\x02\n\n\r\n\x05\x04=\x02\0\x06\x12\x04\xa1\x15\x0b\
    \x0f\n\r\n\x05\x04=\x02\0\x01\x12\x04\xa1\x15\x10\x14\n\r\n\x05\x04=\x02\
    \0\x03\x12\x04\xa1\x15\x17\x18\nZ\n\x04\x04=\x02\x01\x12\x04\xa5\x15\x02\
    \x19\x1aL\x20Only\x20one\x20of\x20the\x20following\x20image\x20messages\
    \x20should\x20be\x20set\x20to\x20match\n\x20the\x20type.\n\n\r\n\x05\x04\
    =\x02\x01\x04\x12\x04\xa5\x15\x02\n\n\r\n\x05\x04=\x02\x01\x06\x12\x04\
    \xa5\x15\x0b\x0f\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xa5\x15\x10\x14\n\r\
    \n\x05\x04=\x02\x01\x03\x12\x04\xa5\x15\x17\x18\n\x0c\n\x04\x04=\x02\x02\
    \x12\x04\xa6\x15\x02\x1d\n\r\n\x05\x04=\x02\x02\x04\x12\x04\xa6\x15\x02\
    \n\n\r\n\x05\x04=\x02\x02\x06\x12\x04\xa6\x15\x0b\x11\n\r\n\x05\x04=\x02\
    \x02\x01\x12\x04\xa6\x15\x12\x18\n\r\n\x05\x04=\x02\x02\x03\x12\x04\xa6\
    \x15\x1b\x1c\n\xaf\x01\n\x04\x04=\x02\x03\x12\x04\xab\x15\x02,\x1a\xa0\
    \x01\x20With\x20this\x20flag\x20set\x20to\x20false,\x20the\x20mesos\x20c\
    ontainerizer\x20will\x20pull\n\x20the\x20docker/appc\x20image\x20from\
    \x20the\x20registry\x20even\x20if\x20the\x20image\x20is\n\x20already\x20\
    downloaded\x20on\x20the\x20agent.\n\n\r\n\x05\x04=\x02\x03\x04\x12\x04\
    \xab\x15\x02\n\n\r\n\x05\x04=\x02\x03\x05\x12\x04\xab\x15\x0b\x0f\n\r\n\
    \x05\x04=\x02\x03\x01\x12\x04\xab\x15\x10\x16\n\r\n\x05\x04=\x02\x03\x03\
    \x12\x04\xab\x15\x19\x1a\n\r\n\x05\x04=\x02\x03\x08\x12\x04\xab\x15\x1b+\
    \n\r\n\x05\x04=\x02\x03\x07\x12\x04\xab\x15&*\n\xd4\x01\n\x02\x04>\x12\
    \x06\xb4\x15\0\xc5\x15\x01\x1a\xc5\x01*\n\x20Describes\x20how\x20the\x20\
    mount\x20will\x20be\x20propagated\x20for\x20a\x20volume.\x20See\x20the\n\
    \x20following\x20doc\x20for\x20more\x20details\x20about\x20mount\x20prop\
    agation:\n\x20https://www.kernel.org/doc/Documentation/filesystems/share\
    dsubtree.txt\n\n\x0b\n\x03\x04>\x01\x12\x04\xb4\x15\x08\x18\n\x0e\n\x04\
    \x04>\x04\0\x12\x06\xb5\x15\x02\xc2\x15\x03\n\r\n\x05\x04>\x04\0\x01\x12\
    \x04\xb5\x15\x07\x0b\n\x0e\n\x06\x04>\x04\0\x02\0\x12\x04\xb6\x15\x04\
    \x10\n\x0f\n\x07\x04>\x04\0\x02\0\x01\x12\x04\xb6\x15\x04\x0b\n\x0f\n\
    \x07\x04>\x04\0\x02\0\x02\x12\x04\xb6\x15\x0e\x0f\n\x84\x02\n\x06\x04>\
    \x04\0\x02\x01\x12\x04\xbc\x15\x04\x1a\x1a\xf3\x01\x20The\x20volume\x20i\
    n\x20a\x20container\x20will\x20receive\x20new\x20mounts\x20from\x20the\
    \x20host\n\x20or\x20other\x20containers,\x20but\x20filesystems\x20mounte\
    d\x20inside\x20the\n\x20container\x20won't\x20be\x20propagated\x20to\x20\
    the\x20host\x20or\x20other\x20containers.\n\x20This\x20is\x20currently\
    \x20the\x20default\x20behavior\x20for\x20all\x20volumes.\n\n\x0f\n\x07\
    \x04>\x04\0\x02\x01\x01\x12\x04\xbc\x15\x04\x15\n\x0f\n\x07\x04>\x04\0\
    \x02\x01\x02\x12\x04\xbc\x15\x18\x19\n\xc3\x01\n\x06\x04>\x04\0\x02\x02\
    \x12\x04\xc1\x15\x04\x16\x1a\xb2\x01\x20The\x20volume\x20in\x20a\x20cont\
    ainer\x20will\x20receive\x20new\x20mounts\x20from\x20the\x20host\n\x20or\
    \x20other\x20containers,\x20and\x20its\x20own\x20mounts\x20will\x20be\
    \x20propagated\x20from\n\x20the\x20container\x20to\x20the\x20host\x20or\
    \x20other\x20containers.\n\n\x0f\n\x07\x04>\x04\0\x02\x02\x01\x12\x04\
    \xc1\x15\x04\x11\n\x0f\n\x07\x04>\x04\0\x02\x02\x02\x12\x04\xc1\x15\x14\
    \x15\n\x0c\n\x04\x04>\x02\0\x12\x04\xc4\x15\x02\x19\n\r\n\x05\x04>\x02\0\
    \x04\x12\x04\xc4\x15\x02\n\n\r\n\x05\x04>\x02\0\x06\x12\x04\xc4\x15\x0b\
    \x0f\n\r\n\x05\x04>\x02\0\x01\x12\x04\xc4\x15\x10\x14\n\r\n\x05\x04>\x02\
    \0\x03\x12\x04\xc4\x15\x17\x18\n\x91\x01\n\x02\x04?\x12\x06\xcc\x15\0\
    \xac\x16\x01\x1a\x82\x01*\n\x20Describes\x20a\x20volume\x20mapping\x20ei\
    ther\x20from\x20host\x20to\x20container\x20or\x20vice\n\x20versa.\x20Bot\
    h\x20paths\x20can\x20either\x20refer\x20to\x20a\x20directory\x20or\x20a\
    \x20file.\n\n\x0b\n\x03\x04?\x01\x12\x04\xcc\x15\x08\x0e\n\x0e\n\x04\x04\
    ?\x04\0\x12\x06\xcd\x15\x02\xd0\x15\x03\n\r\n\x05\x04?\x04\0\x01\x12\x04\
    \xcd\x15\x07\x0b\n\x1d\n\x06\x04?\x04\0\x02\0\x12\x04\xce\x15\x04\x0b\"\
    \r\x20read-write.\n\n\x0f\n\x07\x04?\x04\0\x02\0\x01\x12\x04\xce\x15\x04\
    \x06\n\x0f\n\x07\x04?\x04\0\x02\0\x02\x12\x04\xce\x15\t\n\n\x1c\n\x06\
    \x04?\x04\0\x02\x01\x12\x04\xcf\x15\x04\x0b\"\x0c\x20read-only.\n\n\x0f\
    \n\x07\x04?\x04\0\x02\x01\x01\x12\x04\xcf\x15\x04\x06\n\x0f\n\x07\x04?\
    \x04\0\x02\x01\x02\x12\x04\xcf\x15\t\n\nW\n\x04\x04?\x02\0\x12\x04\xd3\
    \x15\x02\x19\x1aI\x20TODO(gyliu513):\x20Make\x20this\x20as\x20`optional`\
    \x20after\x20deprecation\x20cycle\x20of\x201.0.\n\n\r\n\x05\x04?\x02\0\
    \x04\x12\x04\xd3\x15\x02\n\n\r\n\x05\x04?\x02\0\x06\x12\x04\xd3\x15\x0b\
    \x0f\n\r\n\x05\x04?\x02\0\x01\x12\x04\xd3\x15\x10\x14\n\r\n\x05\x04?\x02\
    \0\x03\x12\x04\xd3\x15\x17\x18\n\xd9\x01\n\x04\x04?\x02\x01\x12\x04\xd9\
    \x15\x02%\x1a\xca\x01\x20Path\x20pointing\x20to\x20a\x20directory\x20or\
    \x20file\x20in\x20the\x20container.\x20If\x20the\n\x20path\x20is\x20a\
    \x20relative\x20path,\x20it\x20is\x20relative\x20to\x20the\x20container\
    \x20work\n\x20directory.\x20If\x20the\x20path\x20is\x20an\x20absolute\
    \x20path,\x20that\x20path\x20must\n\x20already\x20exist.\n\n\r\n\x05\x04\
    ?\x02\x01\x04\x12\x04\xd9\x15\x02\n\n\r\n\x05\x04?\x02\x01\x05\x12\x04\
    \xd9\x15\x0b\x11\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xd9\x15\x12\x20\n\r\
    \n\x05\x04?\x02\x01\x03\x12\x04\xd9\x15#$\n\xe1\x01\n\x04\x04?\x02\x02\
    \x12\x04\xe0\x15\x02\x20\x1ap\x20Absolute\x20path\x20pointing\x20to\x20a\
    \x20directory\x20or\x20file\x20on\x20the\x20host\x20or\x20a\n\x20path\
    \x20relative\x20to\x20the\x20container\x20work\x20directory.\n2a\x20The\
    \x20following\x20specifies\x20the\x20source\x20of\x20this\x20volume.\x20\
    At\x20most\x20one\x20of\n\x20the\x20following\x20should\x20be\x20set.\n\
    \n\r\n\x05\x04?\x02\x02\x04\x12\x04\xe0\x15\x02\n\n\r\n\x05\x04?\x02\x02\
    \x05\x12\x04\xe0\x15\x0b\x11\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xe0\x15\
    \x12\x1b\n\r\n\x05\x04?\x02\x02\x03\x12\x04\xe0\x15\x1e\x1f\n{\n\x04\x04\
    ?\x02\x03\x12\x04\xe4\x15\x02\x1b\x1am\x20The\x20source\x20of\x20the\x20\
    volume\x20is\x20an\x20Image\x20which\x20describes\x20a\x20root\n\x20file\
    system\x20which\x20will\x20be\x20provisioned\x20by\x20Mesos.\n\n\r\n\x05\
    \x04?\x02\x03\x04\x12\x04\xe4\x15\x02\n\n\r\n\x05\x04?\x02\x03\x06\x12\
    \x04\xe4\x15\x0b\x10\n\r\n\x05\x04?\x02\x03\x01\x12\x04\xe4\x15\x11\x16\
    \n\r\n\x05\x04?\x02\x03\x03\x12\x04\xe4\x15\x19\x1a\n;\n\x04\x04?\x03\0\
    \x12\x06\xe7\x15\x02\xa9\x16\x03\x1a+\x20Describes\x20where\x20a\x20volu\
    me\x20originates\x20from.\n\n\r\n\x05\x04?\x03\0\x01\x12\x04\xe7\x15\n\
    \x10\n\x10\n\x06\x04?\x03\0\x04\0\x12\x06\xe8\x15\x04\xf4\x15\x05\n\x0f\
    \n\x07\x04?\x03\0\x04\0\x01\x12\x04\xe8\x15\t\r\n\xdf\x01\n\x08\x04?\x03\
    \0\x04\0\x02\0\x12\x04\xed\x15\x06\x12\x1a\xcc\x01\x20This\x20must\x20be\
    \x20the\x20first\x20enum\x20value\x20in\x20this\x20list,\x20to\n\x20ensu\
    re\x20that\x20if\x20'type'\x20is\x20not\x20set,\x20the\x20default\x20val\
    ue\n\x20is\x20UNKNOWN.\x20This\x20enables\x20enum\x20values\x20to\x20be\
    \x20added\n\x20in\x20a\x20backwards-compatible\x20way.\x20See:\x20MESOS-\
    4997.\n\n\x11\n\t\x04?\x03\0\x04\0\x02\0\x01\x12\x04\xed\x15\x06\r\n\x11\
    \n\t\x04?\x03\0\x04\0\x02\0\x02\x12\x04\xed\x15\x10\x11\nD\n\x08\x04?\
    \x03\0\x04\0\x02\x01\x12\x04\xf0\x15\x06\x18\x1a2\x20TODO(gyliu513):\x20\
    Add\x20IMAGE\x20as\x20volume\x20source\x20type.\n\n\x11\n\t\x04?\x03\0\
    \x04\0\x02\x01\x01\x12\x04\xf0\x15\x06\x13\n\x11\n\t\x04?\x03\0\x04\0\
    \x02\x01\x02\x12\x04\xf0\x15\x16\x17\n\x10\n\x08\x04?\x03\0\x04\0\x02\
    \x02\x12\x04\xf1\x15\x06\x14\n\x11\n\t\x04?\x03\0\x04\0\x02\x02\x01\x12\
    \x04\xf1\x15\x06\x0f\n\x11\n\t\x04?\x03\0\x04\0\x02\x02\x02\x12\x04\xf1\
    \x15\x12\x13\n\x10\n\x08\x04?\x03\0\x04\0\x02\x03\x12\x04\xf2\x15\x06\
    \x17\n\x11\n\t\x04?\x03\0\x04\0\x02\x03\x01\x12\x04\xf2\x15\x06\x12\n\
    \x11\n\t\x04?\x03\0\x04\0\x02\x03\x02\x12\x04\xf2\x15\x15\x16\n\x10\n\
    \x08\x04?\x03\0\x04\0\x02\x04\x12\x04\xf3\x15\x06\x11\n\x11\n\t\x04?\x03\
    \0\x04\0\x02\x04\x01\x12\x04\xf3\x15\x06\x0c\n\x11\n\t\x04?\x03\0\x04\0\
    \x02\x04\x02\x12\x04\xf3\x15\x0f\x10\n\x10\n\x06\x04?\x03\0\x03\0\x12\
    \x06\xf6\x15\x04\xff\x15\x05\n\x0f\n\x07\x04?\x03\0\x03\0\x01\x12\x04\
    \xf6\x15\x0c\x18\nP\n\x08\x04?\x03\0\x03\0\x02\0\x12\x04\xf8\x15\x06!\
    \x1a>\x20Driver\x20of\x20the\x20volume,\x20it\x20can\x20be\x20flocker,\
    \x20convoy,\x20raxrey\x20etc.\n\n\x11\n\t\x04?\x03\0\x03\0\x02\0\x04\x12\
    \x04\xf8\x15\x06\x0e\n\x11\n\t\x04?\x03\0\x03\0\x02\0\x05\x12\x04\xf8\
    \x15\x0f\x15\n\x11\n\t\x04?\x03\0\x03\0\x02\0\x01\x12\x04\xf8\x15\x16\
    \x1c\n\x11\n\t\x04?\x03\0\x03\0\x02\0\x03\x12\x04\xf8\x15\x1f\x20\n'\n\
    \x08\x04?\x03\0\x03\0\x02\x01\x12\x04\xfb\x15\x06\x1f\x1a\x15\x20Name\
    \x20of\x20the\x20volume.\n\n\x11\n\t\x04?\x03\0\x03\0\x02\x01\x04\x12\
    \x04\xfb\x15\x06\x0e\n\x11\n\t\x04?\x03\0\x03\0\x02\x01\x05\x12\x04\xfb\
    \x15\x0f\x15\n\x11\n\t\x04?\x03\0\x03\0\x02\x01\x01\x12\x04\xfb\x15\x16\
    \x1a\n\x11\n\t\x04?\x03\0\x03\0\x02\x01\x03\x12\x04\xfb\x15\x1d\x1e\n3\n\
    \x08\x04?\x03\0\x03\0\x02\x02\x12\x04\xfe\x15\x06-\x1a!\x20Volume\x20dri\
    ver\x20specific\x20options.\n\n\x11\n\t\x04?\x03\0\x03\0\x02\x02\x04\x12\
    \x04\xfe\x15\x06\x0e\n\x11\n\t\x04?\x03\0\x03\0\x02\x02\x06\x12\x04\xfe\
    \x15\x0f\x19\n\x11\n\t\x04?\x03\0\x03\0\x02\x02\x01\x12\x04\xfe\x15\x1a(\
    \n\x11\n\t\x04?\x03\0\x03\0\x02\x02\x03\x12\x04\xfe\x15+,\nN\n\x06\x04?\
    \x03\0\x03\x01\x12\x06\x82\x16\x04\x85\x16\x05\x1a<\x20Absolute\x20path\
    \x20pointing\x20to\x20a\x20directory\x20or\x20file\x20on\x20the\x20host.\
    \n\n\x0f\n\x07\x04?\x03\0\x03\x01\x01\x12\x04\x82\x16\x0c\x14\n\x10\n\
    \x08\x04?\x03\0\x03\x01\x02\0\x12\x04\x83\x16\x06\x1f\n\x11\n\t\x04?\x03\
    \0\x03\x01\x02\0\x04\x12\x04\x83\x16\x06\x0e\n\x11\n\t\x04?\x03\0\x03\
    \x01\x02\0\x05\x12\x04\x83\x16\x0f\x15\n\x11\n\t\x04?\x03\0\x03\x01\x02\
    \0\x01\x12\x04\x83\x16\x16\x1a\n\x11\n\t\x04?\x03\0\x03\x01\x02\0\x03\
    \x12\x04\x83\x16\x1d\x1e\n\x10\n\x08\x04?\x03\0\x03\x01\x02\x01\x12\x04\
    \x84\x16\x066\n\x11\n\t\x04?\x03\0\x03\x01\x02\x01\x04\x12\x04\x84\x16\
    \x06\x0e\n\x11\n\t\x04?\x03\0\x03\x01\x02\x01\x06\x12\x04\x84\x16\x0f\
    \x1f\n\x11\n\t\x04?\x03\0\x03\x01\x02\x01\x01\x12\x04\x84\x16\x201\n\x11\
    \n\t\x04?\x03\0\x03\x01\x02\x01\x03\x12\x04\x84\x1645\n\xba\x02\n\x06\
    \x04?\x03\0\x03\x02\x12\x06\x8c\x16\x04\x98\x16\x05\x1a\xa7\x02\x20Descr\
    ibe\x20a\x20path\x20from\x20a\x20container's\x20sandbox.\x20The\x20conta\
    iner\x20can\n\x20be\x20the\x20current\x20container\x20(SELF),\x20or\x20i\
    ts\x20parent\x20container\n\x20(PARENT).\x20PARENT\x20allows\x20all\x20c\
    hild\x20containers\x20to\x20share\x20a\x20volume\n\x20from\x20their\x20p\
    arent\x20container's\x20sandbox.\x20It'll\x20be\x20an\x20error\x20if\n\
    \x20the\x20current\x20container\x20is\x20a\x20top\x20level\x20container.\
    \n\n\x0f\n\x07\x04?\x03\0\x03\x02\x01\x12\x04\x8c\x16\x0c\x17\n\x12\n\
    \x08\x04?\x03\0\x03\x02\x04\0\x12\x06\x8d\x16\x06\x91\x16\x07\n\x11\n\t\
    \x04?\x03\0\x03\x02\x04\0\x01\x12\x04\x8d\x16\x0b\x0f\n\x12\n\n\x04?\x03\
    \0\x03\x02\x04\0\x02\0\x12\x04\x8e\x16\x08\x14\n\x13\n\x0b\x04?\x03\0\
    \x03\x02\x04\0\x02\0\x01\x12\x04\x8e\x16\x08\x0f\n\x13\n\x0b\x04?\x03\0\
    \x03\x02\x04\0\x02\0\x02\x12\x04\x8e\x16\x12\x13\n\x12\n\n\x04?\x03\0\
    \x03\x02\x04\0\x02\x01\x12\x04\x8f\x16\x08\x11\n\x13\n\x0b\x04?\x03\0\
    \x03\x02\x04\0\x02\x01\x01\x12\x04\x8f\x16\x08\x0c\n\x13\n\x0b\x04?\x03\
    \0\x03\x02\x04\0\x02\x01\x02\x12\x04\x8f\x16\x0f\x10\n\x12\n\n\x04?\x03\
    \0\x03\x02\x04\0\x02\x02\x12\x04\x90\x16\x08\x13\n\x13\n\x0b\x04?\x03\0\
    \x03\x02\x04\0\x02\x02\x01\x12\x04\x90\x16\x08\x0e\n\x13\n\x0b\x04?\x03\
    \0\x03\x02\x04\0\x02\x02\x02\x12\x04\x90\x16\x11\x12\n\x10\n\x08\x04?\
    \x03\0\x03\x02\x02\0\x12\x04\x93\x16\x06\x1d\n\x11\n\t\x04?\x03\0\x03\
    \x02\x02\0\x04\x12\x04\x93\x16\x06\x0e\n\x11\n\t\x04?\x03\0\x03\x02\x02\
    \0\x06\x12\x04\x93\x16\x0f\x13\n\x11\n\t\x04?\x03\0\x03\x02\x02\0\x01\
    \x12\x04\x93\x16\x14\x18\n\x11\n\t\x04?\x03\0\x03\x02\x02\0\x03\x12\x04\
    \x93\x16\x1b\x1c\n\x8b\x01\n\x08\x04?\x03\0\x03\x02\x02\x01\x12\x04\x97\
    \x16\x06\x1f\x1ay\x20A\x20path\x20relative\x20to\x20the\x20corresponding\
    \x20container's\x20sandbox.\n\x20Note\x20that\x20upwards\x20traversal\
    \x20(i.e.\x20../../abc)\x20is\x20not\x20allowed.\n\n\x11\n\t\x04?\x03\0\
    \x03\x02\x02\x01\x04\x12\x04\x97\x16\x06\x0e\n\x11\n\t\x04?\x03\0\x03\
    \x02\x02\x01\x05\x12\x04\x97\x16\x0f\x15\n\x11\n\t\x04?\x03\0\x03\x02\
    \x02\x01\x01\x12\x04\x97\x16\x16\x1a\n\x11\n\t\x04?\x03\0\x03\x02\x02\
    \x01\x03\x12\x04\x97\x16\x1d\x1e\nB\n\x06\x04?\x03\0\x02\0\x12\x04\x9b\
    \x16\x04\x1b\x1a2\x20Enum\x20fields\x20should\x20be\x20optional,\x20see:\
    \x20MESOS-4997.\n\n\x0f\n\x07\x04?\x03\0\x02\0\x04\x12\x04\x9b\x16\x04\
    \x0c\n\x0f\n\x07\x04?\x03\0\x02\0\x06\x12\x04\x9b\x16\r\x11\n\x0f\n\x07\
    \x04?\x03\0\x02\0\x01\x12\x04\x9b\x16\x12\x16\n\x0f\n\x07\x04?\x03\0\x02\
    \0\x03\x12\x04\x9b\x16\x19\x1a\n\xae\x01\n\x06\x04?\x03\0\x02\x01\x12\
    \x04\xa1\x16\x04,\x1a;\x20The\x20source\x20of\x20the\x20volume\x20create\
    d\x20by\x20docker\x20volume\x20driver.\n2a\x20The\x20following\x20specif\
    ies\x20the\x20source\x20of\x20this\x20volume.\x20At\x20most\x20one\x20of\
    \n\x20the\x20following\x20should\x20be\x20set.\n\n\x0f\n\x07\x04?\x03\0\
    \x02\x01\x04\x12\x04\xa1\x16\x04\x0c\n\x0f\n\x07\x04?\x03\0\x02\x01\x06\
    \x12\x04\xa1\x16\r\x19\n\x0f\n\x07\x04?\x03\0\x02\x01\x01\x12\x04\xa1\
    \x16\x1a'\n\x0f\n\x07\x04?\x03\0\x02\x01\x03\x12\x04\xa1\x16*+\n\x0e\n\
    \x06\x04?\x03\0\x02\x02\x12\x04\xa3\x16\x04$\n\x0f\n\x07\x04?\x03\0\x02\
    \x02\x04\x12\x04\xa3\x16\x04\x0c\n\x0f\n\x07\x04?\x03\0\x02\x02\x06\x12\
    \x04\xa3\x16\r\x15\n\x0f\n\x07\x04?\x03\0\x02\x02\x01\x12\x04\xa3\x16\
    \x16\x1f\n\x0f\n\x07\x04?\x03\0\x02\x02\x03\x12\x04\xa3\x16\"#\n\x0e\n\
    \x06\x04?\x03\0\x02\x03\x12\x04\xa4\x16\x04*\n\x0f\n\x07\x04?\x03\0\x02\
    \x03\x04\x12\x04\xa4\x16\x04\x0c\n\x0f\n\x07\x04?\x03\0\x02\x03\x06\x12\
    \x04\xa4\x16\r\x18\n\x0f\n\x07\x04?\x03\0\x02\x03\x01\x12\x04\xa4\x16\
    \x19%\n\x0f\n\x07\x04?\x03\0\x02\x03\x03\x12\x04\xa4\x16()\n\xa6\x01\n\
    \x06\x04?\x03\0\x02\x04\x12\x04\xa8\x16\x04\x1f\x1a\x95\x01\x20The\x20vo\
    lume/secret\x20isolator\x20uses\x20the\x20secret-fetcher\x20module\x20(t\
    hird-party\x20or\n\x20internal)\x20downloads\x20the\x20secret\x20and\x20\
    makes\x20it\x20available\x20at\x20container_path.\n\n\x0f\n\x07\x04?\x03\
    \0\x02\x04\x04\x12\x04\xa8\x16\x04\x0c\n\x0f\n\x07\x04?\x03\0\x02\x04\
    \x06\x12\x04\xa8\x16\r\x13\n\x0f\n\x07\x04?\x03\0\x02\x04\x01\x12\x04\
    \xa8\x16\x14\x1a\n\x0f\n\x07\x04?\x03\0\x02\x04\x03\x12\x04\xa8\x16\x1d\
    \x1e\n\x0c\n\x04\x04?\x02\x04\x12\x04\xab\x16\x02\x1d\n\r\n\x05\x04?\x02\
    \x04\x04\x12\x04\xab\x16\x02\n\n\r\n\x05\x04?\x02\x04\x06\x12\x04\xab\
    \x16\x0b\x11\n\r\n\x05\x04?\x02\x04\x01\x12\x04\xab\x16\x12\x18\n\r\n\
    \x05\x04?\x02\x04\x03\x12\x04\xab\x16\x1b\x1c\n\xb0\x07\n\x02\x04@\x12\
    \x06\xc3\x16\0\x82\x17\x01\x1a\xa1\x07*\n\x20Describes\x20a\x20network\
    \x20request\x20from\x20a\x20framework\x20as\x20well\x20as\x20network\x20\
    resolution\n\x20provided\x20by\x20Mesos.\n\n\x20A\x20framework\x20may\
    \x20request\x20the\x20network\x20isolator\x20on\x20the\x20Agent\x20to\
    \x20isolate\x20the\n\x20container\x20in\x20a\x20network\x20namespace\x20\
    and\x20create\x20a\x20virtual\x20network\x20interface.\n\x20The\x20`Netw\
    orkInfo`\x20message\x20describes\x20the\x20properties\x20of\x20that\x20v\
    irtual\n\x20interface,\x20including\x20the\x20IP\x20addresses\x20and\x20\
    network\x20isolation\x20policy\n\x20(network\x20group\x20membership).\n\
    \n\x20The\x20NetworkInfo\x20message\x20is\x20not\x20interpreted\x20by\
    \x20the\x20Master\x20or\x20Agent\x20and\x20is\n\x20intended\x20to\x20be\
    \x20used\x20by\x20Agent\x20and\x20Master\x20modules\x20implementing\x20n\
    etwork\n\x20isolation.\x20If\x20the\x20modules\x20are\x20missing,\x20the\
    \x20message\x20is\x20simply\x20ignored.\x20In\n\x20future,\x20the\x20tas\
    k\x20launch\x20will\x20fail\x20if\x20there\x20is\x20no\x20module\x20prov\
    iding\x20the\n\x20network\x20isolation\x20capabilities\x20(MESOS-3390).\
    \n\n\x20An\x20executor,\x20Agent,\x20or\x20an\x20Agent\x20module\x20may\
    \x20append\x20NetworkInfos\x20inside\n\x20TaskStatus::container_status\
    \x20to\x20provide\x20information\x20such\x20as\x20the\x20container\x20IP\
    \n\x20address\x20and\x20isolation\x20groups.\n\n\x0b\n\x03\x04@\x01\x12\
    \x04\xc3\x16\x08\x13\n\x0e\n\x04\x04@\x04\0\x12\x06\xc4\x16\x02\xc7\x16\
    \x03\n\r\n\x05\x04@\x04\0\x01\x12\x04\xc4\x16\x07\x0f\n\x0e\n\x06\x04@\
    \x04\0\x02\0\x12\x04\xc5\x16\x04\r\n\x0f\n\x07\x04@\x04\0\x02\0\x01\x12\
    \x04\xc5\x16\x04\x08\n\x0f\n\x07\x04@\x04\0\x02\0\x02\x12\x04\xc5\x16\
    \x0b\x0c\n\x0e\n\x06\x04@\x04\0\x02\x01\x12\x04\xc6\x16\x04\r\n\x0f\n\
    \x07\x04@\x04\0\x02\x01\x01\x12\x04\xc6\x16\x04\x08\n\x0f\n\x07\x04@\x04\
    \0\x02\x01\x02\x12\x04\xc6\x16\x0b\x0c\n\xf9\x02\n\x04\x04@\x03\0\x12\
    \x06\xd0\x16\x02\xde\x16\x03\x1a\xe8\x02\x20Specifies\x20a\x20request\
    \x20for\x20an\x20IP\x20address,\x20or\x20reports\x20the\x20assigned\x20c\
    ontainer\n\x20IP\x20address.\n\n\x20Users\x20can\x20request\x20an\x20aut\
    omatically\x20assigned\x20IP\x20(for\x20example,\x20via\x20an\n\x20IPAM\
    \x20service)\x20or\x20a\x20specific\x20IP\x20by\x20adding\x20a\x20Networ\
    kInfo\x20to\x20the\n\x20ContainerInfo\x20for\x20a\x20task.\x20\x20On\x20\
    a\x20request,\x20specifying\x20neither\x20`protocol`\n\x20nor\x20`ip_add\
    ress`\x20means\x20that\x20any\x20available\x20address\x20may\x20be\x20as\
    signed.\n\n\r\n\x05\x04@\x03\0\x01\x12\x04\xd0\x16\n\x13\n\x90\x02\n\x06\
    \x04@\x03\0\x02\0\x12\x04\xd5\x16\x044\x1a\xff\x01\x20Specify\x20IP\x20a\
    ddress\x20requirement.\x20Set\x20protocol\x20to\x20the\x20desired\x20val\
    ue\x20to\n\x20request\x20the\x20network\x20isolator\x20on\x20the\x20Agen\
    t\x20to\x20assign\x20an\x20IP\x20address\x20to\x20the\n\x20container\x20\
    being\x20launched.\x20If\x20a\x20specific\x20IP\x20address\x20is\x20spec\
    ified\x20in\n\x20ip_address,\x20this\x20field\x20should\x20not\x20be\x20\
    set.\n\n\x0f\n\x07\x04@\x03\0\x02\0\x04\x12\x04\xd5\x16\x04\x0c\n\x0f\n\
    \x07\x04@\x03\0\x02\0\x06\x12\x04\xd5\x16\r\x15\n\x0f\n\x07\x04@\x03\0\
    \x02\0\x01\x12\x04\xd5\x16\x16\x1e\n\x0f\n\x07\x04@\x03\0\x02\0\x03\x12\
    \x04\xd5\x16!\"\n\x0f\n\x07\x04@\x03\0\x02\0\x08\x12\x04\xd5\x16#3\n\x0f\
    \n\x07\x04@\x03\0\x02\0\x07\x12\x04\xd5\x16.2\n\xc0\x02\n\x06\x04@\x03\0\
    \x02\x01\x12\x04\xdd\x16\x04#\x1a\xaf\x02\x20Statically\x20assigned\x20I\
    P\x20provided\x20by\x20the\x20Framework.\x20This\x20IP\x20will\x20be\n\
    \x20assigned\x20to\x20the\x20container\x20by\x20the\x20network\x20isolat\
    or\x20module\x20on\x20the\x20Agent.\n\x20This\x20field\x20should\x20not\
    \x20be\x20used\x20with\x20the\x20protocol\x20field\x20above.\n\n\x20If\
    \x20an\x20explicit\x20address\x20is\x20requested\x20but\x20is\x20unavail\
    able,\x20the\x20network\n\x20isolator\x20should\x20fail\x20the\x20task.\
    \n\n\x0f\n\x07\x04@\x03\0\x02\x01\x04\x12\x04\xdd\x16\x04\x0c\n\x0f\n\
    \x07\x04@\x03\0\x02\x01\x05\x12\x04\xdd\x16\r\x13\n\x0f\n\x07\x04@\x03\0\
    \x02\x01\x01\x12\x04\xdd\x16\x14\x1e\n\x0f\n\x07\x04@\x03\0\x02\x01\x03\
    \x12\x04\xdd\x16!\"\n\xc2\x03\n\x04\x04@\x02\0\x12\x04\xe8\x16\x02&\x1a\
    \xb3\x03\x20When\x20included\x20in\x20a\x20ContainerInfo,\x20each\x20of\
    \x20these\x20represent\x20a\n\x20request\x20for\x20an\x20IP\x20address.\
    \x20Each\x20request\x20can\x20specify\x20an\x20explicit\x20address\n\x20\
    or\x20the\x20IP\x20protocol\x20to\x20use.\n\n\x20When\x20included\x20in\
    \x20a\x20TaskStatus\x20message,\x20these\x20inform\x20the\x20framework\n\
    \x20scheduler\x20about\x20the\x20IP\x20addresses\x20that\x20are\x20bound\
    \x20to\x20the\x20container\n\x20interface.\x20When\x20there\x20are\x20no\
    \x20custom\x20network\x20isolator\x20modules\x20installed,\n\x20this\x20\
    field\x20is\x20filled\x20in\x20automatically\x20with\x20the\x20Agent\x20\
    IP\x20address.\n\n\r\n\x05\x04@\x02\0\x04\x12\x04\xe8\x16\x02\n\n\r\n\
    \x05\x04@\x02\0\x06\x12\x04\xe8\x16\x0b\x14\n\r\n\x05\x04@\x02\0\x01\x12\
    \x04\xe8\x16\x15!\n\r\n\x05\x04@\x02\0\x03\x12\x04\xe8\x16$%\n\xc7\x01\n\
    \x04\x04@\x02\x01\x12\x04\xed\x16\x02\x1b\x1a\xb8\x01\x20Name\x20of\x20t\
    he\x20network\x20which\x20will\x20be\x20used\x20by\x20network\x20isolato\
    r\x20to\x20determine\n\x20the\x20network\x20that\x20the\x20container\x20\
    joins.\x20It's\x20up\x20to\x20the\x20network\x20isolator\n\x20to\x20deci\
    de\x20how\x20to\x20interpret\x20this\x20field.\n\n\r\n\x05\x04@\x02\x01\
    \x04\x12\x04\xed\x16\x02\n\n\r\n\x05\x04@\x02\x01\x05\x12\x04\xed\x16\
    \x0b\x11\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xed\x16\x12\x16\n\r\n\x05\
    \x04@\x02\x01\x03\x12\x04\xed\x16\x19\x1a\n\xe3\x02\n\x04\x04@\x02\x02\
    \x12\x04\xf4\x16\x02\x1d\x1a\xd4\x02\x20A\x20group\x20is\x20the\x20name\
    \x20given\x20to\x20a\x20set\x20of\x20logically-related\x20interfaces\x20\
    that\n\x20are\x20allowed\x20to\x20communicate\x20among\x20themselves.\
    \x20Network\x20traffic\x20is\x20allowed\n\x20between\x20two\x20container\
    \x20interfaces\x20that\x20share\x20at\x20least\x20one\x20network\x20grou\
    p.\n\x20For\x20example,\x20one\x20might\x20want\x20to\x20create\x20separ\
    ate\x20groups\x20for\x20isolating\x20dev,\n\x20testing,\x20qa\x20and\x20\
    prod\x20deployment\x20environments.\n\n\r\n\x05\x04@\x02\x02\x04\x12\x04\
    \xf4\x16\x02\n\n\r\n\x05\x04@\x02\x02\x05\x12\x04\xf4\x16\x0b\x11\n\r\n\
    \x05\x04@\x02\x02\x01\x12\x04\xf4\x16\x12\x18\n\r\n\x05\x04@\x02\x02\x03\
    \x12\x04\xf4\x16\x1b\x1c\nU\n\x04\x04@\x02\x03\x12\x04\xf7\x16\x02\x1d\
    \x1aG\x20To\x20tag\x20certain\x20metadata\x20to\x20be\x20used\x20by\x20I\
    solator/IPAM,\x20e.g.,\x20rack,\x20etc.\n\n\r\n\x05\x04@\x02\x03\x04\x12\
    \x04\xf7\x16\x02\n\n\r\n\x05\x04@\x02\x03\x06\x12\x04\xf7\x16\x0b\x11\n\
    \r\n\x05\x04@\x02\x03\x01\x12\x04\xf7\x16\x12\x18\n\r\n\x05\x04@\x02\x03\
    \x03\x12\x04\xf7\x16\x1b\x1c\nP\n\x04\x04@\x03\x01\x12\x06\xfa\x16\x02\
    \xff\x16\x03\x1a@\x20Specifies\x20a\x20port\x20mapping\x20request\x20for\
    \x20the\x20task\x20on\x20this\x20network.\n\n\r\n\x05\x04@\x03\x01\x01\
    \x12\x04\xfa\x16\n\x15\n\x0e\n\x06\x04@\x03\x01\x02\0\x12\x04\xfb\x16\
    \x04\"\n\x0f\n\x07\x04@\x03\x01\x02\0\x04\x12\x04\xfb\x16\x04\x0c\n\x0f\
    \n\x07\x04@\x03\x01\x02\0\x05\x12\x04\xfb\x16\r\x13\n\x0f\n\x07\x04@\x03\
    \x01\x02\0\x01\x12\x04\xfb\x16\x14\x1d\n\x0f\n\x07\x04@\x03\x01\x02\0\
    \x03\x12\x04\xfb\x16\x20!\n\x0e\n\x06\x04@\x03\x01\x02\x01\x12\x04\xfc\
    \x16\x04'\n\x0f\n\x07\x04@\x03\x01\x02\x01\x04\x12\x04\xfc\x16\x04\x0c\n\
    \x0f\n\x07\x04@\x03\x01\x02\x01\x05\x12\x04\xfc\x16\r\x13\n\x0f\n\x07\
    \x04@\x03\x01\x02\x01\x01\x12\x04\xfc\x16\x14\"\n\x0f\n\x07\x04@\x03\x01\
    \x02\x01\x03\x12\x04\xfc\x16%&\n7\n\x06\x04@\x03\x01\x02\x02\x12\x04\xfe\
    \x16\x04!\x1a'\x20Protocol\x20to\x20expose\x20as\x20(ie:\x20tcp,\x20udp)\
    .\n\n\x0f\n\x07\x04@\x03\x01\x02\x02\x04\x12\x04\xfe\x16\x04\x0c\n\x0f\n\
    \x07\x04@\x03\x01\x02\x02\x05\x12\x04\xfe\x16\r\x13\n\x0f\n\x07\x04@\x03\
    \x01\x02\x02\x01\x12\x04\xfe\x16\x14\x1c\n\x0f\n\x07\x04@\x03\x01\x02\
    \x02\x03\x12\x04\xfe\x16\x1f\x20\n\x0c\n\x04\x04@\x02\x04\x12\x04\x81\
    \x17\x02)\n\r\n\x05\x04@\x02\x04\x04\x12\x04\x81\x17\x02\n\n\r\n\x05\x04\
    @\x02\x04\x06\x12\x04\x81\x17\x0b\x16\n\r\n\x05\x04@\x02\x04\x01\x12\x04\
    \x81\x17\x17$\n\r\n\x05\x04@\x02\x04\x03\x12\x04\x81\x17'(\nz\n\x02\x04A\
    \x12\x06\x89\x17\0\xba\x17\x01\x1al*\n\x20Encapsulation\x20of\x20`Capabi\
    lities`\x20supported\x20by\x20Linux.\n\x20Reference:\x20http://linux.die\
    .net/man/7/capabilities.\n\n\x0b\n\x03\x04A\x01\x12\x04\x89\x17\x08\x16\
    \n\x9c\x02\n\x04\x04A\x04\0\x12\x06\x8f\x17\x02\xb7\x17\x03\x1a\x8b\x02\
    \x20We\x20start\x20the\x20actual\x20values\x20at\x20an\x20offset(1000)\
    \x20because\x20Protobuf\x202\n\x20uses\x20the\x20first\x20value\x20as\
    \x20the\x20default\x20one.\x20Separating\x20the\x20default\n\x20value\
    \x20from\x20the\x20real\x20first\x20value\x20helps\x20to\x20disambiguate\
    \x20them.\x20This\n\x20is\x20especially\x20valuable\x20for\x20backward\
    \x20compatibility.\n\x20See:\x20MESOS-4997.\n\n\r\n\x05\x04A\x04\0\x01\
    \x12\x04\x8f\x17\x07\x11\n\x0e\n\x06\x04A\x04\0\x02\0\x12\x04\x90\x17\
    \x04\x10\n\x0f\n\x07\x04A\x04\0\x02\0\x01\x12\x04\x90\x17\x04\x0b\n\x0f\
    \n\x07\x04A\x04\0\x02\0\x02\x12\x04\x90\x17\x0e\x0f\n\x0e\n\x06\x04A\x04\
    \0\x02\x01\x12\x04\x91\x17\x04\x11\n\x0f\n\x07\x04A\x04\0\x02\x01\x01\
    \x12\x04\x91\x17\x04\t\n\x0f\n\x07\x04A\x04\0\x02\x01\x02\x12\x04\x91\
    \x17\x0c\x10\n\x0e\n\x06\x04A\x04\0\x02\x02\x12\x04\x92\x17\x04\x18\n\
    \x0f\n\x07\x04A\x04\0\x02\x02\x01\x12\x04\x92\x17\x04\x10\n\x0f\n\x07\
    \x04A\x04\0\x02\x02\x02\x12\x04\x92\x17\x13\x17\n\x0e\n\x06\x04A\x04\0\
    \x02\x03\x12\x04\x93\x17\x04\x1b\n\x0f\n\x07\x04A\x04\0\x02\x03\x01\x12\
    \x04\x93\x17\x04\x13\n\x0f\n\x07\x04A\x04\0\x02\x03\x02\x12\x04\x93\x17\
    \x16\x1a\n\x0e\n\x06\x04A\x04\0\x02\x04\x12\x04\x94\x17\x04\x12\n\x0f\n\
    \x07\x04A\x04\0\x02\x04\x01\x12\x04\x94\x17\x04\n\n\x0f\n\x07\x04A\x04\0\
    \x02\x04\x02\x12\x04\x94\x17\r\x11\n\x0e\n\x06\x04A\x04\0\x02\x05\x12\
    \x04\x95\x17\x04\x12\n\x0f\n\x07\x04A\x04\0\x02\x05\x01\x12\x04\x95\x17\
    \x04\n\n\x0f\n\x07\x04A\x04\0\x02\x05\x02\x12\x04\x95\x17\r\x11\n\x0e\n\
    \x06\x04A\x04\0\x02\x06\x12\x04\x96\x17\x04\x10\n\x0f\n\x07\x04A\x04\0\
    \x02\x06\x01\x12\x04\x96\x17\x04\x08\n\x0f\n\x07\x04A\x04\0\x02\x06\x02\
    \x12\x04\x96\x17\x0b\x0f\n\x0e\n\x06\x04A\x04\0\x02\x07\x12\x04\x97\x17\
    \x04\x12\n\x0f\n\x07\x04A\x04\0\x02\x07\x01\x12\x04\x97\x17\x04\n\n\x0f\
    \n\x07\x04A\x04\0\x02\x07\x02\x12\x04\x97\x17\r\x11\n\x0e\n\x06\x04A\x04\
    \0\x02\x08\x12\x04\x98\x17\x04\x12\n\x0f\n\x07\x04A\x04\0\x02\x08\x01\
    \x12\x04\x98\x17\x04\n\n\x0f\n\x07\x04A\x04\0\x02\x08\x02\x12\x04\x98\
    \x17\r\x11\n\x0e\n\x06\x04A\x04\0\x02\t\x12\x04\x99\x17\x04\x13\n\x0f\n\
    \x07\x04A\x04\0\x02\t\x01\x12\x04\x99\x17\x04\x0b\n\x0f\n\x07\x04A\x04\0\
    \x02\t\x02\x12\x04\x99\x17\x0e\x12\n\x0e\n\x06\x04A\x04\0\x02\n\x12\x04\
    \x9a\x17\x04\x1b\n\x0f\n\x07\x04A\x04\0\x02\n\x01\x12\x04\x9a\x17\x04\
    \x13\n\x0f\n\x07\x04A\x04\0\x02\n\x02\x12\x04\x9a\x17\x16\x1a\n\x0e\n\
    \x06\x04A\x04\0\x02\x0b\x12\x04\x9b\x17\x04\x1c\n\x0f\n\x07\x04A\x04\0\
    \x02\x0b\x01\x12\x04\x9b\x17\x04\x14\n\x0f\n\x07\x04A\x04\0\x02\x0b\x02\
    \x12\x04\x9b\x17\x17\x1b\n\x0e\n\x06\x04A\x04\0\x02\x0c\x12\x04\x9c\x17\
    \x04\x19\n\x0f\n\x07\x04A\x04\0\x02\x0c\x01\x12\x04\x9c\x17\x04\x11\n\
    \x0f\n\x07\x04A\x04\0\x02\x0c\x02\x12\x04\x9c\x17\x14\x18\n\x0e\n\x06\
    \x04A\x04\0\x02\r\x12\x04\x9d\x17\x04\x15\n\x0f\n\x07\x04A\x04\0\x02\r\
    \x01\x12\x04\x9d\x17\x04\r\n\x0f\n\x07\x04A\x04\0\x02\r\x02\x12\x04\x9d\
    \x17\x10\x14\n\x0e\n\x06\x04A\x04\0\x02\x0e\x12\x04\x9e\x17\x04\x13\n\
    \x0f\n\x07\x04A\x04\0\x02\x0e\x01\x12\x04\x9e\x17\x04\x0b\n\x0f\n\x07\
    \x04A\x04\0\x02\x0e\x02\x12\x04\x9e\x17\x0e\x12\n\x0e\n\x06\x04A\x04\0\
    \x02\x0f\x12\x04\x9f\x17\x04\x14\n\x0f\n\x07\x04A\x04\0\x02\x0f\x01\x12\
    \x04\x9f\x17\x04\x0c\n\x0f\n\x07\x04A\x04\0\x02\x0f\x02\x12\x04\x9f\x17\
    \x0f\x13\n\x0e\n\x06\x04A\x04\0\x02\x10\x12\x04\xa0\x17\x04\x15\n\x0f\n\
    \x07\x04A\x04\0\x02\x10\x01\x12\x04\xa0\x17\x04\r\n\x0f\n\x07\x04A\x04\0\
    \x02\x10\x02\x12\x04\xa0\x17\x10\x14\n\x0e\n\x06\x04A\x04\0\x02\x11\x12\
    \x04\xa1\x17\x04\x16\n\x0f\n\x07\x04A\x04\0\x02\x11\x01\x12\x04\xa1\x17\
    \x04\x0e\n\x0f\n\x07\x04A\x04\0\x02\x11\x02\x12\x04\xa1\x17\x11\x15\n\
    \x0e\n\x06\x04A\x04\0\x02\x12\x12\x04\xa2\x17\x04\x15\n\x0f\n\x07\x04A\
    \x04\0\x02\x12\x01\x12\x04\xa2\x17\x04\r\n\x0f\n\x07\x04A\x04\0\x02\x12\
    \x02\x12\x04\xa2\x17\x10\x14\n\x0e\n\x06\x04A\x04\0\x02\x13\x12\x04\xa3\
    \x17\x04\x16\n\x0f\n\x07\x04A\x04\0\x02\x13\x01\x12\x04\xa3\x17\x04\x0e\
    \n\x0f\n\x07\x04A\x04\0\x02\x13\x02\x12\x04\xa3\x17\x11\x15\n\x0e\n\x06\
    \x04A\x04\0\x02\x14\x12\x04\xa4\x17\x04\x16\n\x0f\n\x07\x04A\x04\0\x02\
    \x14\x01\x12\x04\xa4\x17\x04\x0e\n\x0f\n\x07\x04A\x04\0\x02\x14\x02\x12\
    \x04\xa4\x17\x11\x15\n\x0e\n\x06\x04A\x04\0\x02\x15\x12\x04\xa5\x17\x04\
    \x15\n\x0f\n\x07\x04A\x04\0\x02\x15\x01\x12\x04\xa5\x17\x04\r\n\x0f\n\
    \x07\x04A\x04\0\x02\x15\x02\x12\x04\xa5\x17\x10\x14\n\x0e\n\x06\x04A\x04\
    \0\x02\x16\x12\x04\xa6\x17\x04\x15\n\x0f\n\x07\x04A\x04\0\x02\x16\x01\
    \x12\x04\xa6\x17\x04\r\n\x0f\n\x07\x04A\x04\0\x02\x16\x02\x12\x04\xa6\
    \x17\x10\x14\n\x0e\n\x06\x04A\x04\0\x02\x17\x12\x04\xa7\x17\x04\x14\n\
    \x0f\n\x07\x04A\x04\0\x02\x17\x01\x12\x04\xa7\x17\x04\x0c\n\x0f\n\x07\
    \x04A\x04\0\x02\x17\x02\x12\x04\xa7\x17\x0f\x13\n\x0e\n\x06\x04A\x04\0\
    \x02\x18\x12\x04\xa8\x17\x04\x14\n\x0f\n\x07\x04A\x04\0\x02\x18\x01\x12\
    \x04\xa8\x17\x04\x0c\n\x0f\n\x07\x04A\x04\0\x02\x18\x02\x12\x04\xa8\x17\
    \x0f\x13\n\x0e\n\x06\x04A\x04\0\x02\x19\x12\x04\xa9\x17\x04\x18\n\x0f\n\
    \x07\x04A\x04\0\x02\x19\x01\x12\x04\xa9\x17\x04\x10\n\x0f\n\x07\x04A\x04\
    \0\x02\x19\x02\x12\x04\xa9\x17\x13\x17\n\x0e\n\x06\x04A\x04\0\x02\x1a\
    \x12\x04\xaa\x17\x04\x14\n\x0f\n\x07\x04A\x04\0\x02\x1a\x01\x12\x04\xaa\
    \x17\x04\x0c\n\x0f\n\x07\x04A\x04\0\x02\x1a\x02\x12\x04\xaa\x17\x0f\x13\
    \n\x0e\n\x06\x04A\x04\0\x02\x1b\x12\x04\xab\x17\x04\x1a\n\x0f\n\x07\x04A\
    \x04\0\x02\x1b\x01\x12\x04\xab\x17\x04\x12\n\x0f\n\x07\x04A\x04\0\x02\
    \x1b\x02\x12\x04\xab\x17\x15\x19\n\x0e\n\x06\x04A\x04\0\x02\x1c\x12\x04\
    \xac\x17\x04\x11\n\x0f\n\x07\x04A\x04\0\x02\x1c\x01\x12\x04\xac\x17\x04\
    \t\n\x0f\n\x07\x04A\x04\0\x02\x1c\x02\x12\x04\xac\x17\x0c\x10\n\x0e\n\
    \x06\x04A\x04\0\x02\x1d\x12\x04\xad\x17\x04\x11\n\x0f\n\x07\x04A\x04\0\
    \x02\x1d\x01\x12\x04\xad\x17\x04\t\n\x0f\n\x07\x04A\x04\0\x02\x1d\x02\
    \x12\x04\xad\x17\x0c\x10\n\x0e\n\x06\x04A\x04\0\x02\x1e\x12\x04\xae\x17\
    \x04\x17\n\x0f\n\x07\x04A\x04\0\x02\x1e\x01\x12\x04\xae\x17\x04\x0f\n\
    \x0f\n\x07\x04A\x04\0\x02\x1e\x02\x12\x04\xae\x17\x12\x16\n\x0e\n\x06\
    \x04A\x04\0\x02\x1f\x12\x04\xaf\x17\x04\x19\n\x0f\n\x07\x04A\x04\0\x02\
    \x1f\x01\x12\x04\xaf\x17\x04\x11\n\x0f\n\x07\x04A\x04\0\x02\x1f\x02\x12\
    \x04\xaf\x17\x14\x18\n\x0e\n\x06\x04A\x04\0\x02\x20\x12\x04\xb0\x17\x04\
    \x13\n\x0f\n\x07\x04A\x04\0\x02\x20\x01\x12\x04\xb0\x17\x04\x0b\n\x0f\n\
    \x07\x04A\x04\0\x02\x20\x02\x12\x04\xb0\x17\x0e\x12\n\x0e\n\x06\x04A\x04\
    \0\x02!\x12\x04\xb1\x17\x04\x18\n\x0f\n\x07\x04A\x04\0\x02!\x01\x12\x04\
    \xb1\x17\x04\x10\n\x0f\n\x07\x04A\x04\0\x02!\x02\x12\x04\xb1\x17\x13\x17\
    \n\x0e\n\x06\x04A\x04\0\x02\"\x12\x04\xb2\x17\x04\x15\n\x0f\n\x07\x04A\
    \x04\0\x02\"\x01\x12\x04\xb2\x17\x04\r\n\x0f\n\x07\x04A\x04\0\x02\"\x02\
    \x12\x04\xb2\x17\x10\x14\n\x0e\n\x06\x04A\x04\0\x02#\x12\x04\xb3\x17\x04\
    \x12\n\x0f\n\x07\x04A\x04\0\x02#\x01\x12\x04\xb3\x17\x04\n\n\x0f\n\x07\
    \x04A\x04\0\x02#\x02\x12\x04\xb3\x17\r\x11\n\x0e\n\x06\x04A\x04\0\x02$\
    \x12\x04\xb4\x17\x04\x16\n\x0f\n\x07\x04A\x04\0\x02$\x01\x12\x04\xb4\x17\
    \x04\x0e\n\x0f\n\x07\x04A\x04\0\x02$\x02\x12\x04\xb4\x17\x11\x15\n\x0e\n\
    \x06\x04A\x04\0\x02%\x12\x04\xb5\x17\x04\x19\n\x0f\n\x07\x04A\x04\0\x02%\
    \x01\x12\x04\xb5\x17\x04\x11\n\x0f\n\x07\x04A\x04\0\x02%\x02\x12\x04\xb5\
    \x17\x14\x18\n\x0e\n\x06\x04A\x04\0\x02&\x12\x04\xb6\x17\x04\x16\n\x0f\n\
    \x07\x04A\x04\0\x02&\x01\x12\x04\xb6\x17\x04\x0e\n\x0f\n\x07\x04A\x04\0\
    \x02&\x02\x12\x04\xb6\x17\x11\x15\n\x0c\n\x04\x04A\x02\0\x12\x04\xb9\x17\
    \x02'\n\r\n\x05\x04A\x02\0\x04\x12\x04\xb9\x17\x02\n\n\r\n\x05\x04A\x02\
    \0\x06\x12\x04\xb9\x17\x0b\x15\n\r\n\x05\x04A\x02\0\x01\x12\x04\xb9\x17\
    \x16\"\n\r\n\x05\x04A\x02\0\x03\x12\x04\xb9\x17%&\na\n\x02\x04B\x12\x06\
    \xc1\x17\0\xd4\x17\x01\x1aS*\n\x20Encapsulation\x20for\x20Linux\x20speci\
    fic\x20configuration.\n\x20E.g,\x20capabilities,\x20limits\x20etc.\n\n\
    \x0b\n\x03\x04B\x01\x12\x04\xc1\x17\x08\x11\nM\n\x04\x04B\x02\0\x12\x04\
    \xc3\x17\x02B\x1a?\x20Since\x201.4.0,\x20deprecated\x20in\x20favor\x20of\
    \x20`effective_capabilities`.\n\n\r\n\x05\x04B\x02\0\x04\x12\x04\xc3\x17\
    \x02\n\n\r\n\x05\x04B\x02\0\x06\x12\x04\xc3\x17\x0b\x19\n\r\n\x05\x04B\
    \x02\0\x01\x12\x04\xc3\x17\x1a)\n\r\n\x05\x04B\x02\0\x03\x12\x04\xc3\x17\
    ,-\n\r\n\x05\x04B\x02\0\x08\x12\x04\xc3\x17.A\n\x10\n\x08\x04B\x02\0\x08\
    \xe7\x07\0\x12\x04\xc3\x17/@\n\x11\n\t\x04B\x02\0\x08\xe7\x07\0\x02\x12\
    \x04\xc3\x17/9\n\x12\n\n\x04B\x02\0\x08\xe7\x07\0\x02\0\x12\x04\xc3\x17/\
    9\n\x13\n\x0b\x04B\x02\0\x08\xe7\x07\0\x02\0\x01\x12\x04\xc3\x17/9\n\x11\
    \n\t\x04B\x02\0\x08\xe7\x07\0\x03\x12\x04\xc3\x17<@\n]\n\x04\x04B\x02\
    \x01\x12\x04\xc7\x17\x024\x1aO\x20The\x20set\x20of\x20capabilities\x20th\
    at\x20are\x20allowed\x20but\x20not\x20initially\n\x20granted\x20to\x20ta\
    sks.\n\n\r\n\x05\x04B\x02\x01\x04\x12\x04\xc7\x17\x02\n\n\r\n\x05\x04B\
    \x02\x01\x06\x12\x04\xc7\x17\x0b\x19\n\r\n\x05\x04B\x02\x01\x01\x12\x04\
    \xc7\x17\x1a/\n\r\n\x05\x04B\x02\x01\x03\x12\x04\xc7\x1723\nX\n\x04\x04B\
    \x02\x02\x12\x04\xcb\x17\x025\x1aJ\x20Represents\x20the\x20set\x20of\x20\
    capabilities\x20that\x20the\x20task\x20will\n\x20be\x20executed\x20with.\
    \n\n\r\n\x05\x04B\x02\x02\x04\x12\x04\xcb\x17\x02\n\n\r\n\x05\x04B\x02\
    \x02\x06\x12\x04\xcb\x17\x0b\x19\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xcb\
    \x17\x1a0\n\r\n\x05\x04B\x02\x02\x03\x12\x04\xcb\x1734\n\xe5\x02\n\x04\
    \x04B\x02\x03\x12\x04\xd3\x17\x02(\x1a\xd6\x02\x20If\x20set\x20as\x20'tr\
    ue',\x20the\x20container\x20shares\x20the\x20pid\x20namespace\x20with\n\
    \x20its\x20parent.\x20If\x20the\x20container\x20is\x20a\x20top\x20level\
    \x20container,\x20it\x20will\n\x20share\x20the\x20pid\x20namespace\x20wi\
    th\x20the\x20agent.\x20If\x20the\x20container\x20is\x20a\n\x20nested\x20\
    container,\x20it\x20will\x20share\x20the\x20pid\x20namespace\x20with\x20\
    its\n\x20parent\x20container.\x20This\x20field\x20will\x20be\x20ignored\
    \x20if\x20'namespaces/pid'\n\x20isolator\x20is\x20not\x20enabled.\n\n\r\
    \n\x05\x04B\x02\x03\x04\x12\x04\xd3\x17\x02\n\n\r\n\x05\x04B\x02\x03\x05\
    \x12\x04\xd3\x17\x0b\x0f\n\r\n\x05\x04B\x02\x03\x01\x12\x04\xd3\x17\x10#\
    \n\r\n\x05\x04B\x02\x03\x03\x12\x04\xd3\x17&'\n\xa1\x02\n\x02\x04C\x12\
    \x06\xde\x17\0\xfd\x17\x01\x1a\x92\x02*\n\x20Encapsulation\x20for\x20POS\
    IX\x20rlimits,\x20see\n\x20http://pubs.opengroup.org/onlinepubs/00969539\
    9/functions/getrlimit.html.\n\x20Note\x20that\x20some\x20types\x20might\
    \x20only\x20be\x20defined\x20for\x20Linux.\n\x20We\x20use\x20a\x20custom\
    \x20prefix\x20to\x20avoid\x20conflict\x20with\x20existing\x20system\x20m\
    acros\n\x20(e.g.,\x20`RLIMIT_CPU`\x20or\x20`NOFILE`).\n\n\x0b\n\x03\x04C\
    \x01\x12\x04\xde\x17\x08\x12\n\x0e\n\x04\x04C\x03\0\x12\x06\xdf\x17\x02\
    \xfa\x17\x03\n\r\n\x05\x04C\x03\0\x01\x12\x04\xdf\x17\n\x10\n\x10\n\x06\
    \x04C\x03\0\x04\0\x12\x06\xe0\x17\x04\xf2\x17\x05\n\x0f\n\x07\x04C\x03\0\
    \x04\0\x01\x12\x04\xe0\x17\t\r\n\x10\n\x08\x04C\x03\0\x04\0\x02\0\x12\
    \x04\xe1\x17\x06\x12\n\x11\n\t\x04C\x03\0\x04\0\x02\0\x01\x12\x04\xe1\
    \x17\x06\r\n\x11\n\t\x04C\x03\0\x04\0\x02\0\x02\x12\x04\xe1\x17\x10\x11\
    \n\x10\n\x08\x04C\x03\0\x04\0\x02\x01\x12\x04\xe2\x17\x06\x12\n\x11\n\t\
    \x04C\x03\0\x04\0\x02\x01\x01\x12\x04\xe2\x17\x06\r\n\x11\n\t\x04C\x03\0\
    \x04\0\x02\x01\x02\x12\x04\xe2\x17\x10\x11\n\x10\n\x08\x04C\x03\0\x04\0\
    \x02\x02\x12\x04\xe3\x17\x06\x14\n\x11\n\t\x04C\x03\0\x04\0\x02\x02\x01\
    \x12\x04\xe3\x17\x06\x0f\n\x11\n\t\x04C\x03\0\x04\0\x02\x02\x02\x12\x04\
    \xe3\x17\x12\x13\n\x10\n\x08\x04C\x03\0\x04\0\x02\x03\x12\x04\xe4\x17\
    \x06\x13\n\x11\n\t\x04C\x03\0\x04\0\x02\x03\x01\x12\x04\xe4\x17\x06\x0e\
    \n\x11\n\t\x04C\x03\0\x04\0\x02\x03\x02\x12\x04\xe4\x17\x11\x12\n\x10\n\
    \x08\x04C\x03\0\x04\0\x02\x04\x12\x04\xe5\x17\x06\x14\n\x11\n\t\x04C\x03\
    \0\x04\0\x02\x04\x01\x12\x04\xe5\x17\x06\x0f\n\x11\n\t\x04C\x03\0\x04\0\
    \x02\x04\x02\x12\x04\xe5\x17\x12\x13\n\x10\n\x08\x04C\x03\0\x04\0\x02\
    \x05\x12\x04\xe6\x17\x06\x15\n\x11\n\t\x04C\x03\0\x04\0\x02\x05\x01\x12\
    \x04\xe6\x17\x06\x10\n\x11\n\t\x04C\x03\0\x04\0\x02\x05\x02\x12\x04\xe6\
    \x17\x13\x14\n\x10\n\x08\x04C\x03\0\x04\0\x02\x06\x12\x04\xe7\x17\x06\
    \x15\n\x11\n\t\x04C\x03\0\x04\0\x02\x06\x01\x12\x04\xe7\x17\x06\x10\n\
    \x11\n\t\x04C\x03\0\x04\0\x02\x06\x02\x12\x04\xe7\x17\x13\x14\n\x10\n\
    \x08\x04C\x03\0\x04\0\x02\x07\x12\x04\xe8\x17\x06\x17\n\x11\n\t\x04C\x03\
    \0\x04\0\x02\x07\x01\x12\x04\xe8\x17\x06\x12\n\x11\n\t\x04C\x03\0\x04\0\
    \x02\x07\x02\x12\x04\xe8\x17\x15\x16\n\x10\n\x08\x04C\x03\0\x04\0\x02\
    \x08\x12\x04\xe9\x17\x06\x18\n\x11\n\t\x04C\x03\0\x04\0\x02\x08\x01\x12\
    \x04\xe9\x17\x06\x13\n\x11\n\t\x04C\x03\0\x04\0\x02\x08\x02\x12\x04\xe9\
    \x17\x16\x17\n\x10\n\x08\x04C\x03\0\x04\0\x02\t\x12\x04\xea\x17\x06\x14\
    \n\x11\n\t\x04C\x03\0\x04\0\x02\t\x01\x12\x04\xea\x17\x06\x0f\n\x11\n\t\
    \x04C\x03\0\x04\0\x02\t\x02\x12\x04\xea\x17\x12\x13\n\x10\n\x08\x04C\x03\
    \0\x04\0\x02\n\x12\x04\xeb\x17\x06\x17\n\x11\n\t\x04C\x03\0\x04\0\x02\n\
    \x01\x12\x04\xeb\x17\x06\x11\n\x11\n\t\x04C\x03\0\x04\0\x02\n\x02\x12\
    \x04\xeb\x17\x14\x16\n\x10\n\x08\x04C\x03\0\x04\0\x02\x0b\x12\x04\xec\
    \x17\x06\x16\n\x11\n\t\x04C\x03\0\x04\0\x02\x0b\x01\x12\x04\xec\x17\x06\
    \x10\n\x11\n\t\x04C\x03\0\x04\0\x02\x0b\x02\x12\x04\xec\x17\x13\x15\n\
    \x10\n\x08\x04C\x03\0\x04\0\x02\x0c\x12\x04\xed\x17\x06\x14\n\x11\n\t\
    \x04C\x03\0\x04\0\x02\x0c\x01\x12\x04\xed\x17\x06\x0e\n\x11\n\t\x04C\x03\
    \0\x04\0\x02\x0c\x02\x12\x04\xed\x17\x11\x13\n\x10\n\x08\x04C\x03\0\x04\
    \0\x02\r\x12\x04\xee\x17\x06\x17\n\x11\n\t\x04C\x03\0\x04\0\x02\r\x01\
    \x12\x04\xee\x17\x06\x11\n\x11\n\t\x04C\x03\0\x04\0\x02\r\x02\x12\x04\
    \xee\x17\x14\x16\n\x10\n\x08\x04C\x03\0\x04\0\x02\x0e\x12\x04\xef\x17\
    \x06\x17\n\x11\n\t\x04C\x03\0\x04\0\x02\x0e\x01\x12\x04\xef\x17\x06\x11\
    \n\x11\n\t\x04C\x03\0\x04\0\x02\x0e\x02\x12\x04\xef\x17\x14\x16\n\x10\n\
    \x08\x04C\x03\0\x04\0\x02\x0f\x12\x04\xf0\x17\x06\x1b\n\x11\n\t\x04C\x03\
    \0\x04\0\x02\x0f\x01\x12\x04\xf0\x17\x06\x15\n\x11\n\t\x04C\x03\0\x04\0\
    \x02\x0f\x02\x12\x04\xf0\x17\x18\x1a\n\x10\n\x08\x04C\x03\0\x04\0\x02\
    \x10\x12\x04\xf1\x17\x06\x16\n\x11\n\t\x04C\x03\0\x04\0\x02\x10\x01\x12\
    \x04\xf1\x17\x06\x10\n\x11\n\t\x04C\x03\0\x04\0\x02\x10\x02\x12\x04\xf1\
    \x17\x13\x15\n\x0e\n\x06\x04C\x03\0\x02\0\x12\x04\xf3\x17\x04\x1b\n\x0f\
    \n\x07\x04C\x03\0\x02\0\x04\x12\x04\xf3\x17\x04\x0c\n\x0f\n\x07\x04C\x03\
    \0\x02\0\x06\x12\x04\xf3\x17\r\x11\n\x0f\n\x07\x04C\x03\0\x02\0\x01\x12\
    \x04\xf3\x17\x12\x16\n\x0f\n\x07\x04C\x03\0\x02\0\x03\x12\x04\xf3\x17\
    \x19\x1a\n\x99\x01\n\x06\x04C\x03\0\x02\x01\x12\x04\xf8\x17\x04\x1d\x1a\
    \x88\x01\x20Either\x20both\x20are\x20set\x20or\x20both\x20are\x20not\x20\
    set.\n\x20If\x20both\x20are\x20not\x20set,\x20it\x20represents\x20unlimi\
    ted.\n\x20If\x20both\x20are\x20set,\x20we\x20require\x20`soft`\x20<=\x20\
    `hard`.\n\n\x0f\n\x07\x04C\x03\0\x02\x01\x04\x12\x04\xf8\x17\x04\x0c\n\
    \x0f\n\x07\x04C\x03\0\x02\x01\x05\x12\x04\xf8\x17\r\x13\n\x0f\n\x07\x04C\
    \x03\0\x02\x01\x01\x12\x04\xf8\x17\x14\x18\n\x0f\n\x07\x04C\x03\0\x02\
    \x01\x03\x12\x04\xf8\x17\x1b\x1c\n\x0e\n\x06\x04C\x03\0\x02\x02\x12\x04\
    \xf9\x17\x04\x1d\n\x0f\n\x07\x04C\x03\0\x02\x02\x04\x12\x04\xf9\x17\x04\
    \x0c\n\x0f\n\x07\x04C\x03\0\x02\x02\x05\x12\x04\xf9\x17\r\x13\n\x0f\n\
    \x07\x04C\x03\0\x02\x02\x01\x12\x04\xf9\x17\x14\x18\n\x0f\n\x07\x04C\x03\
    \0\x02\x02\x03\x12\x04\xf9\x17\x1b\x1c\n\x0c\n\x04\x04C\x02\0\x12\x04\
    \xfc\x17\x02\x1e\n\r\n\x05\x04C\x02\0\x04\x12\x04\xfc\x17\x02\n\n\r\n\
    \x05\x04C\x02\0\x06\x12\x04\xfc\x17\x0b\x11\n\r\n\x05\x04C\x02\0\x01\x12\
    \x04\xfc\x17\x12\x19\n\r\n\x05\x04C\x02\0\x03\x12\x04\xfc\x17\x1c\x1d\ny\
    \n\x02\x04D\x12\x06\x84\x18\0\x8b\x18\x01\x1ak*\n\x20Describes\x20the\
    \x20information\x20about\x20(pseudo)\x20TTY\x20that\x20can\n\x20be\x20at\
    tached\x20to\x20a\x20process\x20running\x20in\x20a\x20container.\n\n\x0b\
    \n\x03\x04D\x01\x12\x04\x84\x18\x08\x0f\n\x0e\n\x04\x04D\x03\0\x12\x06\
    \x85\x18\x02\x88\x18\x03\n\r\n\x05\x04D\x03\0\x01\x12\x04\x85\x18\n\x14\
    \n\x0e\n\x06\x04D\x03\0\x02\0\x12\x04\x86\x18\x04\x1d\n\x0f\n\x07\x04D\
    \x03\0\x02\0\x04\x12\x04\x86\x18\x04\x0c\n\x0f\n\x07\x04D\x03\0\x02\0\
    \x05\x12\x04\x86\x18\r\x13\n\x0f\n\x07\x04D\x03\0\x02\0\x01\x12\x04\x86\
    \x18\x14\x18\n\x0f\n\x07\x04D\x03\0\x02\0\x03\x12\x04\x86\x18\x1b\x1c\n\
    \x0e\n\x06\x04D\x03\0\x02\x01\x12\x04\x87\x18\x04\x20\n\x0f\n\x07\x04D\
    \x03\0\x02\x01\x04\x12\x04\x87\x18\x04\x0c\n\x0f\n\x07\x04D\x03\0\x02\
    \x01\x05\x12\x04\x87\x18\r\x13\n\x0f\n\x07\x04D\x03\0\x02\x01\x01\x12\
    \x04\x87\x18\x14\x1b\n\x0f\n\x07\x04D\x03\0\x02\x01\x03\x12\x04\x87\x18\
    \x1e\x1f\n\x0c\n\x04\x04D\x02\0\x12\x04\x8a\x18\x02&\n\r\n\x05\x04D\x02\
    \0\x04\x12\x04\x8a\x18\x02\n\n\r\n\x05\x04D\x02\0\x06\x12\x04\x8a\x18\
    \x0b\x15\n\r\n\x05\x04D\x02\0\x01\x12\x04\x8a\x18\x16!\n\r\n\x05\x04D\
    \x02\0\x03\x12\x04\x8a\x18$%\n\x96\x04\n\x02\x04E\x12\x06\x99\x18\0\xe1\
    \x18\x01\x1a\x87\x04*\n\x20Describes\x20a\x20container\x20configuration\
    \x20and\x20allows\x20extensible\n\x20configurations\x20for\x20different\
    \x20container\x20implementations.\n\n\x20NOTE:\x20`ContainerInfo`\x20may\
    \x20be\x20specified,\x20e.g.,\x20by\x20a\x20task,\x20even\x20if\x20no\n\
    \x20container\x20image\x20is\x20provided.\x20In\x20this\x20case\x20neith\
    er\x20`MesosInfo`\x20nor\n\x20`DockerInfo`\x20is\x20set,\x20the\x20requi\
    red\x20`type`\x20must\x20be\x20`MESOS`.\x20This\x20is\x20to\n\x20address\
    \x20a\x20case\x20when\x20a\x20task\x20without\x20an\x20image,\x20e.g.,\
    \x20a\x20shell\x20script\n\x20with\x20URIs,\x20wants\x20to\x20use\x20fea\
    tures\x20originally\x20designed\x20for\x20containers,\n\x20for\x20exampl\
    e\x20custom\x20network\x20isolation\x20via\x20`NetworkInfo`.\n\n\x0b\n\
    \x03\x04E\x01\x12\x04\x99\x18\x08\x15\n5\n\x04\x04E\x04\0\x12\x06\x9b\
    \x18\x02\x9e\x18\x03\x1a%\x20All\x20container\x20implementation\x20types\
    .\n\n\r\n\x05\x04E\x04\0\x01\x12\x04\x9b\x18\x07\x0b\n\x0e\n\x06\x04E\
    \x04\0\x02\0\x12\x04\x9c\x18\x04\x0f\n\x0f\n\x07\x04E\x04\0\x02\0\x01\
    \x12\x04\x9c\x18\x04\n\n\x0f\n\x07\x04E\x04\0\x02\0\x02\x12\x04\x9c\x18\
    \r\x0e\n\x0e\n\x06\x04E\x04\0\x02\x01\x12\x04\x9d\x18\x04\x0e\n\x0f\n\
    \x07\x04E\x04\0\x02\x01\x01\x12\x04\x9d\x18\x04\t\n\x0f\n\x07\x04E\x04\0\
    \x02\x01\x02\x12\x04\x9d\x18\x0c\r\n\x0e\n\x04\x04E\x03\0\x12\x06\xa0\
    \x18\x02\xc6\x18\x03\n\r\n\x05\x04E\x03\0\x01\x12\x04\xa0\x18\n\x14\nN\n\
    \x06\x04E\x03\0\x02\0\x12\x04\xa2\x18\x04\x1e\x1a>\x20The\x20docker\x20i\
    mage\x20that\x20is\x20going\x20to\x20be\x20passed\x20to\x20the\x20regist\
    ry.\n\n\x0f\n\x07\x04E\x03\0\x02\0\x04\x12\x04\xa2\x18\x04\x0c\n\x0f\n\
    \x07\x04E\x03\0\x02\0\x05\x12\x04\xa2\x18\r\x13\n\x0f\n\x07\x04E\x03\0\
    \x02\0\x01\x12\x04\xa2\x18\x14\x19\n\x0f\n\x07\x04E\x03\0\x02\0\x03\x12\
    \x04\xa2\x18\x1c\x1d\n$\n\x06\x04E\x03\0\x04\0\x12\x06\xa5\x18\x04\xaa\
    \x18\x05\x1a\x12\x20Network\x20options.\n\n\x0f\n\x07\x04E\x03\0\x04\0\
    \x01\x12\x04\xa5\x18\t\x10\n\x10\n\x08\x04E\x03\0\x04\0\x02\0\x12\x04\
    \xa6\x18\x06\x0f\n\x11\n\t\x04E\x03\0\x04\0\x02\0\x01\x12\x04\xa6\x18\
    \x06\n\n\x11\n\t\x04E\x03\0\x04\0\x02\0\x02\x12\x04\xa6\x18\r\x0e\n\x10\
    \n\x08\x04E\x03\0\x04\0\x02\x01\x12\x04\xa7\x18\x06\x11\n\x11\n\t\x04E\
    \x03\0\x04\0\x02\x01\x01\x12\x04\xa7\x18\x06\x0c\n\x11\n\t\x04E\x03\0\
    \x04\0\x02\x01\x02\x12\x04\xa7\x18\x0f\x10\n\x10\n\x08\x04E\x03\0\x04\0\
    \x02\x02\x12\x04\xa8\x18\x06\x0f\n\x11\n\t\x04E\x03\0\x04\0\x02\x02\x01\
    \x12\x04\xa8\x18\x06\n\n\x11\n\t\x04E\x03\0\x04\0\x02\x02\x02\x12\x04\
    \xa8\x18\r\x0e\n\x10\n\x08\x04E\x03\0\x04\0\x02\x03\x12\x04\xa9\x18\x06\
    \x0f\n\x11\n\t\x04E\x03\0\x04\0\x02\x03\x01\x12\x04\xa9\x18\x06\n\n\x11\
    \n\t\x04E\x03\0\x04\0\x02\x03\x02\x12\x04\xa9\x18\r\x0e\n\x0e\n\x06\x04E\
    \x03\0\x02\x01\x12\x04\xac\x18\x042\n\x0f\n\x07\x04E\x03\0\x02\x01\x04\
    \x12\x04\xac\x18\x04\x0c\n\x0f\n\x07\x04E\x03\0\x02\x01\x06\x12\x04\xac\
    \x18\r\x14\n\x0f\n\x07\x04E\x03\0\x02\x01\x01\x12\x04\xac\x18\x15\x1c\n\
    \x0f\n\x07\x04E\x03\0\x02\x01\x03\x12\x04\xac\x18\x1f\x20\n\x0f\n\x07\
    \x04E\x03\0\x02\x01\x08\x12\x04\xac\x18!1\n\x0f\n\x07\x04E\x03\0\x02\x01\
    \x07\x12\x04\xac\x18,0\n\x10\n\x06\x04E\x03\0\x03\0\x12\x06\xae\x18\x04\
    \xb3\x18\x05\n\x0f\n\x07\x04E\x03\0\x03\0\x01\x12\x04\xae\x18\x0c\x17\n\
    \x10\n\x08\x04E\x03\0\x03\0\x02\0\x12\x04\xaf\x18\x06$\n\x11\n\t\x04E\
    \x03\0\x03\0\x02\0\x04\x12\x04\xaf\x18\x06\x0e\n\x11\n\t\x04E\x03\0\x03\
    \0\x02\0\x05\x12\x04\xaf\x18\x0f\x15\n\x11\n\t\x04E\x03\0\x03\0\x02\0\
    \x01\x12\x04\xaf\x18\x16\x1f\n\x11\n\t\x04E\x03\0\x03\0\x02\0\x03\x12\
    \x04\xaf\x18\"#\n\x10\n\x08\x04E\x03\0\x03\0\x02\x01\x12\x04\xb0\x18\x06\
    )\n\x11\n\t\x04E\x03\0\x03\0\x02\x01\x04\x12\x04\xb0\x18\x06\x0e\n\x11\n\
    \t\x04E\x03\0\x03\0\x02\x01\x05\x12\x04\xb0\x18\x0f\x15\n\x11\n\t\x04E\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xb0\x18\x16$\n\x11\n\t\x04E\x03\0\x03\0\
    \x02\x01\x03\x12\x04\xb0\x18'(\n9\n\x08\x04E\x03\0\x03\0\x02\x02\x12\x04\
    \xb2\x18\x06#\x1a'\x20Protocol\x20to\x20expose\x20as\x20(ie:\x20tcp,\x20\
    udp).\n\n\x11\n\t\x04E\x03\0\x03\0\x02\x02\x04\x12\x04\xb2\x18\x06\x0e\n\
    \x11\n\t\x04E\x03\0\x03\0\x02\x02\x05\x12\x04\xb2\x18\x0f\x15\n\x11\n\t\
    \x04E\x03\0\x03\0\x02\x02\x01\x12\x04\xb2\x18\x16\x1e\n\x11\n\t\x04E\x03\
    \0\x03\0\x02\x02\x03\x12\x04\xb2\x18!\"\n\x0e\n\x06\x04E\x03\0\x02\x02\
    \x12\x04\xb5\x18\x04+\n\x0f\n\x07\x04E\x03\0\x02\x02\x04\x12\x04\xb5\x18\
    \x04\x0c\n\x0f\n\x07\x04E\x03\0\x02\x02\x06\x12\x04\xb5\x18\r\x18\n\x0f\
    \n\x07\x04E\x03\0\x02\x02\x01\x12\x04\xb5\x18\x19&\n\x0f\n\x07\x04E\x03\
    \0\x02\x02\x03\x12\x04\xb5\x18)*\n\x0e\n\x06\x04E\x03\0\x02\x03\x12\x04\
    \xb7\x18\x043\n\x0f\n\x07\x04E\x03\0\x02\x03\x04\x12\x04\xb7\x18\x04\x0c\
    \n\x0f\n\x07\x04E\x03\0\x02\x03\x05\x12\x04\xb7\x18\r\x11\n\x0f\n\x07\
    \x04E\x03\0\x02\x03\x01\x12\x04\xb7\x18\x12\x1c\n\x0f\n\x07\x04E\x03\0\
    \x02\x03\x03\x12\x04\xb7\x18\x1f\x20\n\x0f\n\x07\x04E\x03\0\x02\x03\x08\
    \x12\x04\xb7\x18!2\n\x0f\n\x07\x04E\x03\0\x02\x03\x07\x12\x04\xb7\x18,1\
    \n\xd4\x01\n\x06\x04E\x03\0\x02\x04\x12\x04\xbd\x18\x04&\x1a\xc3\x01\x20\
    Allowing\x20arbitrary\x20parameters\x20to\x20be\x20passed\x20to\x20docke\
    r\x20CLI.\n\x20Note\x20that\x20anything\x20passed\x20to\x20this\x20field\
    \x20is\x20not\x20guaranteed\n\x20to\x20be\x20supported\x20moving\x20forw\
    ard,\x20as\x20we\x20might\x20move\x20away\x20from\n\x20the\x20docker\x20\
    CLI.\n\n\x0f\n\x07\x04E\x03\0\x02\x04\x04\x12\x04\xbd\x18\x04\x0c\n\x0f\
    \n\x07\x04E\x03\0\x02\x04\x06\x12\x04\xbd\x18\r\x16\n\x0f\n\x07\x04E\x03\
    \0\x02\x04\x01\x12\x04\xbd\x18\x17!\n\x0f\n\x07\x04E\x03\0\x02\x04\x03\
    \x12\x04\xbd\x18$%\n\xac\x01\n\x06\x04E\x03\0\x02\x05\x12\x04\xc2\x18\
    \x04'\x1a\x9b\x01\x20With\x20this\x20flag\x20set\x20to\x20true,\x20the\
    \x20docker\x20containerizer\x20will\n\x20pull\x20the\x20docker\x20image\
    \x20from\x20the\x20registry\x20even\x20if\x20the\x20image\n\x20is\x20alr\
    eady\x20downloaded\x20on\x20the\x20agent.\n\n\x0f\n\x07\x04E\x03\0\x02\
    \x05\x04\x12\x04\xc2\x18\x04\x0c\n\x0f\n\x07\x04E\x03\0\x02\x05\x05\x12\
    \x04\xc2\x18\r\x11\n\x0f\n\x07\x04E\x03\0\x02\x05\x01\x12\x04\xc2\x18\
    \x12\"\n\x0f\n\x07\x04E\x03\0\x02\x05\x03\x12\x04\xc2\x18%&\n@\n\x06\x04\
    E\x03\0\x02\x06\x12\x04\xc5\x18\x04:\x1a#\x20The\x20name\x20of\x20volume\
    \x20driver\x20plugin.\n\"\x0b\x20Since\x201.0\n\n\x0f\n\x07\x04E\x03\0\
    \x02\x06\x04\x12\x04\xc5\x18\x04\x0c\n\x0f\n\x07\x04E\x03\0\x02\x06\x05\
    \x12\x04\xc5\x18\r\x13\n\x0f\n\x07\x04E\x03\0\x02\x06\x01\x12\x04\xc5\
    \x18\x14!\n\x0f\n\x07\x04E\x03\0\x02\x06\x03\x12\x04\xc5\x18$%\n\x0f\n\
    \x07\x04E\x03\0\x02\x06\x08\x12\x04\xc5\x18&9\n\x12\n\n\x04E\x03\0\x02\
    \x06\x08\xe7\x07\0\x12\x04\xc5\x18'8\n\x13\n\x0b\x04E\x03\0\x02\x06\x08\
    \xe7\x07\0\x02\x12\x04\xc5\x18'1\n\x14\n\x0c\x04E\x03\0\x02\x06\x08\xe7\
    \x07\0\x02\0\x12\x04\xc5\x18'1\n\x15\n\r\x04E\x03\0\x02\x06\x08\xe7\x07\
    \0\x02\0\x01\x12\x04\xc5\x18'1\n\x13\n\x0b\x04E\x03\0\x02\x06\x08\xe7\
    \x07\0\x03\x12\x04\xc5\x1848\n\x0e\n\x04\x04E\x03\x01\x12\x06\xc8\x18\
    \x02\xca\x18\x03\n\r\n\x05\x04E\x03\x01\x01\x12\x04\xc8\x18\n\x13\n\x0e\
    \n\x06\x04E\x03\x01\x02\0\x12\x04\xc9\x18\x04\x1d\n\x0f\n\x07\x04E\x03\
    \x01\x02\0\x04\x12\x04\xc9\x18\x04\x0c\n\x0f\n\x07\x04E\x03\x01\x02\0\
    \x06\x12\x04\xc9\x18\r\x12\n\x0f\n\x07\x04E\x03\x01\x02\0\x01\x12\x04\
    \xc9\x18\x13\x18\n\x0f\n\x07\x04E\x03\x01\x02\0\x03\x12\x04\xc9\x18\x1b\
    \x1c\n\x0c\n\x04\x04E\x02\0\x12\x04\xcc\x18\x02\x19\n\r\n\x05\x04E\x02\0\
    \x04\x12\x04\xcc\x18\x02\n\n\r\n\x05\x04E\x02\0\x06\x12\x04\xcc\x18\x0b\
    \x0f\n\r\n\x05\x04E\x02\0\x01\x12\x04\xcc\x18\x10\x14\n\r\n\x05\x04E\x02\
    \0\x03\x12\x04\xcc\x18\x17\x18\n\x0c\n\x04\x04E\x02\x01\x12\x04\xcd\x18\
    \x02\x1e\n\r\n\x05\x04E\x02\x01\x04\x12\x04\xcd\x18\x02\n\n\r\n\x05\x04E\
    \x02\x01\x06\x12\x04\xcd\x18\x0b\x11\n\r\n\x05\x04E\x02\x01\x01\x12\x04\
    \xcd\x18\x12\x19\n\r\n\x05\x04E\x02\x01\x03\x12\x04\xcd\x18\x1c\x1d\n\
    \x0c\n\x04\x04E\x02\x02\x12\x04\xce\x18\x02\x1f\n\r\n\x05\x04E\x02\x02\
    \x04\x12\x04\xce\x18\x02\n\n\r\n\x05\x04E\x02\x02\x05\x12\x04\xce\x18\
    \x0b\x11\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xce\x18\x12\x1a\n\r\n\x05\
    \x04E\x02\x02\x03\x12\x04\xce\x18\x1d\x1e\nZ\n\x04\x04E\x02\x03\x12\x04\
    \xd2\x18\x02!\x1aL\x20Only\x20one\x20of\x20the\x20following\x20*Info\x20\
    messages\x20should\x20be\x20set\x20to\x20match\n\x20the\x20type.\n\n\r\n\
    \x05\x04E\x02\x03\x04\x12\x04\xd2\x18\x02\n\n\r\n\x05\x04E\x02\x03\x06\
    \x12\x04\xd2\x18\x0b\x15\n\r\n\x05\x04E\x02\x03\x01\x12\x04\xd2\x18\x16\
    \x1c\n\r\n\x05\x04E\x02\x03\x03\x12\x04\xd2\x18\x1f\x20\n\x0c\n\x04\x04E\
    \x02\x04\x12\x04\xd3\x18\x02\x1f\n\r\n\x05\x04E\x02\x04\x04\x12\x04\xd3\
    \x18\x02\n\n\r\n\x05\x04E\x02\x04\x06\x12\x04\xd3\x18\x0b\x14\n\r\n\x05\
    \x04E\x02\x04\x01\x12\x04\xd3\x18\x15\x1a\n\r\n\x05\x04E\x02\x04\x03\x12\
    \x04\xd3\x18\x1d\x1e\nm\n\x04\x04E\x02\x05\x12\x04\xd7\x18\x02)\x1a_\x20\
    A\x20list\x20of\x20network\x20requests.\x20A\x20framework\x20can\x20requ\
    est\x20multiple\x20IP\x20addresses\n\x20for\x20the\x20container.\n\n\r\n\
    \x05\x04E\x02\x05\x04\x12\x04\xd7\x18\x02\n\n\r\n\x05\x04E\x02\x05\x06\
    \x12\x04\xd7\x18\x0b\x16\n\r\n\x05\x04E\x02\x05\x01\x12\x04\xd7\x18\x17$\
    \n\r\n\x05\x04E\x02\x05\x03\x12\x04\xd7\x18'(\n=\n\x04\x04E\x02\x06\x12\
    \x04\xda\x18\x02$\x1a/\x20Linux\x20specific\x20information\x20for\x20the\
    \x20container.\n\n\r\n\x05\x04E\x02\x06\x04\x12\x04\xda\x18\x02\n\n\r\n\
    \x05\x04E\x02\x06\x06\x12\x04\xda\x18\x0b\x14\n\r\n\x05\x04E\x02\x06\x01\
    \x12\x04\xda\x18\x15\x1f\n\r\n\x05\x04E\x02\x06\x03\x12\x04\xda\x18\"#\n\
    6\n\x04\x04E\x02\x07\x12\x04\xdd\x18\x02&\x1a(\x20(POSIX\x20only)\x20rli\
    mits\x20of\x20the\x20container.\n\n\r\n\x05\x04E\x02\x07\x04\x12\x04\xdd\
    \x18\x02\n\n\r\n\x05\x04E\x02\x07\x06\x12\x04\xdd\x18\x0b\x15\n\r\n\x05\
    \x04E\x02\x07\x01\x12\x04\xdd\x18\x16!\n\r\n\x05\x04E\x02\x07\x03\x12\
    \x04\xdd\x18$%\nP\n\x04\x04E\x02\x08\x12\x04\xe0\x18\x02!\x1aB\x20If\x20\
    specified\x20a\x20tty\x20will\x20be\x20attached\x20to\x20the\x20containe\
    r\x20entrypoint.\n\n\r\n\x05\x04E\x02\x08\x04\x12\x04\xe0\x18\x02\n\n\r\
    \n\x05\x04E\x02\x08\x06\x12\x04\xe0\x18\x0b\x12\n\r\n\x05\x04E\x02\x08\
    \x01\x12\x04\xe0\x18\x13\x1b\n\r\n\x05\x04E\x02\x08\x03\x12\x04\xe0\x18\
    \x1e\x20\n\xac\x01\n\x02\x04F\x12\x06\xe9\x18\0\xf4\x18\x01\x1a\x9d\x01*\
    \n\x20Container\x20related\x20information\x20that\x20is\x20resolved\x20d\
    uring\x20container\n\x20setup.\x20The\x20information\x20is\x20sent\x20ba\
    ck\x20to\x20the\x20framework\x20as\x20part\x20of\x20the\n\x20TaskStatus\
    \x20message.\n\n\x0b\n\x03\x04F\x01\x12\x04\xe9\x18\x08\x17\n\x0c\n\x04\
    \x04F\x02\0\x12\x04\xea\x18\x02(\n\r\n\x05\x04F\x02\0\x04\x12\x04\xea\
    \x18\x02\n\n\r\n\x05\x04F\x02\0\x06\x12\x04\xea\x18\x0b\x16\n\r\n\x05\
    \x04F\x02\0\x01\x12\x04\xea\x18\x17#\n\r\n\x05\x04F\x02\0\x03\x12\x04\
    \xea\x18&'\nU\n\x04\x04F\x02\x01\x12\x04\xed\x18\x02)\x1aG\x20This\x20fi\
    eld\x20can\x20be\x20reliably\x20used\x20to\x20identify\x20the\x20contain\
    er\x20IP\x20address.\n\n\r\n\x05\x04F\x02\x01\x04\x12\x04\xed\x18\x02\n\
    \n\r\n\x05\x04F\x02\x01\x06\x12\x04\xed\x18\x0b\x16\n\r\n\x05\x04F\x02\
    \x01\x01\x12\x04\xed\x18\x17$\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xed\x18\
    '(\n?\n\x04\x04F\x02\x02\x12\x04\xf0\x18\x02&\x1a1\x20Information\x20abo\
    ut\x20Linux\x20control\x20group\x20(cgroup).\n\n\r\n\x05\x04F\x02\x02\
    \x04\x12\x04\xf0\x18\x02\n\n\r\n\x05\x04F\x02\x02\x06\x12\x04\xf0\x18\
    \x0b\x15\n\r\n\x05\x04F\x02\x02\x01\x12\x04\xf0\x18\x16!\n\r\n\x05\x04F\
    \x02\x02\x03\x12\x04\xf0\x18$%\n/\n\x04\x04F\x02\x03\x12\x04\xf3\x18\x02\
    #\x1a!\x20Information\x20about\x20Executor\x20PID.\n\n\r\n\x05\x04F\x02\
    \x03\x04\x12\x04\xf3\x18\x02\n\n\r\n\x05\x04F\x02\x03\x05\x12\x04\xf3\
    \x18\x0b\x11\n\r\n\x05\x04F\x02\x03\x01\x12\x04\xf3\x18\x12\x1e\n\r\n\
    \x05\x04F\x02\x03\x03\x12\x04\xf3\x18!\"\n;\n\x02\x04G\x12\x06\xfa\x18\0\
    \xc6\x19\x01\x1a-*\n\x20Linux\x20control\x20group\x20(cgroup)\x20informa\
    tion.\n\n\x0b\n\x03\x04G\x01\x12\x04\xfa\x18\x08\x12\n<\n\x04\x04G\x03\0\
    \x12\x06\xfc\x18\x02\xba\x19\x03\x1a,\x20Configuration\x20of\x20a\x20blk\
    io\x20cgroup\x20subsystem.\n\n\r\n\x05\x04G\x03\0\x01\x12\x04\xfc\x18\n\
    \x0f\n\x10\n\x06\x04G\x03\0\x04\0\x12\x06\xfd\x18\x04\x84\x19\x05\n\x0f\
    \n\x07\x04G\x03\0\x04\0\x01\x12\x04\xfd\x18\t\x12\n\x10\n\x08\x04G\x03\0\
    \x04\0\x02\0\x12\x04\xfe\x18\x06\x12\n\x11\n\t\x04G\x03\0\x04\0\x02\0\
    \x01\x12\x04\xfe\x18\x06\r\n\x11\n\t\x04G\x03\0\x04\0\x02\0\x02\x12\x04\
    \xfe\x18\x10\x11\n\x10\n\x08\x04G\x03\0\x04\0\x02\x01\x12\x04\xff\x18\
    \x06\x10\n\x11\n\t\x04G\x03\0\x04\0\x02\x01\x01\x12\x04\xff\x18\x06\x0b\
    \n\x11\n\t\x04G\x03\0\x04\0\x02\x01\x02\x12\x04\xff\x18\x0e\x0f\n\x10\n\
    \x08\x04G\x03\0\x04\0\x02\x02\x12\x04\x80\x19\x06\x0f\n\x11\n\t\x04G\x03\
    \0\x04\0\x02\x02\x01\x12\x04\x80\x19\x06\n\n\x11\n\t\x04G\x03\0\x04\0\
    \x02\x02\x02\x12\x04\x80\x19\r\x0e\n\x10\n\x08\x04G\x03\0\x04\0\x02\x03\
    \x12\x04\x81\x19\x06\x10\n\x11\n\t\x04G\x03\0\x04\0\x02\x03\x01\x12\x04\
    \x81\x19\x06\x0b\n\x11\n\t\x04G\x03\0\x04\0\x02\x03\x02\x12\x04\x81\x19\
    \x0e\x0f\n\x10\n\x08\x04G\x03\0\x04\0\x02\x04\x12\x04\x82\x19\x06\x0f\n\
    \x11\n\t\x04G\x03\0\x04\0\x02\x04\x01\x12\x04\x82\x19\x06\n\n\x11\n\t\
    \x04G\x03\0\x04\0\x02\x04\x02\x12\x04\x82\x19\r\x0e\n\x10\n\x08\x04G\x03\
    \0\x04\0\x02\x05\x12\x04\x83\x19\x06\x10\n\x11\n\t\x04G\x03\0\x04\0\x02\
    \x05\x01\x12\x04\x83\x19\x06\x0b\n\x11\n\t\x04G\x03\0\x04\0\x02\x05\x02\
    \x12\x04\x83\x19\x0e\x0f\nN\n\x06\x04G\x03\0\x03\0\x12\x06\x87\x19\x04\
    \x8a\x19\x05\x1a<\x20Describes\x20a\x20stat\x20value\x20without\x20the\
    \x20device\x20descriptor\x20part.\n\n\x0f\n\x07\x04G\x03\0\x03\0\x01\x12\
    \x04\x87\x19\x0c\x11\n\x1d\n\x08\x04G\x03\0\x03\0\x02\0\x12\x04\x88\x19\
    \x06\x20\"\x0b\x20Required.\n\n\x11\n\t\x04G\x03\0\x03\0\x02\0\x04\x12\
    \x04\x88\x19\x06\x0e\n\x11\n\t\x04G\x03\0\x03\0\x02\0\x06\x12\x04\x88\
    \x19\x0f\x18\n\x11\n\t\x04G\x03\0\x03\0\x02\0\x01\x12\x04\x88\x19\x19\
    \x1b\n\x11\n\t\x04G\x03\0\x03\0\x02\0\x03\x12\x04\x88\x19\x1e\x1f\n\x1d\
    \n\x08\x04G\x03\0\x03\0\x02\x01\x12\x04\x89\x19\x06\x20\"\x0b\x20Require\
    d.\n\n\x11\n\t\x04G\x03\0\x03\0\x02\x01\x04\x12\x04\x89\x19\x06\x0e\n\
    \x11\n\t\x04G\x03\0\x03\0\x02\x01\x05\x12\x04\x89\x19\x0f\x15\n\x11\n\t\
    \x04G\x03\0\x03\0\x02\x01\x01\x12\x04\x89\x19\x16\x1b\n\x11\n\t\x04G\x03\
    \0\x03\0\x02\x01\x03\x12\x04\x89\x19\x1e\x1f\n\x10\n\x06\x04G\x03\0\x03\
    \x01\x12\x06\x8c\x19\x04\xa5\x19\x05\n\x0f\n\x07\x04G\x03\0\x03\x01\x01\
    \x12\x04\x8c\x19\x0c\x0f\n\x12\n\x08\x04G\x03\0\x03\x01\x03\0\x12\x06\
    \x8d\x19\x06\xa1\x19\x07\n\x11\n\t\x04G\x03\0\x03\x01\x03\0\x01\x12\x04\
    \x8d\x19\x0e\x18\ni\n\n\x04G\x03\0\x03\x01\x03\0\x02\0\x12\x04\x90\x19\
    \x08*\x1aU\x20Stats\x20are\x20grouped\x20by\x20block\x20devices.\x20If\
    \x20`device`\x20is\x20not\n\x20set,\x20it\x20represents\x20`Total`.\n\n\
    \x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\0\x04\x12\x04\x90\x19\x08\x10\n\
    \x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\0\x06\x12\x04\x90\x19\x11\x1e\n\
    \x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\0\x01\x12\x04\x90\x19\x1f%\n\x13\
    \n\x0b\x04G\x03\0\x03\x01\x03\0\x02\0\x03\x12\x04\x90\x19()\n#\n\n\x04G\
    \x03\0\x03\x01\x03\0\x02\x01\x12\x04\x92\x19\x08$\x1a\x0f\x20blkio.secto\
    rs\n\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x01\x04\x12\x04\x92\x19\
    \x08\x10\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x01\x05\x12\x04\x92\
    \x19\x11\x17\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x01\x01\x12\x04\
    \x92\x19\x18\x1f\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x01\x03\x12\
    \x04\x92\x19\"#\n\x20\n\n\x04G\x03\0\x03\x01\x03\0\x02\x02\x12\x04\x94\
    \x19\x08!\x1a\x0c\x20blkio.time\n\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\
    \x02\x02\x04\x12\x04\x94\x19\x08\x10\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\
    \0\x02\x02\x05\x12\x04\x94\x19\x11\x17\n\x13\n\x0b\x04G\x03\0\x03\x01\
    \x03\0\x02\x02\x01\x12\x04\x94\x19\x18\x1c\n\x13\n\x0b\x04G\x03\0\x03\
    \x01\x03\0\x02\x02\x03\x12\x04\x94\x19\x1f\x20\n'\n\n\x04G\x03\0\x03\x01\
    \x03\0\x02\x03\x12\x04\x96\x19\x08'\x1a\x13\x20blkio.io_serviced\n\n\x13\
    \n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x03\x04\x12\x04\x96\x19\x08\x10\n\
    \x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x03\x06\x12\x04\x96\x19\x11\x16\
    \n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x03\x01\x12\x04\x96\x19\x17\"\
    \n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x03\x03\x12\x04\x96\x19%&\n,\n\
    \n\x04G\x03\0\x03\x01\x03\0\x02\x04\x12\x04\x98\x19\x08,\x1a\x18\x20blki\
    o.io_service_bytes\n\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x04\x04\
    \x12\x04\x98\x19\x08\x10\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x04\
    \x06\x12\x04\x98\x19\x11\x16\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\
    \x04\x01\x12\x04\x98\x19\x17'\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\
    \x04\x03\x12\x04\x98\x19*+\n+\n\n\x04G\x03\0\x03\x01\x03\0\x02\x05\x12\
    \x04\x9a\x19\x08+\x1a\x17\x20blkio.io_service_time\n\n\x13\n\x0b\x04G\
    \x03\0\x03\x01\x03\0\x02\x05\x04\x12\x04\x9a\x19\x08\x10\n\x13\n\x0b\x04\
    G\x03\0\x03\x01\x03\0\x02\x05\x06\x12\x04\x9a\x19\x11\x16\n\x13\n\x0b\
    \x04G\x03\0\x03\x01\x03\0\x02\x05\x01\x12\x04\x9a\x19\x17&\n\x13\n\x0b\
    \x04G\x03\0\x03\x01\x03\0\x02\x05\x03\x12\x04\x9a\x19)*\n(\n\n\x04G\x03\
    \0\x03\x01\x03\0\x02\x06\x12\x04\x9c\x19\x08(\x1a\x14\x20blkio.io_wait_t\
    ime\n\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x06\x04\x12\x04\x9c\x19\
    \x08\x10\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x06\x06\x12\x04\x9c\
    \x19\x11\x16\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x06\x01\x12\x04\
    \x9c\x19\x17#\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\x06\x03\x12\x04\
    \x9c\x19&'\n%\n\n\x04G\x03\0\x03\x01\x03\0\x02\x07\x12\x04\x9e\x19\x08%\
    \x1a\x11\x20blkio.io_merged\n\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\x02\
    \x07\x04\x12\x04\x9e\x19\x08\x10\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\0\
    \x02\x07\x06\x12\x04\x9e\x19\x11\x16\n\x13\n\x0b\x04G\x03\0\x03\x01\x03\
    \0\x02\x07\x01\x12\x04\x9e\x19\x17\x20\n\x13\n\x0b\x04G\x03\0\x03\x01\
    \x03\0\x02\x07\x03\x12\x04\x9e\x19#$\n%\n\n\x04G\x03\0\x03\x01\x03\0\x02\
    \x08\x12\x04\xa0\x19\x08%\x1a\x11\x20blkio.io_queued\n\n\x13\n\x0b\x04G\
    \x03\0\x03\x01\x03\0\x02\x08\x04\x12\x04\xa0\x19\x08\x10\n\x13\n\x0b\x04\
    G\x03\0\x03\x01\x03\0\x02\x08\x06\x12\x04\xa0\x19\x11\x16\n\x13\n\x0b\
    \x04G\x03\0\x03\x01\x03\0\x02\x08\x01\x12\x04\xa0\x19\x17\x20\n\x13\n\
    \x0b\x04G\x03\0\x03\x01\x03\0\x02\x08\x03\x12\x04\xa0\x19#$\n\x10\n\x06\
    \x04G\x03\0\x03\x02\x12\x06\xa7\x19\x04\xb3\x19\x05\n\x0f\n\x07\x04G\x03\
    \0\x03\x02\x01\x12\x04\xa7\x19\x0c\x16\n\x12\n\x08\x04G\x03\0\x03\x02\
    \x03\0\x12\x06\xa8\x19\x06\xb0\x19\x07\n\x11\n\t\x04G\x03\0\x03\x02\x03\
    \0\x01\x12\x04\xa8\x19\x0e\x18\ni\n\n\x04G\x03\0\x03\x02\x03\0\x02\0\x12\
    \x04\xab\x19\x08*\x1aU\x20Stats\x20are\x20grouped\x20by\x20block\x20devi\
    ces.\x20If\x20`device`\x20is\x20not\n\x20set,\x20it\x20represents\x20`To\
    tal`.\n\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\0\x04\x12\x04\xab\x19\
    \x08\x10\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\0\x06\x12\x04\xab\x19\
    \x11\x1e\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\0\x01\x12\x04\xab\x19\
    \x1f%\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\0\x03\x12\x04\xab\x19()\n\
    0\n\n\x04G\x03\0\x03\x02\x03\0\x02\x01\x12\x04\xad\x19\x08'\x1a\x1c\x20b\
    lkio.throttle.io_serviced\n\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\x01\
    \x04\x12\x04\xad\x19\x08\x10\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\
    \x01\x06\x12\x04\xad\x19\x11\x16\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\
    \x02\x01\x01\x12\x04\xad\x19\x17\"\n\x13\n\x0b\x04G\x03\0\x03\x02\x03\0\
    \x02\x01\x03\x12\x04\xad\x19%&\n5\n\n\x04G\x03\0\x03\x02\x03\0\x02\x02\
    \x12\x04\xaf\x19\x08,\x1a!\x20blkio.throttle.io_service_bytes\n\n\x13\n\
    \x0b\x04G\x03\0\x03\x02\x03\0\x02\x02\x04\x12\x04\xaf\x19\x08\x10\n\x13\
    \n\x0b\x04G\x03\0\x03\x02\x03\0\x02\x02\x06\x12\x04\xaf\x19\x11\x16\n\
    \x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\x02\x01\x12\x04\xaf\x19\x17'\n\
    \x13\n\x0b\x04G\x03\0\x03\x02\x03\0\x02\x02\x03\x12\x04\xaf\x19*+\n\x10\
    \n\x06\x04G\x03\0\x03\x03\x12\x06\xb5\x19\x04\xb9\x19\x05\n\x0f\n\x07\
    \x04G\x03\0\x03\x03\x01\x12\x04\xb5\x19\x0c\x16\n\x10\n\x08\x04G\x03\0\
    \x03\x03\x02\0\x12\x04\xb6\x19\x06&\n\x11\n\t\x04G\x03\0\x03\x03\x02\0\
    \x04\x12\x04\xb6\x19\x06\x0e\n\x11\n\t\x04G\x03\0\x03\x03\x02\0\x06\x12\
    \x04\xb6\x19\x0f\x1d\n\x11\n\t\x04G\x03\0\x03\x03\x02\0\x01\x12\x04\xb6\
    \x19\x1e!\n\x11\n\t\x04G\x03\0\x03\x03\x02\0\x03\x12\x04\xb6\x19$%\n\x10\
    \n\x08\x04G\x03\0\x03\x03\x02\x01\x12\x04\xb7\x19\x060\n\x11\n\t\x04G\
    \x03\0\x03\x03\x02\x01\x04\x12\x04\xb7\x19\x06\x0e\n\x11\n\t\x04G\x03\0\
    \x03\x03\x02\x01\x06\x12\x04\xb7\x19\x0f\x1d\n\x11\n\t\x04G\x03\0\x03\
    \x03\x02\x01\x01\x12\x04\xb7\x19\x1e+\n\x11\n\t\x04G\x03\0\x03\x03\x02\
    \x01\x03\x12\x04\xb7\x19./\n\x10\n\x08\x04G\x03\0\x03\x03\x02\x02\x12\
    \x04\xb8\x19\x064\n\x11\n\t\x04G\x03\0\x03\x03\x02\x02\x04\x12\x04\xb8\
    \x19\x06\x0e\n\x11\n\t\x04G\x03\0\x03\x03\x02\x02\x06\x12\x04\xb8\x19\
    \x0f$\n\x11\n\t\x04G\x03\0\x03\x03\x02\x02\x01\x12\x04\xb8\x19%/\n\x11\n\
    \t\x04G\x03\0\x03\x03\x02\x02\x03\x12\x04\xb8\x1923\n>\n\x04\x04G\x03\
    \x01\x12\x06\xbd\x19\x02\xc3\x19\x03\x1a.\x20Configuration\x20of\x20a\
    \x20net_cls\x20cgroup\x20subsystem.\n\n\r\n\x05\x04G\x03\x01\x01\x12\x04\
    \xbd\x19\n\x10\n\x87\x02\n\x06\x04G\x03\x01\x02\0\x12\x04\xc2\x19\x04\
    \x20\x1a\xf6\x01\x20The\x2032-bit\x20classid\x20consists\x20of\x20two\
    \x20parts,\x20a\x2016\x20bit\x20major\x20handle\n\x20and\x20a\x2016-bit\
    \x20minor\x20handle.\x20The\x20major\x20and\x20minor\x20handle\x20are\n\
    \x20represented\x20using\x20the\x20format\x200xAAAABBBB,\x20where\x200xA\
    AAA\x20is\x20the\n\x2016-bit\x20major\x20handle\x20and\x200xBBBB\x20is\
    \x20the\x2016-bit\x20minor\x20handle.\n\n\x0f\n\x07\x04G\x03\x01\x02\0\
    \x04\x12\x04\xc2\x19\x04\x0c\n\x0f\n\x07\x04G\x03\x01\x02\0\x05\x12\x04\
    \xc2\x19\r\x13\n\x0f\n\x07\x04G\x03\x01\x02\0\x01\x12\x04\xc2\x19\x14\
    \x1b\n\x0f\n\x07\x04G\x03\x01\x02\0\x03\x12\x04\xc2\x19\x1e\x1f\n\x0c\n\
    \x04\x04G\x02\0\x12\x04\xc5\x19\x02\x1e\n\r\n\x05\x04G\x02\0\x04\x12\x04\
    \xc5\x19\x02\n\n\r\n\x05\x04G\x02\0\x06\x12\x04\xc5\x19\x0b\x11\n\r\n\
    \x05\x04G\x02\0\x01\x12\x04\xc5\x19\x12\x19\n\r\n\x05\x04G\x02\0\x03\x12\
    \x04\xc5\x19\x1c\x1d\n]\n\x02\x04H\x12\x06\xcd\x19\0\xcf\x19\x01\x1aO*\n\
    \x20Collection\x20of\x20labels.\x20Labels\x20should\x20not\x20contain\
    \x20duplicate\x20key-value\n\x20pairs.\n\n\x0b\n\x03\x04H\x01\x12\x04\
    \xcd\x19\x08\x0e\n\x0c\n\x04\x04H\x02\0\x12\x04\xce\x19\x02\x1c\n\r\n\
    \x05\x04H\x02\0\x04\x12\x04\xce\x19\x02\n\n\r\n\x05\x04H\x02\0\x06\x12\
    \x04\xce\x19\x0b\x10\n\r\n\x05\x04H\x02\0\x01\x12\x04\xce\x19\x11\x17\n\
    \r\n\x05\x04H\x02\0\x03\x12\x04\xce\x19\x1a\x1b\nD\n\x02\x04I\x12\x06\
    \xd5\x19\0\xd8\x19\x01\x1a6*\n\x20Key,\x20value\x20pair\x20used\x20to\
    \x20store\x20free\x20form\x20user-data.\n\n\x0b\n\x03\x04I\x01\x12\x04\
    \xd5\x19\x08\r\n\x0c\n\x04\x04I\x02\0\x12\x04\xd6\x19\x02\x1a\n\r\n\x05\
    \x04I\x02\0\x04\x12\x04\xd6\x19\x02\n\n\r\n\x05\x04I\x02\0\x05\x12\x04\
    \xd6\x19\x0b\x11\n\r\n\x05\x04I\x02\0\x01\x12\x04\xd6\x19\x12\x15\n\r\n\
    \x05\x04I\x02\0\x03\x12\x04\xd6\x19\x18\x19\n\x0c\n\x04\x04I\x02\x01\x12\
    \x04\xd7\x19\x02\x1c\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xd7\x19\x02\n\n\
    \r\n\x05\x04I\x02\x01\x05\x12\x04\xd7\x19\x0b\x11\n\r\n\x05\x04I\x02\x01\
    \x01\x12\x04\xd7\x19\x12\x17\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xd7\x19\
    \x1a\x1b\n8\n\x02\x04J\x12\x06\xde\x19\0\xf1\x19\x01\x1a**\n\x20Named\
    \x20port\x20used\x20for\x20service\x20discovery.\n\n\x0b\n\x03\x04J\x01\
    \x12\x04\xde\x19\x08\x0c\nE\n\x04\x04J\x02\0\x12\x04\xe0\x19\x02\x1d\x1a\
    7\x20Port\x20number\x20on\x20which\x20the\x20framework\x20exposes\x20a\
    \x20service.\n\n\r\n\x05\x04J\x02\0\x04\x12\x04\xe0\x19\x02\n\n\r\n\x05\
    \x04J\x02\0\x05\x12\x04\xe0\x19\x0b\x11\n\r\n\x05\x04J\x02\0\x01\x12\x04\
    \xe0\x19\x12\x18\n\r\n\x05\x04J\x02\0\x03\x12\x04\xe0\x19\x1b\x1c\n8\n\
    \x04\x04J\x02\x01\x12\x04\xe3\x19\x02\x1b\x1a*\x20Name\x20of\x20the\x20s\
    ervice\x20hosted\x20on\x20this\x20port.\n\n\r\n\x05\x04J\x02\x01\x04\x12\
    \x04\xe3\x19\x02\n\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xe3\x19\x0b\x11\n\
    \r\n\x05\x04J\x02\x01\x01\x12\x04\xe3\x19\x12\x16\n\r\n\x05\x04J\x02\x01\
    \x03\x12\x04\xe3\x19\x19\x1a\nO\n\x04\x04J\x02\x02\x12\x04\xe6\x19\x02\
    \x1f\x1aA\x20Layer\x204-7\x20protocol\x20on\x20which\x20the\x20framework\
    \x20exposes\x20its\x20services.\n\n\r\n\x05\x04J\x02\x02\x04\x12\x04\xe6\
    \x19\x02\n\n\r\n\x05\x04J\x02\x02\x05\x12\x04\xe6\x19\x0b\x11\n\r\n\x05\
    \x04J\x02\x02\x01\x12\x04\xe6\x19\x12\x1a\n\r\n\x05\x04J\x02\x02\x03\x12\
    \x04\xe6\x19\x1d\x1e\n\xfb\x01\n\x04\x04J\x02\x03\x12\x04\xec\x19\x023\
    \x1a\xec\x01\x20This\x20field\x20restricts\x20discovery\x20within\x20a\
    \x20framework\x20(FRAMEWORK),\n\x20within\x20a\x20Mesos\x20cluster\x20(C\
    LUSTER),\x20or\x20places\x20no\x20restrictions\x20(EXTERNAL).\n\x20The\
    \x20visibility\x20setting\x20for\x20a\x20Port\x20overrides\x20the\x20gen\
    eral\x20visibility\x20setting\n\x20in\x20the\x20DiscoveryInfo.\n\n\r\n\
    \x05\x04J\x02\x03\x04\x12\x04\xec\x19\x02\n\n\r\n\x05\x04J\x02\x03\x06\
    \x12\x04\xec\x19\x0b#\n\r\n\x05\x04J\x02\x03\x01\x12\x04\xec\x19$.\n\r\n\
    \x05\x04J\x02\x03\x03\x12\x04\xec\x1912\n\x85\x01\n\x04\x04J\x02\x04\x12\
    \x04\xf0\x19\x02\x1d\x1aw\x20This\x20can\x20be\x20used\x20to\x20decorate\
    \x20the\x20message\x20with\x20metadata\x20to\x20be\n\x20interpreted\x20b\
    y\x20external\x20applications\x20such\x20as\x20firewalls.\n\n\r\n\x05\
    \x04J\x02\x04\x04\x12\x04\xf0\x19\x02\n\n\r\n\x05\x04J\x02\x04\x06\x12\
    \x04\xf0\x19\x0b\x11\n\r\n\x05\x04J\x02\x04\x01\x12\x04\xf0\x19\x12\x18\
    \n\r\n\x05\x04J\x02\x04\x03\x12\x04\xf0\x19\x1b\x1c\n&\n\x02\x04K\x12\
    \x06\xf7\x19\0\xf9\x19\x01\x1a\x18*\n\x20Collection\x20of\x20ports.\n\n\
    \x0b\n\x03\x04K\x01\x12\x04\xf7\x19\x08\r\n\x0c\n\x04\x04K\x02\0\x12\x04\
    \xf8\x19\x02\x1a\n\r\n\x05\x04K\x02\0\x04\x12\x04\xf8\x19\x02\n\n\r\n\
    \x05\x04K\x02\0\x06\x12\x04\xf8\x19\x0b\x0f\n\r\n\x05\x04K\x02\0\x01\x12\
    \x04\xf8\x19\x10\x15\n\r\n\x05\x04K\x02\0\x03\x12\x04\xf8\x19\x18\x19\n\
    \x95\x06\n\x02\x04L\x12\x06\x8a\x1a\0\x98\x1a\x01\x1a\x86\x06*\n\x20Serv\
    ice\x20discovery\x20information.\n\x20The\x20visibility\x20field\x20rest\
    ricts\x20discovery\x20within\x20a\x20framework\x20(FRAMEWORK),\n\x20with\
    in\x20a\x20Mesos\x20cluster\x20(CLUSTER),\x20or\x20places\x20no\x20restr\
    ictions\x20(EXTERNAL).\n\x20Each\x20port\x20in\x20the\x20ports\x20field\
    \x20also\x20has\x20an\x20optional\x20visibility\x20field.\n\x20If\x20vis\
    ibility\x20is\x20specified\x20for\x20a\x20port,\x20it\x20overrides\x20th\
    e\x20default\x20service-wide\n\x20DiscoveryInfo.visibility\x20for\x20tha\
    t\x20port.\n\x20The\x20environment,\x20location,\x20and\x20version\x20fi\
    elds\x20provide\x20first\x20class\x20support\x20for\n\x20common\x20attri\
    butes\x20used\x20to\x20differentiate\x20between\x20similar\x20services.\
    \x20The\n\x20environment\x20may\x20receive\x20values\x20such\x20as\x20PR\
    OD/QA/DEV,\x20the\x20location\x20field\x20may\n\x20receive\x20values\x20\
    like\x20EAST-US/WEST-US/EUROPE/AMEA,\x20and\x20the\x20version\x20field\
    \x20may\n\x20receive\x20values\x20like\x20v2.0/v0.9.\x20The\x20exact\x20\
    use\x20of\x20these\x20fields\x20is\x20up\x20to\x20each\n\x20service\x20d\
    iscovery\x20system.\n\n\x0b\n\x03\x04L\x01\x12\x04\x8a\x1a\x08\x15\n\x0e\
    \n\x04\x04L\x04\0\x12\x06\x8b\x1a\x02\x8f\x1a\x03\n\r\n\x05\x04L\x04\0\
    \x01\x12\x04\x8b\x1a\x07\x11\n\x0e\n\x06\x04L\x04\0\x02\0\x12\x04\x8c\
    \x1a\x04\x12\n\x0f\n\x07\x04L\x04\0\x02\0\x01\x12\x04\x8c\x1a\x04\r\n\
    \x0f\n\x07\x04L\x04\0\x02\0\x02\x12\x04\x8c\x1a\x10\x11\n\x0e\n\x06\x04L\
    \x04\0\x02\x01\x12\x04\x8d\x1a\x04\x10\n\x0f\n\x07\x04L\x04\0\x02\x01\
    \x01\x12\x04\x8d\x1a\x04\x0b\n\x0f\n\x07\x04L\x04\0\x02\x01\x02\x12\x04\
    \x8d\x1a\x0e\x0f\n\x0e\n\x06\x04L\x04\0\x02\x02\x12\x04\x8e\x1a\x04\x11\
    \n\x0f\n\x07\x04L\x04\0\x02\x02\x01\x12\x04\x8e\x1a\x04\x0c\n\x0f\n\x07\
    \x04L\x04\0\x02\x02\x02\x12\x04\x8e\x1a\x0f\x10\n\x0c\n\x04\x04L\x02\0\
    \x12\x04\x91\x1a\x02%\n\r\n\x05\x04L\x02\0\x04\x12\x04\x91\x1a\x02\n\n\r\
    \n\x05\x04L\x02\0\x06\x12\x04\x91\x1a\x0b\x15\n\r\n\x05\x04L\x02\0\x01\
    \x12\x04\x91\x1a\x16\x20\n\r\n\x05\x04L\x02\0\x03\x12\x04\x91\x1a#$\n\
    \x0c\n\x04\x04L\x02\x01\x12\x04\x92\x1a\x02\x1b\n\r\n\x05\x04L\x02\x01\
    \x04\x12\x04\x92\x1a\x02\n\n\r\n\x05\x04L\x02\x01\x05\x12\x04\x92\x1a\
    \x0b\x11\n\r\n\x05\x04L\x02\x01\x01\x12\x04\x92\x1a\x12\x16\n\r\n\x05\
    \x04L\x02\x01\x03\x12\x04\x92\x1a\x19\x1a\n\x0c\n\x04\x04L\x02\x02\x12\
    \x04\x93\x1a\x02\"\n\r\n\x05\x04L\x02\x02\x04\x12\x04\x93\x1a\x02\n\n\r\
    \n\x05\x04L\x02\x02\x05\x12\x04\x93\x1a\x0b\x11\n\r\n\x05\x04L\x02\x02\
    \x01\x12\x04\x93\x1a\x12\x1d\n\r\n\x05\x04L\x02\x02\x03\x12\x04\x93\x1a\
    \x20!\n\x0c\n\x04\x04L\x02\x03\x12\x04\x94\x1a\x02\x1f\n\r\n\x05\x04L\
    \x02\x03\x04\x12\x04\x94\x1a\x02\n\n\r\n\x05\x04L\x02\x03\x05\x12\x04\
    \x94\x1a\x0b\x11\n\r\n\x05\x04L\x02\x03\x01\x12\x04\x94\x1a\x12\x1a\n\r\
    \n\x05\x04L\x02\x03\x03\x12\x04\x94\x1a\x1d\x1e\n\x0c\n\x04\x04L\x02\x04\
    \x12\x04\x95\x1a\x02\x1e\n\r\n\x05\x04L\x02\x04\x04\x12\x04\x95\x1a\x02\
    \n\n\r\n\x05\x04L\x02\x04\x05\x12\x04\x95\x1a\x0b\x11\n\r\n\x05\x04L\x02\
    \x04\x01\x12\x04\x95\x1a\x12\x19\n\r\n\x05\x04L\x02\x04\x03\x12\x04\x95\
    \x1a\x1c\x1d\n\x0c\n\x04\x04L\x02\x05\x12\x04\x96\x1a\x02\x1b\n\r\n\x05\
    \x04L\x02\x05\x04\x12\x04\x96\x1a\x02\n\n\r\n\x05\x04L\x02\x05\x06\x12\
    \x04\x96\x1a\x0b\x10\n\r\n\x05\x04L\x02\x05\x01\x12\x04\x96\x1a\x11\x16\
    \n\r\n\x05\x04L\x02\x05\x03\x12\x04\x96\x1a\x19\x1a\n\x0c\n\x04\x04L\x02\
    \x06\x12\x04\x97\x1a\x02\x1d\n\r\n\x05\x04L\x02\x06\x04\x12\x04\x97\x1a\
    \x02\n\n\r\n\x05\x04L\x02\x06\x06\x12\x04\x97\x1a\x0b\x11\n\r\n\x05\x04L\
    \x02\x06\x01\x12\x04\x97\x1a\x12\x18\n\r\n\x05\x04L\x02\x06\x03\x12\x04\
    \x97\x1a\x1b\x1c\ni\n\x02\x04M\x12\x06\x9f\x1a\0\xa4\x1a\x01\x1a[*\n\x20\
    Named\x20WeightInfo\x20to\x20indicate\x20resource\x20allocation\n\x20pri\
    ority\x20between\x20the\x20different\x20roles.\n\n\x0b\n\x03\x04M\x01\
    \x12\x04\x9f\x1a\x08\x12\n\x0c\n\x04\x04M\x02\0\x12\x04\xa0\x1a\x02\x1d\
    \n\r\n\x05\x04M\x02\0\x04\x12\x04\xa0\x1a\x02\n\n\r\n\x05\x04M\x02\0\x05\
    \x12\x04\xa0\x1a\x0b\x11\n\r\n\x05\x04M\x02\0\x01\x12\x04\xa0\x1a\x12\
    \x18\n\r\n\x05\x04M\x02\0\x03\x12\x04\xa0\x1a\x1b\x1c\n\"\n\x04\x04M\x02\
    \x01\x12\x04\xa3\x1a\x02\x1b\x1a\x14\x20Related\x20role\x20name.\n\n\r\n\
    \x05\x04M\x02\x01\x04\x12\x04\xa3\x1a\x02\n\n\r\n\x05\x04M\x02\x01\x05\
    \x12\x04\xa3\x1a\x0b\x11\n\r\n\x05\x04M\x02\x01\x01\x12\x04\xa3\x1a\x12\
    \x16\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xa3\x1a\x19\x1a\n5\n\x02\x04N\
    \x12\x06\xaa\x1a\0\xb2\x1a\x01\x1a'*\n\x20Version\x20information\x20of\
    \x20a\x20component.\n\n\x0b\n\x03\x04N\x01\x12\x04\xaa\x1a\x08\x13\n\x0c\
    \n\x04\x04N\x02\0\x12\x04\xab\x1a\x02\x1e\n\r\n\x05\x04N\x02\0\x04\x12\
    \x04\xab\x1a\x02\n\n\r\n\x05\x04N\x02\0\x05\x12\x04\xab\x1a\x0b\x11\n\r\
    \n\x05\x04N\x02\0\x01\x12\x04\xab\x1a\x12\x19\n\r\n\x05\x04N\x02\0\x03\
    \x12\x04\xab\x1a\x1c\x1d\n\x0c\n\x04\x04N\x02\x01\x12\x04\xac\x1a\x02!\n\
    \r\n\x05\x04N\x02\x01\x04\x12\x04\xac\x1a\x02\n\n\r\n\x05\x04N\x02\x01\
    \x05\x12\x04\xac\x1a\x0b\x11\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xac\x1a\
    \x12\x1c\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xac\x1a\x1f\x20\n\x0c\n\x04\
    \x04N\x02\x02\x12\x04\xad\x1a\x02!\n\r\n\x05\x04N\x02\x02\x04\x12\x04\
    \xad\x1a\x02\n\n\r\n\x05\x04N\x02\x02\x05\x12\x04\xad\x1a\x0b\x11\n\r\n\
    \x05\x04N\x02\x02\x01\x12\x04\xad\x1a\x12\x1c\n\r\n\x05\x04N\x02\x02\x03\
    \x12\x04\xad\x1a\x1f\x20\n\x0c\n\x04\x04N\x02\x03\x12\x04\xae\x1a\x02!\n\
    \r\n\x05\x04N\x02\x03\x04\x12\x04\xae\x1a\x02\n\n\r\n\x05\x04N\x02\x03\
    \x05\x12\x04\xae\x1a\x0b\x11\n\r\n\x05\x04N\x02\x03\x01\x12\x04\xae\x1a\
    \x12\x1c\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xae\x1a\x1f\x20\n\x0c\n\x04\
    \x04N\x02\x04\x12\x04\xaf\x1a\x02\x1e\n\r\n\x05\x04N\x02\x04\x04\x12\x04\
    \xaf\x1a\x02\n\n\r\n\x05\x04N\x02\x04\x05\x12\x04\xaf\x1a\x0b\x11\n\r\n\
    \x05\x04N\x02\x04\x01\x12\x04\xaf\x1a\x12\x19\n\r\n\x05\x04N\x02\x04\x03\
    \x12\x04\xaf\x1a\x1c\x1d\n\x0c\n\x04\x04N\x02\x05\x12\x04\xb0\x1a\x02!\n\
    \r\n\x05\x04N\x02\x05\x04\x12\x04\xb0\x1a\x02\n\n\r\n\x05\x04N\x02\x05\
    \x05\x12\x04\xb0\x1a\x0b\x11\n\r\n\x05\x04N\x02\x05\x01\x12\x04\xb0\x1a\
    \x12\x1c\n\r\n\x05\x04N\x02\x05\x03\x12\x04\xb0\x1a\x1f\x20\n\x0c\n\x04\
    \x04N\x02\x06\x12\x04\xb1\x1a\x02\x1e\n\r\n\x05\x04N\x02\x06\x04\x12\x04\
    \xb1\x1a\x02\n\n\r\n\x05\x04N\x02\x06\x05\x12\x04\xb1\x1a\x0b\x11\n\r\n\
    \x05\x04N\x02\x06\x01\x12\x04\xb1\x1a\x12\x19\n\r\n\x05\x04N\x02\x06\x03\
    \x12\x04\xb1\x1a\x1c\x1d\nC\n\x02\x04O\x12\x06\xb8\x1a\0\xbb\x1a\x01\x1a\
    5*\n\x20Flag\x20consists\x20of\x20a\x20name\x20and\x20optionally\x20its\
    \x20value.\n\n\x0b\n\x03\x04O\x01\x12\x04\xb8\x1a\x08\x0c\n\x0c\n\x04\
    \x04O\x02\0\x12\x04\xb9\x1a\x02\x1b\n\r\n\x05\x04O\x02\0\x04\x12\x04\xb9\
    \x1a\x02\n\n\r\n\x05\x04O\x02\0\x05\x12\x04\xb9\x1a\x0b\x11\n\r\n\x05\
    \x04O\x02\0\x01\x12\x04\xb9\x1a\x12\x16\n\r\n\x05\x04O\x02\0\x03\x12\x04\
    \xb9\x1a\x19\x1a\n\x0c\n\x04\x04O\x02\x01\x12\x04\xba\x1a\x02\x1c\n\r\n\
    \x05\x04O\x02\x01\x04\x12\x04\xba\x1a\x02\n\n\r\n\x05\x04O\x02\x01\x05\
    \x12\x04\xba\x1a\x0b\x11\n\r\n\x05\x04O\x02\x01\x01\x12\x04\xba\x1a\x12\
    \x17\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xba\x1a\x1a\x1b\n\x8c\x01\n\x02\
    \x04P\x12\x06\xc2\x1a\0\xc7\x1a\x01\x1a~*\n\x20Describes\x20a\x20Role.\
    \x20Roles\x20can\x20be\x20used\x20to\x20specify\x20that\x20certain\x20re\
    sources\x20are\n\x20reserved\x20for\x20the\x20use\x20of\x20one\x20or\x20\
    more\x20frameworks.\n\n\x0b\n\x03\x04P\x01\x12\x04\xc2\x1a\x08\x0c\n\x0c\
    \n\x04\x04P\x02\0\x12\x04\xc3\x1a\x02\x1b\n\r\n\x05\x04P\x02\0\x04\x12\
    \x04\xc3\x1a\x02\n\n\r\n\x05\x04P\x02\0\x05\x12\x04\xc3\x1a\x0b\x11\n\r\
    \n\x05\x04P\x02\0\x01\x12\x04\xc3\x1a\x12\x16\n\r\n\x05\x04P\x02\0\x03\
    \x12\x04\xc3\x1a\x19\x1a\n\x0c\n\x04\x04P\x02\x01\x12\x04\xc4\x1a\x02\
    \x1d\n\r\n\x05\x04P\x02\x01\x04\x12\x04\xc4\x1a\x02\n\n\r\n\x05\x04P\x02\
    \x01\x05\x12\x04\xc4\x1a\x0b\x11\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xc4\
    \x1a\x12\x18\n\r\n\x05\x04P\x02\x01\x03\x12\x04\xc4\x1a\x1b\x1c\n\x0c\n\
    \x04\x04P\x02\x02\x12\x04\xc5\x1a\x02&\n\r\n\x05\x04P\x02\x02\x04\x12\
    \x04\xc5\x1a\x02\n\n\r\n\x05\x04P\x02\x02\x06\x12\x04\xc5\x1a\x0b\x16\n\
    \r\n\x05\x04P\x02\x02\x01\x12\x04\xc5\x1a\x17!\n\r\n\x05\x04P\x02\x02\
    \x03\x12\x04\xc5\x1a$%\n\x0c\n\x04\x04P\x02\x03\x12\x04\xc6\x1a\x02\"\n\
    \r\n\x05\x04P\x02\x03\x04\x12\x04\xc6\x1a\x02\n\n\r\n\x05\x04P\x02\x03\
    \x06\x12\x04\xc6\x1a\x0b\x13\n\r\n\x05\x04P\x02\x03\x01\x12\x04\xc6\x1a\
    \x14\x1d\n\r\n\x05\x04P\x02\x03\x03\x12\x04\xc6\x1a\x20!\nE\n\x02\x04Q\
    \x12\x06\xcd\x1a\0\xd0\x1a\x01\x1a7*\n\x20Metric\x20consists\x20of\x20a\
    \x20name\x20and\x20optionally\x20its\x20value.\n\n\x0b\n\x03\x04Q\x01\
    \x12\x04\xcd\x1a\x08\x0e\n\x0c\n\x04\x04Q\x02\0\x12\x04\xce\x1a\x02\x1b\
    \n\r\n\x05\x04Q\x02\0\x04\x12\x04\xce\x1a\x02\n\n\r\n\x05\x04Q\x02\0\x05\
    \x12\x04\xce\x1a\x0b\x11\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xce\x1a\x12\
    \x16\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xce\x1a\x19\x1a\n\x0c\n\x04\x04Q\
    \x02\x01\x12\x04\xcf\x1a\x02\x1c\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xcf\
    \x1a\x02\n\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\xcf\x1a\x0b\x11\n\r\n\x05\
    \x04Q\x02\x01\x01\x12\x04\xcf\x1a\x12\x17\n\r\n\x05\x04Q\x02\x01\x03\x12\
    \x04\xcf\x1a\x1a\x1b\n#\n\x02\x04R\x12\x06\xd6\x1a\0\xec\x1a\x01\x1a\x15\
    *\n\x20Describes\x20a\x20File.\n\n\x0b\n\x03\x04R\x01\x12\x04\xd6\x1a\
    \x08\x10\n*\n\x04\x04R\x02\0\x12\x04\xd8\x1a\x02\x1b\x1a\x1c\x20Absolute\
    \x20path\x20to\x20the\x20file.\n\n\r\n\x05\x04R\x02\0\x04\x12\x04\xd8\
    \x1a\x02\n\n\r\n\x05\x04R\x02\0\x05\x12\x04\xd8\x1a\x0b\x11\n\r\n\x05\
    \x04R\x02\0\x01\x12\x04\xd8\x1a\x12\x16\n\r\n\x05\x04R\x02\0\x03\x12\x04\
    \xd8\x1a\x19\x1a\n%\n\x04\x04R\x02\x01\x12\x04\xdb\x1a\x02\x1b\x1a\x17\
    \x20Number\x20of\x20hard\x20links.\n\n\r\n\x05\x04R\x02\x01\x04\x12\x04\
    \xdb\x1a\x02\n\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xdb\x1a\x0b\x10\n\r\n\
    \x05\x04R\x02\x01\x01\x12\x04\xdb\x1a\x11\x16\n\r\n\x05\x04R\x02\x01\x03\
    \x12\x04\xdb\x1a\x19\x1a\n$\n\x04\x04R\x02\x02\x12\x04\xde\x1a\x02\x1b\
    \x1a\x16\x20Total\x20size\x20in\x20bytes.\n\n\r\n\x05\x04R\x02\x02\x04\
    \x12\x04\xde\x1a\x02\n\n\r\n\x05\x04R\x02\x02\x05\x12\x04\xde\x1a\x0b\
    \x11\n\r\n\x05\x04R\x02\x02\x01\x12\x04\xde\x1a\x12\x16\n\r\n\x05\x04R\
    \x02\x02\x03\x12\x04\xde\x1a\x19\x1a\n'\n\x04\x04R\x02\x03\x12\x04\xe1\
    \x1a\x02\x1e\x1a\x19\x20Last\x20modification\x20time.\n\n\r\n\x05\x04R\
    \x02\x03\x04\x12\x04\xe1\x1a\x02\n\n\r\n\x05\x04R\x02\x03\x06\x12\x04\
    \xe1\x1a\x0b\x13\n\r\n\x05\x04R\x02\x03\x01\x12\x04\xe1\x1a\x14\x19\n\r\
    \n\x05\x04R\x02\x03\x03\x12\x04\xe1\x1a\x1c\x1d\n\x80\x01\n\x04\x04R\x02\
    \x04\x12\x04\xe5\x1a\x02\x1b\x1ar\x20Represents\x20a\x20file's\x20mode\
    \x20and\x20permission\x20bits.\x20The\x20bits\x20have\x20the\x20same\n\
    \x20definition\x20on\x20all\x20systems\x20and\x20is\x20portable.\n\n\r\n\
    \x05\x04R\x02\x04\x04\x12\x04\xe5\x1a\x02\n\n\r\n\x05\x04R\x02\x04\x05\
    \x12\x04\xe5\x1a\x0b\x11\n\r\n\x05\x04R\x02\x04\x01\x12\x04\xe5\x1a\x12\
    \x16\n\r\n\x05\x04R\x02\x04\x03\x12\x04\xe5\x1a\x19\x1a\n!\n\x04\x04R\
    \x02\x05\x12\x04\xe8\x1a\x02\x1a\x1a\x13\x20User\x20ID\x20of\x20owner.\n\
    \n\r\n\x05\x04R\x02\x05\x04\x12\x04\xe8\x1a\x02\n\n\r\n\x05\x04R\x02\x05\
    \x05\x12\x04\xe8\x1a\x0b\x11\n\r\n\x05\x04R\x02\x05\x01\x12\x04\xe8\x1a\
    \x12\x15\n\r\n\x05\x04R\x02\x05\x03\x12\x04\xe8\x1a\x18\x19\n\"\n\x04\
    \x04R\x02\x06\x12\x04\xeb\x1a\x02\x1a\x1a\x14\x20Group\x20ID\x20of\x20ow\
    ner.\n\n\r\n\x05\x04R\x02\x06\x04\x12\x04\xeb\x1a\x02\n\n\r\n\x05\x04R\
    \x02\x06\x05\x12\x04\xeb\x1a\x0b\x11\n\r\n\x05\x04R\x02\x06\x01\x12\x04\
    \xeb\x1a\x12\x15\n\r\n\x05\x04R\x02\x06\x03\x12\x04\xeb\x1a\x18\x19\n8\n\
    \x02\x04S\x12\x06\xf2\x1a\0\xfa\x1a\x01\x1a**\n\x20Describes\x20informat\
    ion\x20abount\x20a\x20device.\n\n\x0b\n\x03\x04S\x01\x12\x04\xf2\x1a\x08\
    \x0e\n\x0e\n\x04\x04S\x03\0\x12\x06\xf3\x1a\x02\xf6\x1a\x03\n\r\n\x05\
    \x04S\x03\0\x01\x12\x04\xf3\x1a\n\x10\n\x0e\n\x06\x04S\x03\0\x02\0\x12\
    \x04\xf4\x1a\x04%\n\x0f\n\x07\x04S\x03\0\x02\0\x04\x12\x04\xf4\x1a\x04\
    \x0c\n\x0f\n\x07\x04S\x03\0\x02\0\x05\x12\x04\xf4\x1a\r\x13\n\x0f\n\x07\
    \x04S\x03\0\x02\0\x01\x12\x04\xf4\x1a\x14\x20\n\x0f\n\x07\x04S\x03\0\x02\
    \0\x03\x12\x04\xf4\x1a#$\n\x0e\n\x06\x04S\x03\0\x02\x01\x12\x04\xf5\x1a\
    \x04%\n\x0f\n\x07\x04S\x03\0\x02\x01\x04\x12\x04\xf5\x1a\x04\x0c\n\x0f\n\
    \x07\x04S\x03\0\x02\x01\x05\x12\x04\xf5\x1a\r\x13\n\x0f\n\x07\x04S\x03\0\
    \x02\x01\x01\x12\x04\xf5\x1a\x14\x20\n\x0f\n\x07\x04S\x03\0\x02\x01\x03\
    \x12\x04\xf5\x1a#$\n\x0c\n\x04\x04S\x02\0\x12\x04\xf8\x1a\x02\x1b\n\r\n\
    \x05\x04S\x02\0\x04\x12\x04\xf8\x1a\x02\n\n\r\n\x05\x04S\x02\0\x05\x12\
    \x04\xf8\x1a\x0b\x11\n\r\n\x05\x04S\x02\0\x01\x12\x04\xf8\x1a\x12\x16\n\
    \r\n\x05\x04S\x02\0\x03\x12\x04\xf8\x1a\x19\x1a\n\x0c\n\x04\x04S\x02\x01\
    \x12\x04\xf9\x1a\x02\x1d\n\r\n\x05\x04S\x02\x01\x04\x12\x04\xf9\x1a\x02\
    \n\n\r\n\x05\x04S\x02\x01\x06\x12\x04\xf9\x1a\x0b\x11\n\r\n\x05\x04S\x02\
    \x01\x01\x12\x04\xf9\x1a\x12\x18\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xf9\
    \x1a\x1b\x1c\nX\n\x02\x04T\x12\x06\x80\x1b\0\x88\x1b\x01\x1aJ*\n\x20Desc\
    ribes\x20a\x20device\x20whitelist\x20entry\x20that\x20expose\x20from\x20\
    host\x20to\x20container.\n\n\x0b\n\x03\x04T\x01\x12\x04\x80\x1b\x08\x14\
    \n\x0e\n\x04\x04T\x03\0\x12\x06\x81\x1b\x02\x85\x1b\x03\n\r\n\x05\x04T\
    \x03\0\x01\x12\x04\x81\x1b\n\x10\n\x0e\n\x06\x04T\x03\0\x02\0\x12\x04\
    \x82\x1b\x04\x1b\n\x0f\n\x07\x04T\x03\0\x02\0\x04\x12\x04\x82\x1b\x04\
    \x0c\n\x0f\n\x07\x04T\x03\0\x02\0\x05\x12\x04\x82\x1b\r\x11\n\x0f\n\x07\
    \x04T\x03\0\x02\0\x01\x12\x04\x82\x1b\x12\x16\n\x0f\n\x07\x04T\x03\0\x02\
    \0\x03\x12\x04\x82\x1b\x19\x1a\n\x0e\n\x06\x04T\x03\0\x02\x01\x12\x04\
    \x83\x1b\x04\x1c\n\x0f\n\x07\x04T\x03\0\x02\x01\x04\x12\x04\x83\x1b\x04\
    \x0c\n\x0f\n\x07\x04T\x03\0\x02\x01\x05\x12\x04\x83\x1b\r\x11\n\x0f\n\
    \x07\x04T\x03\0\x02\x01\x01\x12\x04\x83\x1b\x12\x17\n\x0f\n\x07\x04T\x03\
    \0\x02\x01\x03\x12\x04\x83\x1b\x1a\x1b\n\x0e\n\x06\x04T\x03\0\x02\x02\
    \x12\x04\x84\x1b\x04\x1c\n\x0f\n\x07\x04T\x03\0\x02\x02\x04\x12\x04\x84\
    \x1b\x04\x0c\n\x0f\n\x07\x04T\x03\0\x02\x02\x05\x12\x04\x84\x1b\r\x11\n\
    \x0f\n\x07\x04T\x03\0\x02\x02\x01\x12\x04\x84\x1b\x12\x17\n\x0f\n\x07\
    \x04T\x03\0\x02\x02\x03\x12\x04\x84\x1b\x1a\x1b\n\x0c\n\x04\x04T\x02\0\
    \x12\x04\x86\x1b\x02\x1d\n\r\n\x05\x04T\x02\0\x04\x12\x04\x86\x1b\x02\n\
    \n\r\n\x05\x04T\x02\0\x06\x12\x04\x86\x1b\x0b\x11\n\r\n\x05\x04T\x02\0\
    \x01\x12\x04\x86\x1b\x12\x18\n\r\n\x05\x04T\x02\0\x03\x12\x04\x86\x1b\
    \x1b\x1c\n\x0c\n\x04\x04T\x02\x01\x12\x04\x87\x1b\x02\x1d\n\r\n\x05\x04T\
    \x02\x01\x04\x12\x04\x87\x1b\x02\n\n\r\n\x05\x04T\x02\x01\x06\x12\x04\
    \x87\x1b\x0b\x11\n\r\n\x05\x04T\x02\x01\x01\x12\x04\x87\x1b\x12\x18\n\r\
    \n\x05\x04T\x02\x01\x03\x12\x04\x87\x1b\x1b\x1c\n\x0c\n\x02\x04U\x12\x06\
    \x8b\x1b\0\x8d\x1b\x01\n\x0b\n\x03\x04U\x01\x12\x04\x8b\x1b\x08\x17\n\
    \x0c\n\x04\x04U\x02\0\x12\x04\x8c\x1b\x03-\n\r\n\x05\x04U\x02\0\x04\x12\
    \x04\x8c\x1b\x03\x0b\n\r\n\x05\x04U\x02\0\x06\x12\x04\x8c\x1b\x0c\x18\n\
    \r\n\x05\x04U\x02\0\x01\x12\x04\x8c\x1b\x19(\n\r\n\x05\x04U\x02\0\x03\
    \x12\x04\x8c\x1b+,\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
